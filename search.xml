<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51nod 1227 平均最小公倍数</title>
    <url>/51nod1227%E5%B9%B3%E5%9D%87%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求 $ \sum\limits_{i=l}^ r\dfrac{1}{i}\sum\limits_{j=1}^i\operatorname{lcm}(i,j) $ ，其中 $ 1\le l\le r\le 10^9 $ 。</p>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1227">题目链接</a></p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>众所周知， $ i\times j=\gcd(i,j)\times\operatorname{lcm}(i,j) $ 。</p>
<p>这个应该是小学只是了吧，我就不证了。（虽然我也不会比较严谨的证明）</p>
<p>加入我们要求一段区间的和，其实只需要能够求前缀就可以了。</p>
<p>所以我们来颓柿子。</p>
<h4 id="欢乐的颓柿子时间"><a href="#欢乐的颓柿子时间" class="headerlink" title="欢乐的颓柿子时间"></a>欢乐的<del>颓柿子</del>时间</h4><script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\dfrac{1}{i}\sum_{j=1}^i\operatorname{lcm}(i,j)\\
=&\sum_{i=1}^n\dfrac{1}{i}\sum_{j=1}^i\dfrac{i\times j}{\gcd(i,j)}&\textbf{使用刚才的公式}\\
=&\sum_{i=1}^n\sum_{j=1}^i\dfrac{j}{\gcd(i,j)}&\textbf{约分}\\
=&\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^i\dfrac{j}{d}\times\left[\gcd(i,j)=d\right]&\textbf{枚举}\gcd\\
=&\sum_{d=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^ij\times\left[\gcd(i,j)=1\right]&i,j\textbf{都是}d\textbf{的倍数，我们枚举他们是}d\textbf{的几倍}\\
\end{aligned}</script><p>令 $ h(n)=\sum\limits_{i=1}^ni\times [\gcd(i,n)=1] $ ， $ S(n)=\sum\limits_{i=1}^nh(i) $ 。</p>
<p>那么上式 $ =\sum\limits_{d=1}^ n\sum\limits_{i=1}^ {\left\lfloor\frac{n}{d}\right\rfloor}h(i)=\sum\limits_{d=1}^nS\left(\left\lfloor\dfrac{n}{d}\right\rfloor\right) $ 。</p>
<p>如果可以快速求出 $ S(i) $ ，那么就可以直接数论分块了。</p>
<p>那么 $ h(n) $ 代表了什么呢？</p>
<p>不就是小于等于 $ n $ 的所有正整数中，和 $ n $ 互质的所有数的和嘛！</p>
<p>所以有 $ h(n)=\dfrac{n\times\varphi(n)+[n=1]}{2} $ 。</p>
<p>为什么是这样的呢？</p>
<p>当 $ n=1 $ 时，显然没问题， $ h(1)=1 $ 。</p>
<p>当 $ n\ge2 $ 时，如果 $ \gcd(i,n)=1 $ ，那么肯定也有 $ \gcd(n-i,i)=1 $ 。</p>
<p>这告诉我们什么？不就是所有小于等于 $ n $ 的数种中与 $ n $ 互质的数的平均数为 $ \dfrac{n}{2} $ 嘛！</p>
<p>小于等于 $ n $ 的数中与 $ n $ 互质的数共有 $ \varphi(n) $ 个，所以上面式子没啥问题。</p>
<p>好，那么我们令 $ f(i)=i\varphi(i) $ ， $ S’(n)=\sum\limits_{i=1}^nf(i) $ 。</p>
<p>那么就有 $ S(n)=\dfrac{S’(n)+1}{2} $ 。</p>
<p>既然 $ f $ 是一个积性函数，并且数据范围为 $ 10^9 $ ，考虑使用杜教筛求解。</p>
<h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><p>显然， $ f=id\cdot \varphi $ ， 我们设 $ g=id $ ，下来搬出杜教筛的式子。</p>
<p>$ S(n)=\sum\limits_{i=1}^n(f\ast g)(i)-\sum\limits_{i=2}^n g(i)S\left(\left\lfloor\dfrac{n}{i}\right\rfloor\right) $ 。</p>
<p>$ f\ast g $ 又怎么求呢？</p>
<p>$ (f\ast g)(n)=\sum\limits_{d|n}f(d)g\left(\dfrac{n}{d}\right)=\sum\limits_{d|n}d\varphi(d)\times\dfrac{n}{d}=n\sum\limits_{d|n}\varphi(d)=n(\varphi\ast I)(n)=n\times id(n)=n^2 $。</p>
<p>这个直接求就可以了， $ g $ 更简单，就不说了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> ll inv2=<span class="number">500000004</span>;</span><br><span class="line"><span class="type">const</span> ll inv6=<span class="number">166666668</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,ll&gt;mf;</span><br><span class="line"><span class="type">int</span> pri[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">bool</span> is[<span class="number">1000001</span>];</span><br><span class="line">ll f[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">run</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)(r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1000000</span>) <span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">if</span>(mf.<span class="built_in">count</span>(n)) <span class="keyword">return</span> mf[n];</span><br><span class="line">    ll ans=(ll)n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*inv6%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ans=(ans-<span class="built_in">run</span>(l,r)*<span class="built_in">get</span>(n/l))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mf[n]=(ans+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getS</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ans+=(r-l+<span class="number">1</span>)*(<span class="built_in">get</span>(n/l)+<span class="number">1</span>)%mod*inv2%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    n=<span class="number">1000000</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) pri[++pri[<span class="number">0</span>]]=i,f[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i*pri[j]]=f[i]*pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i*pri[j]]=f[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=(f[i]*i+f[i<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n+1;i++) printf(&quot;%lld &quot;,get(i));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">getS</span>(r)-<span class="built_in">getS</span>(l<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
        <tag>数论分块</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1220 约数之和</title>
    <url>/51nod1220%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题意：已知 $ \sigma(i)=\sum\limits_{d|i}d $ ，求 $ \sum\limits_ {i=1}^n\sum\limits_ {j=1}^n\sigma(ij) $ ，其中 $ 1\le n\le10^9 $。</p>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1220">题目链接</a></p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先我们先来看一个结论： $ \sigma(ij)=\sum\limits_ {x|i}\sum\limits_ {y|j} xy\times\left[\gcd\left(\frac{i}{x},y\right)=1\right] $ 。其中 $ [x] $ 表示在 $ x $ 成立的时候这个值为 $ 1 $ ，不成立时这个值为 $ 0 $ 。</p>
<p>为啥这个结论是对的呢？前面的 $ xy $ 实际上是在枚举这个约数的值，但是为什么在 $ xy $ 后面还要乘上一个数字呢？</p>
<p>因为如果不乘那个数字会重复计算，例如在 $ i=6,j=3 $ 时 $ x=1,y=3 $ 和 $ x=3,y=1 $ 这两组取值都可以得到一个 $ ij $ 的约数 $ 3 $ ，这时候这个约数就被计算了两遍。加上这个约束就不会重复计算了。</p>
<p>下来我们来推式子。</p>
<h4 id="欢乐的颓柿子时间"><a href="#欢乐的颓柿子时间" class="headerlink" title="欢乐的颓柿子时间"></a>欢乐的<del>颓柿子</del>时间</h4><script type="math/tex; mode=display">
\begin{aligned}
&\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sigma(ij)\\
=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_ {x|i}^i\sum\limits_ {y|j}^j xy\times\left[\gcd\left(\frac{i}{x},y\right)=1\right]&\textbf{展开上面的式子}\\
=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_ {x|i}^i\sum\limits_ {y|j}^j \frac{iy}{x}\times\left[\gcd\left(x,y\right)=1\right]&\textbf{这里换了一下枚举的方式}\\
=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_ {x|i}^i\sum\limits_ {y|j}^j \frac{iy}{x}\times\varepsilon\left(\gcd\left(x,y\right)\right)&\varepsilon(n)\textbf{和}[n=1]\textbf{等价}\\
=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_ {x|i}^i\sum\limits_ {y|j}^j \frac{iy}{x}\times\sum\limits_{d|\gcd(x,y)}\mu(d)&\textbf{由迪利克雷卷积知}\mu\ast I=\varepsilon\\
=&\sum_{d=1}^n\mu(d)\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_ {x|i\wedge d|x}^i\kern{5pt}\sum\limits_ {y|j\wedge d|y}^j \frac{iy}{x}&\textbf{换一下枚举顺序}\\
=&\sum_{d=1}^nd\mu(d)\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_ {x|i}\sum\limits_ {y|j} \frac{iy}{x}& i,j,x,y\textbf{都是 $ d $ 的倍数，我们枚举他们是 $ d $ 的几倍}\\
=&\sum_{d=1}^nd\mu(d)\left(\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_ {x|i}\frac{i}{x}\right)\left(\sum\limits_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_ {y|j}y\right)&\textbf{换一下枚举顺序}\\
=&\sum\limits_{d=1}^nd\mu(d)\left(\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sigma(i)\right)^2&\textbf{然后会发现一些神奇的东西}\\
\end{aligned}</script><p>令 $ h(n)=\left(\sum\limits_ {i=1}^ n\sigma(i)\right)^2 $</p>
<p>那么上面的式子可以变成 $ \sum\limits_{d=1}^nd\mu(d)h\left\lfloor\frac{n}{d}\right\rfloor $ 。</p>
<p>可以发现，如果可以比较快速求出 $ h(i) $ 的值以及 $ d\mu(d) $ 的前缀和就可以对整个式子进行数论分块。</p>
<h4 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h4><p>我们先来看一下 $ h $ 的值如何求。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h(n)\\
=&\left(\sum\limits_{i=1}^n\sigma(i)\right)^2\\
=&\left(\sum\limits_{i=1}^n\sum_{j|i}j\right)^2\\
=&\left(\sum_{j=1}^nj\left\lfloor\frac{n}{j}\right\rfloor\right)^2\\
\end{aligned}</script><p>这个玩意也可以数论分块（瞬间窒息</p>
<h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h4><p>我们设 $ f(i)=i\mu(i) $ 。</p>
<p>那么我们要求的 $ S(i)=\sum\limits_{j=1}^if(j) $ 。</p>
<p>既然要在 $ 10^9 $ 范围内求一个函数（就是 $ f $ ）的前缀和，并且这还是一个积性函数，我们首先考虑杜教筛。</p>
<p>不难发现 $ f=id\cdot \mu $ ，那我们设 $ g=id $ 。</p>
<p>让我们把杜教筛的式子写出来：</p>
<script type="math/tex; mode=display">
S(n)g(1)=\sum\limits_{i=1}^n(f\ast g)(i)-\sum\limits_{i=2}^nS\left(\left\lfloor\frac{n}{i}\right\rfloor\right)g(i)</script><p>$ g $ 的前缀和挺好求，不说了。</p>
<p>我们来推一下 $ f\ast g $ 的。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n(f\ast g)(i)\\
=&\sum_{i=1}^n\sum_{d|i}d\times\mu(d)\times \frac{i}{d}\\
=&\sum_{i=1}^ni\sum_{d|i}\mu(d)\\
=&\sum_{i=1}^ni\times(\mu\ast I)(i)\\
=&\sum_{i=1}^ni\times\varepsilon(i)\\
=&1
\end{aligned}</script><p>Game over!</p>
<p>数论分块套数论分块，时间复杂度为 $ O(n^{\frac{3}{4}}) $ 。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pri[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">bool</span> is[<span class="number">1000001</span>];</span><br><span class="line">ll f[<span class="number">1000001</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;mf;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">run</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)(r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1000000</span>) <span class="keyword">return</span> f[num];</span><br><span class="line">    <span class="keyword">if</span>(mf.<span class="built_in">count</span>(num)) <span class="keyword">return</span> mf[num];</span><br><span class="line">    <span class="comment">// printf(&quot;get %d\n&quot;,num);</span></span><br><span class="line">    ll val=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;l&lt;=num;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=num/(num/l);</span><br><span class="line">        val=(val-<span class="built_in">run</span>(l,r)*<span class="built_in">get</span>(num/l))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mf[num]=(val+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getpre</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=num;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=num/(num/l);</span><br><span class="line">        ans=(ans+<span class="built_in">run</span>(l,r)*(num/l))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans*ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="number">1000000</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) pri[++pri[<span class="number">0</span>]]=i,f[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            f[i*pri[j]]=-f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=(f[i]*i+f[i<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ans=(ans+(<span class="built_in">get</span>(r)-<span class="built_in">get</span>(l<span class="number">-1</span>))*<span class="built_in">getpre</span>(n/l))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
        <tag>数论分块</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC235题解</title>
    <url>/ABC235/</url>
    <content><![CDATA[<p>本题解包含ABC235的所有题目。</p>
<span id="more"></span>
<h2 id="ABC235-A-Rotate"><a href="#ABC235-A-Rotate" class="headerlink" title="ABC235 A - Rotate"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_a">ABC235 A - Rotate</a></h2><p>给你一个三位数 $ \overline{abc} $，求 $ \overline{abc}+\overline{bca}+\overline{cab} $。</p>
<hr>
<p>分析：</p>
<script type="math/tex; mode=display">
\overline{abc}+\overline{bca}+\overline{cab}</script><script type="math/tex; mode=display">
=(100a+10b+c)+(100b+10c+a)+(100c+10a+b)</script><script type="math/tex; mode=display">
=111a+111b+111c</script><script type="math/tex; mode=display">
=111(a+b+c)</script><p>那么如何得到 $ a,b,c $ 呢？有这么几种方法：</p>
<ol>
<li><p>逐个使用<code>getchar()</code>读入。</p>
</li>
<li><p>将它们一起用<code>scanf()</code>读入到一个数组里。</p>
</li>
<li><p>将 $ \overline{abc} $ 读入，然后逐位拆开。</p>
</li>
</ol>
<p>最后输出即可。</p>
<p>时间复杂度 $ O(1) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      a=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>,b=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">111</span>*(a+b+c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-B-Climbing-Takahashi"><a href="#ABC235-B-Climbing-Takahashi" class="headerlink" title="ABC235 B - Climbing Takahashi"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_b">ABC235 B - Climbing Takahashi</a></h2><p>现在有 $ N $ 个平台从左到右排成一行，第 $ i $ 个平台高度为 $ H_i $。有一个人现在站在第一个平台上，他将要重复执行以下动作。</p>
<p>如果现在他所在的平台不是最右边的平台，且下一个平台比自己所在的这个平台高，那么他将走到下一个平台。</p>
<p>问他最后停留在的平台的高度。</p>
<p>$ 2\le N\le10^5 $</p>
<p>$ 1\le H_i\le10^9 $</p>
<hr>
<p>分析：直接模拟这个人走的过程即可。</p>
<p>当他不走的时候就输出答案就行。</p>
<p>因为这个人只会从左往右走，所以时间复杂度 $ O(n) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[i<span class="number">-1</span>])&#123; cout&lt;&lt;a[i<span class="number">-1</span>];<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-C-The-Kth-Time-Query"><a href="#ABC235-C-The-Kth-Time-Query" class="headerlink" title="ABC235 C - The Kth Time Query"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_c">ABC235 C - The Kth Time Query</a></h2><p>给定一个长度为 $ N $ 的序列 $ a $。</p>
<p>现在有 $ Q $ 次询问，第 $ i $ 次询问给定 $ x_i $ 和 $ k_i $，输出 $ x_i $ 这个数字第 $ k_i $ 次在 $ a $ 出现时的下标。没有出现过 $ k_i $ 次输出 $ -1 $。</p>
<p>$ 1\le N,Q\le 2\times10^5 $</p>
<p>$ 1\le k_i\le N(1\le i\le Q) $</p>
<p>$ 0\le x_i\le 10^9(1\le i\le Q) $</p>
<p>$ 0\le a_i\le 10^9(1\le i\le N) $</p>
<hr>
<p>首先对 $ a $ 与 $ x $ 一起进行离散化。</p>
<p>考虑统计每一个值在哪里出现过。</p>
<p>不妨对每一个序列中可能的值开一个<code>vector</code>用来统计这个值在哪里出现过。</p>
<p>然后从左到右对于每一个位置 $ i $，将 $ i $ 加入一个 $ a_i $ 对应的 vector 中。</p>
<p>因为我们是从左到右加入的，所以每个值对应的<code>vector</code>里元素是从小到大排列的。</p>
<p>查询直接访问对应的<code>vector</code>进行回答即可。</p>
<p>时间复杂度 $ O((n+q)\log (n+q)) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[<span class="number">400001</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">400001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> x[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> k[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],num[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) cin&gt;&gt;x[i]&gt;&gt;k[i],num[i+n]=x[i];</span><br><span class="line">    <span class="built_in">sort</span>(num+<span class="number">1</span>,num+n+q+<span class="number">1</span>);<span class="type">int</span> len=<span class="built_in">unique</span>(num+<span class="number">1</span>,num+n+q+<span class="number">1</span>)-num<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(num+<span class="number">1</span>,num+len+<span class="number">1</span>,a[i])-num;</span><br><span class="line">        g[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i]=<span class="built_in">lower_bound</span>(num+<span class="number">1</span>,num+len+<span class="number">1</span>,x[i])-num;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)g[x[i]].<span class="built_in">size</span>()&lt;k[i])&#123; cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        cout&lt;&lt;g[x[i]][k[i]<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-D-Multiply-and-Rotate"><a href="#ABC235-D-Multiply-and-Rotate" class="headerlink" title="ABC235 D - Multiply and Rotate"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_d">ABC235 D - Multiply and Rotate</a></h2><p>给定一个数字 $ a $ 与 $ N $，现有一个初始为 $ 1 $ 的数字 $ x $，你可以对 $ x $ 执行以下操作无数次：</p>
<ol>
<li><p>令 $ x\gets x\times a $；</p>
</li>
<li><p>当 $ x\ge 10 $ 且 $ x\nmid10 $ 时，设 $ y $ 为将 $ x $ 的末位提到最前面所得的数字，令 $ x\gets y $。</p>
</li>
</ol>
<p>求 $ x=N $ 时，操作最小次数。如果无法令 $ x=N $，输出 $ -1 $。</p>
<p>$ 2\le a,N&lt;10^6 $</p>
<hr>
<p>分析：你会发现，假如原来这个数字有 $ x $ 位，那么进行若干次操作以后这个数字的位数一定不会比 $ x $ 小。</p>
<p>从数字 $ 1 $ 出发，按照两种转移直接进行 bfs 即可。</p>
<p>时间复杂度 $ O(10^6) $</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> a,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yi</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;i++,j*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=num&amp;&amp;num&lt;<span class="number">10</span>*j)</span><br><span class="line">            <span class="keyword">return</span> j*(num%<span class="number">10</span>)+num/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;n;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;!vis[n])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>((ll)p*a&lt;=<span class="number">1000000</span>&amp;&amp;!vis[p*a])</span><br><span class="line">        &#123;</span><br><span class="line">            dis[p*a]=dis[p]+<span class="number">1</span>;</span><br><span class="line">            vis[p*a]=<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(p*a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;<span class="number">10</span>&amp;&amp;p%<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=<span class="built_in">yi</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(!vis[q])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[q]=<span class="number">1</span>;</span><br><span class="line">                dis[q]=dis[p]+<span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[n]) cout&lt;&lt;dis[n];</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-E-MST-1"><a href="#ABC235-E-MST-1" class="headerlink" title="ABC235 E - MST + 1"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_e">ABC235 E - MST + 1</a></h2><p>给定一个有 $ N $ 个顶点 $ M $ 条边的无向联通图，以及 $ Q $ 个询问。</p>
<p>每个询问 $ i $ 给定 $ u_i,v_i,w_i $ 询问，假如有一条连接顶点 $ u_i $ 与 $ v_i $ 且边权为 $ w_i $ 的边，他会不会在新图的最小生成树中。</p>
<p>$ 1\le N,M,Q\le 2\times 10^5 $</p>
<p>保证 $ w_i $ 不和原图中任何一条边的边权相等。</p>
<hr>
<p>分析：先来想一下最小生成树是怎么得到的。</p>
<p>首先我们将所有边按照边权从小到大的顺序进行排序。</p>
<p>然后贪心地加入边。</p>
<p>如果按照这样做，我们会发现这样做是 $ O(MQ) $ 的，显然无法通过。</p>
<p>然后你会发现，每一次询问问的是这条边是否会出现在最小生成树中，而不是什么其他的问题。</p>
<p>那么我们能否快速得到原图中小于某个边权的所有边构成的生成森林的样子呢？</p>
<p>显然是可以的，我们可以把所有询问离线下来。</p>
<p>我们对于输入的所有边进行排序，然后每一次不断加上原图中的边。</p>
<p>然后在这个时候跑一个双指针。</p>
<p>那么我们就可以知道原图中边权小于某一个值的边所构成生成森林的样子了。</p>
<p>这个时候直接查一下询问给出的两个点是否连通就可以了。</p>
<p>最后记得按照询问的顺序顺序输出答案。</p>
<p>时间复杂度 $ O(M\log M+Q\log Q) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> ans;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;qu[<span class="number">200001</span>],a[<span class="number">200001</span>];</span><br><span class="line"><span class="type">bool</span> qans[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> fa[num]=<span class="built_in">find</span>(fa[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) cin&gt;&gt;qu[i].u&gt;&gt;qu[i].v&gt;&gt;qu[i].w,qu[i].i=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,[](edge a,edge b)&#123; <span class="keyword">return</span> a.w&lt;b.w;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(qu+<span class="number">1</span>,qu+q+<span class="number">1</span>,[](edge a,edge b)&#123; <span class="keyword">return</span> a.w&lt;b.w;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=m&amp;&amp;j&lt;=q;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].w&lt;qu[j].w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a[i].u)==<span class="built_in">find</span>(a[i].v))&#123; i++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            fa[<span class="built_in">find</span>(a[i].u)]=<span class="built_in">find</span>(a[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(qu[j].u)!=<span class="built_in">find</span>(qu[j].v))&#123; qans[qu[j].i]=<span class="number">1</span>;&#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="keyword">if</span>(qans[i]) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-F-Variety-of-Digits"><a href="#ABC235-F-Variety-of-Digits" class="headerlink" title="ABC235 F - Variety of Digits"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_f">ABC235 F - Variety of Digits</a></h2><p>给两个数 $ N $ 与 $ M $，以及长度为 $ M $ 的序列 $ C $，保证 $ C $ 中任何数为一位数。</p>
<p>求出所有小于等于 $ N $ 且数位中出现过所有 $ C $ 的数字之和。</p>
<p>$ N\le10^ {10^4} $</p>
<p>$ 1\le M\le10 $</p>
<p>$ 0\le C_1&lt;\dots&lt;C_M\le9 $</p>
<hr>
<p>分析：很明显的数位状压 dp，没什么好说的。</p>
<p>细节非常多，具体见代码。</p>
<p>我用的是二维的 <code>dp[i][j][0\1][0\1]</code>，表示的是当前在第 $ i $ 位，已经出现的数字集合为 $ j $，前面是否全为 $ 0 $，前面是否与 $ n $ 的这些位全部相等的数字之和。</p>
<p><code>fp[i][j][0/1][0/1]</code>的含义基本一样，只不过记录的是方案数。</p>
<p>时间复杂度 $ O(\log_{10}n\times2^{10}\times10) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">ll dp[<span class="number">10001</span>][<span class="number">1024</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ll fp[<span class="number">10001</span>][<span class="number">1024</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> a[<span class="number">10002</span>];</span><br><span class="line"><span class="type">int</span> need;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;(a+<span class="number">1</span>)&gt;&gt;m;n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        need|=<span class="number">1</span>&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    fp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        fp[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1024</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]+dp[i][j][<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>)%mod;</span><br><span class="line">            fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">0</span>][<span class="number">0</span>])%mod;</span><br><span class="line">            <span class="keyword">if</span>(a[i+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=(dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]+dp[i][j][<span class="number">0</span>][<span class="number">1</span>]*<span class="number">10</span>)%mod;</span><br><span class="line">                fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=(fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]+fp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]+dp[i][j][<span class="number">0</span>][<span class="number">1</span>]*<span class="number">10</span>)%mod;</span><br><span class="line">                fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][j|<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> jj=j|(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">                dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+dp[i][j][<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>+fp[i][j][<span class="number">0</span>][<span class="number">0</span>]*k)%mod;</span><br><span class="line">                fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">0</span>][<span class="number">0</span>])%mod;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;a[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+dp[i][j][<span class="number">0</span>][<span class="number">1</span>]*<span class="number">10</span>+fp[i][j][<span class="number">0</span>][<span class="number">1</span>]*k)%mod;</span><br><span class="line">                    fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>]*k)%mod;</span><br><span class="line">                        fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k==a[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]+dp[i][j][<span class="number">0</span>][<span class="number">1</span>]*<span class="number">10</span>+fp[i][j][<span class="number">0</span>][<span class="number">1</span>]*k)%mod;</span><br><span class="line">                    fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]+fp[i][j][<span class="number">0</span>][<span class="number">1</span>])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>]*k)%mod;</span><br><span class="line">                        fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">1</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(dp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>]*k)%mod;</span><br><span class="line">                    fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]=(fp[i+<span class="number">1</span>][jj][<span class="number">0</span>][<span class="number">0</span>]+fp[i][j][<span class="number">1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++) <span class="keyword">if</span>((need&amp;i)==need)</span><br><span class="line">        ans=(ans+dp[n][i][<span class="number">0</span>][<span class="number">0</span>]+dp[n][i][<span class="number">0</span>][<span class="number">1</span>]+dp[n][i][<span class="number">1</span>][<span class="number">0</span>]+dp[n][i][<span class="number">1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-G-Gardens"><a href="#ABC235-G-Gardens" class="headerlink" title="ABC235 G - Gardens"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_g">ABC235 G - Gardens</a></h2><p>你现在有 $ N $ 个花园，以及 $ A $ 个苹果苗，$ B $ 个香蕉苗，$ C $ 个樱桃苗。你现在要将这些树苗种到花园中。</p>
<p>求出使得每个花园非空且任何一个花园不能种植两个同类树苗的方案。</p>
<p>$ 1\le N\le5\times 10^6 $</p>
<p>$ 0\le A,B,C\le N $</p>
<hr>
<p>分析：</p>
<p>首先判断一下特殊情况，如果 $ A+B+C&lt;N $ 答案为 $ 0 $。</p>
<p>下来我们来看，假如说我们不要求每个花园非空，该怎么做？</p>
<p>我们来考虑每种树苗的放置情况。</p>
<p>苹果苗可以不放，方案数为 $ C^0_n $；可以放一个，方案数为 $ C^1_n $…；可以放 $ A $ 个，方案数为 $ C^A_n $。</p>
<p>香蕉苗，樱桃苗也是一样的。</p>
<p>所以总方案数为 $ \left(\sum\limits_{i=0}^ AC^ i_n\right)\times\left(\sum\limits_{i=0}^B  C^ i_n\right)\times\left(\sum\limits_{i=0}^ CC^i_n\right) $。</p>
<p>如果说要使得他非空，再加上一个容斥就可以了。</p>
<p>因为非空的方案=所有方案-空了一个的方案+空了两个的方案……</p>
<p>可以证明是对的。</p>
<p>开开心心打完代码，发现 TLE 了。时间复杂度炸成 $ O(n^2) $。</p>
<p>考虑加速容斥的过程。想一想哪里复杂度最大？没错，求组合数的和的过程。</p>
<p>我们要对与每一个 $ i\le n $ 求出 $ \sum\limits_{j=0}^{\min(i,a)} $$ C_i^j $</p>
<p>显然，当 $ i\le a $ 时，上面的值为 $ 2^i $。</p>
<p>考虑 $ i&gt;a $ 时的情况。</p>
<script type="math/tex; mode=display">
\sum\limits_{j=0}^{\min(i,a)}C_i^j</script><script type="math/tex; mode=display">
=\sum\limits_{j=0}^aC_i^j</script><p>利用杨辉三角可以知道上面的值为 $ =\left(\sum\limits_{j=0}^ aC_{i-1}^ j\right)\times2-C_{i-1}^a $。</p>
<p>直接 $ O(1) $ 递推就行。</p>
<p>时间复杂度 $ O(n) $ 或 $ O(n\log mod) $</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">ll jc[<span class="number">5000001</span>];</span><br><span class="line">ll inv[<span class="number">5000001</span>];</span><br><span class="line">ll p[<span class="number">5000001</span>];</span><br><span class="line">ll numa,numb,numc;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> jc[b]*inv[a]%mod*inv[b-a]%mod;&#125;</span><br><span class="line"><span class="function">ll <span class="title">run</span><span class="params">(ll numa,<span class="type">int</span> a,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=i) <span class="keyword">return</span> p[i];</span><br><span class="line">    numa=numa*<span class="number">2</span>-<span class="built_in">C</span>(a,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (numa%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;sum=a+b+c;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;n)&#123; cout&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    inv[<span class="number">0</span>]=jc[<span class="number">0</span>]=p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=inv[i<span class="number">-1</span>]*<span class="built_in">qow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numa=<span class="built_in">run</span>(numa,a,i),numb=<span class="built_in">run</span>(numb,b,i),numc=<span class="built_in">run</span>(numc,c,i);</span><br><span class="line">        ll num=numa*numb%mod*numc%mod;</span><br><span class="line">        num=num*<span class="built_in">C</span>(i,n)%mod;</span><br><span class="line">        <span class="keyword">if</span>((n-i)%<span class="number">2</span>) ans=(ans-num+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+num)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC235-Ex-Painting-Weighted-Graph"><a href="#ABC235-Ex-Painting-Weighted-Graph" class="headerlink" title="ABC235 Ex - Painting Weighted Graph"></a><a href="https://atcoder.jp/contests/abc235/tasks/abc235_h">ABC235 Ex - Painting Weighted Graph</a></h2><p>给定 $ N $ 个点与 $ M $ 条边的无向图，第 $ i $ 条边连接顶点 $ A_i $ 与 $ B_i $，边权为 $ C_i $。</p>
<p>你现在可以执行以下操作。</p>
<p>每次你可以任意指定一个节点 $ v $ 与整数 $ x $，将所有从节点 $ v $ 出发只经过边权不超过 $ x $ 的边就能到达的节点全部染成红色。</p>
<p>求经过不超过 $ K $ 次操作后节点变红的集合数量。</p>
<p>$ 2\le N\le 10^5 $</p>
<p>$ 0\le M\le 10^5 $</p>
<p>$ 1\le K \le 500 $</p>
<p>$ 1\le C_i \le 10^9 $</p>
<hr>
<p>分析：</p>
<p>看到边权不超过 $ x $ 的边，你想到了什么？</p>
<p>没错！Kruskal 重构树！</p>
<p>我们把这个图的 Kruskal 重构树求出来。</p>
<p>然后你就会发现在原图中选择两个整数实际相当于在重构树上选择一个子树。</p>
<p>所以我们只需要一个树形 dp 就可以。</p>
<p>$ dp_{i,j} $ 表示在子树 $ i $ 中共染色了 $ j $ 次，可以得到多少种不同的结果。</p>
<p>看起来简单，实际上转移的时候非常复杂，很有可能算重/算漏。</p>
<p>而且因为有边权相等的情况，所以这里的 Kruskal 重构树与平时的还有些不同。</p>
<p>这里两个边如果边权一样的话，是不能成为父子关系的，具体细节可以见代码。</p>
<p>时间复杂度 $ O(NK) $。</p>
<p>你可能会说：什么？这样做时间复杂度不是 $ O(NK^2) $ 吗？</p>
<p>是的，看起来确实是 $ O(NK^2) $ 的，但实际上，他真的是 $ O(NK) $。</p>
<p>时间复杂度证明：两个子树的合并可以分为三种情况，所以分类讨论</p>
<ol>
<li><p>两个大小都大于等于 $ K $ 的子树合并；<br>可以发现，大小大于等于 $ K $ 的子树最多只有 $ \dfrac{N}{K} $ 个，也就是说最多会合并 $ \dfrac{N}{K} $ 次。<br>这部分时间复杂度 $ O(\dfrac{N}{K}\times K^2)=O(NK) $。</p>
</li>
<li><p>两个大小都小于 $ K $ 的子树合并；<br>如果两个子树大小之和小于 $ K $，我们不考虑这种情况，归类到下面。<br>如果两个子树大小之和大于等于 $ K $，设子树大小分别为 $ a,b $。<br>时间复杂度 $ T(K)=T(a)+T(b)+a\times b $。<br>在 $ a=b $ 时时间复杂度最大，此时：  </p>
<script type="math/tex; mode=display">
T(K)=2T(\dfrac{K}{2})+K^2=O(K^2)</script><p>此时合并出一个大小大于等于 $ K $ 的子树时间复杂度为 $ O(K^2) $，且这个复杂度包含了第一类情况。<br>这种最多合并 $ \dfrac{N}{K} $ 次，时间复杂度 $ O(\dfrac{N}{K}\times K^2)=O(NK) $。</p>
</li>
<li><p>一个大小大于等于 $ K $ 和一个大小小于 $ K $ 的子树合并；<br>一个大小为 $ a(a\ge K) $ 的子树与一个 $ b(b&lt;K) $ 的子树合并起来时间复杂度为 $ O(Kb) $。<br>对于所有这种情况，都有 $ \sum b\le N $。<br>所以这部分时间复杂度为 $ O(NK) $。</p>
</li>
</ol>
<p>结合上面所有情况，时间复杂度为 $ O(NK) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line">basic_string&lt;<span class="type">int</span>&gt;g[<span class="number">200001</span>],num;</span><br><span class="line">ll dp[<span class="number">200001</span>][<span class="number">501</span>];</span><br><span class="line"><span class="type">int</span> siz[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">200001</span>];</span><br><span class="line">ll h[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> fa[num]=<span class="built_in">find</span>(fa[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=n)&#123; siz[num]=<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    dp[num][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p:g[num])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=siz[num]&amp;&amp;x&lt;=k;x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x+y&lt;=k&amp;&amp;y&lt;=siz[p];y++)</span><br><span class="line">                h[x+y]=(h[x+y]+dp[num][x]*dp[p][y])%mod;</span><br><span class="line">        siz[num]+=siz[p];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=siz[num]&amp;&amp;x&lt;=k;x++) dp[num][x]=h[x],h[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num!=tot||sum==n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[num][<span class="number">1</span>]=(dp[num][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="type">int</span> s=(<span class="type">int</span>)g[num].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=k) dp[num][s]=(dp[num][s]<span class="number">-1</span>+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,dp[i][<span class="number">0</span>]=dp[i][<span class="number">1</span>]=<span class="number">1</span>,g[i]+=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,[](edge a,edge b)&#123; <span class="keyword">return</span> a.w&lt;b.w;&#125;);tot=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=m;i=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> save=tot;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=m&amp;&amp;a[i].w==a[j].w;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">find</span>(a[j].u),v=<span class="built_in">find</span>(a[j].v);</span><br><span class="line">            <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);sum++;</span><br><span class="line">            <span class="keyword">if</span>(v&lt;=save)</span><br><span class="line">            &#123;</span><br><span class="line">                tot++;val[tot]=a[j].w;</span><br><span class="line">                fa[u]=fa[v]=fa[tot]=tot;</span><br><span class="line">                g[tot]+=u,g[tot]+=v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(u&lt;=save) g[v]+=u;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i:g[u]) g[v]+=i;g[u].<span class="built_in">clear</span>();&#125;</span><br><span class="line">                fa[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="keyword">if</span>(<span class="built_in">find</span>(i)==i) num+=i;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">int</span>)num.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:num) fa[i]=tot,g[tot]+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(tot);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=(ans+dp[tot][i])%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完结撒花！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
  </entry>
  <entry>
    <title>ABC218H</title>
    <url>/ABC218H/</url>
    <content><![CDATA[<p>一道有前置题目的贪心。</p>
<p>总体看来不错，思维难度也是有的。</p>
<p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_h">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ N $ 盏台灯，你需要将它们中的 $ R $ 个点亮成红色，剩余的 $ N-R $ 个点亮成蓝色。</p>
<p>如果第 $ i $ 盏台灯和第 $ i+1 $ 盏台灯颜色不同，那么你将会获得 $ a_i $ 的收益。</p>
<p>求最大收益。</p>
<p>$ 2\leqslant N\leqslant 2\times 10^5 $</p>
<p>$ 1\leqslant R&lt;n $</p>
<p>$ 1\leqslant a_i\leqslant 10^9 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，我们不妨假设 $ 2R\leqslant N $ 。</p>
<p>因为如果 $ 2R&gt;N $ ，我们可以令 $ R\gets N-R $ ，显然答案不会变。</p>
<p>那么现在红色台灯的数量一定会小于等于蓝色台灯的数量。</p>
<p>那么我们就会有一个结论：</p>
<blockquote>
<p>所有的最优方式中，一定存在一个方案，使得不会有任何两个红色台灯相邻摆放</p>
</blockquote>
<p>考虑证明这个结论。</p>
<p>我们首先从左到右找到第一个极长的红色块 $ [l,r] $ ，满足 $ r&gt;l $ 。</p>
<p>假如此时 $ l\ne1 $ ，那么根据假设，第 $ l-1 $ 个位置肯定是蓝色的台灯。</p>
<p>假如此时第 $ l-2 $ 个位置没有台灯或者台灯是蓝色，我们直接将 $ l-1 $ 和 $ l $ 上的颜色互换，答案显然会增加 $ a_{l-1}+a_{l+1} $ 。</p>
<p>否则，第 $ l $ 个位置以前肯定是若干个“单独”的红色台灯。</p>
<p>这个时候，找到 $ l $ 以左的，最靠右的，相邻的两个蓝色台灯。</p>
<p>如果可以找到，那么我们将这两个台灯以右的所有红色台灯，向左移一个位置·，这样子答案照样会增加，并且我们将第 $ l $ 个位置的红色台灯，挪到了第 $ l-1 $ 个位置。</p>
<p>注意到这个时候 $ R\leqslant N-R $ ，所以如果左边不能移动，那么右边按照同样的方法，肯定可以移动。</p>
<p>所以这个结论就是正确的。</p>
<p>这个时候我们就可以转化问题，成下面这个样子：</p>
<blockquote>
<p>现在有一个长度为 $ N $ 的序列 $ b $ ，满足 $ b_i=a_{i-1}+a_i $ ，这里 $ a_0=a_n=0 $ 。</p>
<p>现在你需要在上面选出 $ R $ 个点，使得这些点互不相邻，这个选点方案的价值为所有选的点 $ b $ 值的和。</p>
<p>求所有方案，权值的最大值。</p>
</blockquote>
<p>你有没有发现，这个样子虽然转化了，但是好像和没有转化差不多，都是一样难做。</p>
<p>但是这道题是一道带悔贪心，并且有原题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3620">luoguP3620</a></p>
<p>上面的题只要做一下差分，就和我们转化后的题意一样了（并且上面这道题做法的第一步就是差分）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pli&gt;que;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> in[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">200001</span>];</span><br><span class="line">ll s[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),m=<span class="built_in">min</span>(m,n-m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) in[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=in[i]+in[i+<span class="number">1</span>];</span><br><span class="line">        l[i]=i<span class="number">-1</span>,r[i]=i+<span class="number">1</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">pli</span>(s[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;r[n]=n,s[<span class="number">0</span>]=s[n]=<span class="number">-0x3f3f3f3f3f3f3f</span>ll;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(vis[que.<span class="built_in">top</span>().second]) que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> wh=que.<span class="built_in">top</span>().second;que.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=s[wh],vis[l[wh]]=vis[r[wh]]=<span class="number">1</span>;</span><br><span class="line">        s[wh]=s[l[wh]]+s[r[wh]]-s[wh];</span><br><span class="line">        l[wh]=l[l[wh]],r[wh]=r[r[wh]];</span><br><span class="line">        l[r[wh]]=r[l[wh]]=wh;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">pli</span>(s[wh],wh));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11 7</span></span><br><span class="line"><span class="comment">12345 678 90123 45678901 234567 89012 3456 78901 23456 7890</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC228题解</title>
    <url>/ABC228/</url>
    <content><![CDATA[<p>本题解包含ABC228的所有题目。</p>
<span id="more"></span>
<h2 id="ABC228-A-On-and-Off"><a href="#ABC228-A-On-and-Off" class="headerlink" title="ABC228 A - On and Off"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_a">ABC228 A - On and Off</a></h2><p>一个人每天在 $ S $ 时开灯， $ T $ 时关灯，求在 $ X $ 时过 $ 30 $ 分钟后等是否时开着的。</p>
<p>$ 0\le S,T,X\le 23 $</p>
<p>$ S\ne T $</p>
<hr>
<p>分析：</p>
<p>本题主要难点在于 $ T $ 可能是小于 $ S $ 的。</p>
<p>那么当 $ T&lt;S $ 时我们令 $ T\gets T+24 $ ，这样就可以保证 $ S&lt;T $ 了。</p>
<p>但是这个时候就会遇到一个问题：如果原来有 $ X&lt;T&lt;S $ ，这种方案显然是合法的。</p>
<p>在操作完之后就会有 $ X&lt;S&lt;T $ ，我们的程序不能正确判断。</p>
<p>那么如果这个时候有 $ X&lt;S $ ，我们再令 $ X\gets X+24 $ 。</p>
<p>最后只需要看是否有 $ S\le X&lt;T $ 就好了。</p>
<p>注意题目中问的是 $ X $ 时<strong>过 $ 30 $ 分钟</strong>灯是否开启，所以 $ X=T $ 是不行的。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> s,t,x;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;s) t+=<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;s) x+=<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=x&amp;&amp;x&lt;t) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-B-Takahashi’s-Secret"><a href="#ABC228-B-Takahashi’s-Secret" class="headerlink" title="ABC228 B - Takahashi’s Secret"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_b">ABC228 B - Takahashi’s Secret</a></h2><p>高桥有 $ N $ 个朋友，被称为 Friend $ 1 $ ,Friend $ 2\dots $ ,Firend $ N $。</p>
<p>有一天，高桥不小心人让 Friend $ X $ 知道了他的可耻的秘密。</p>
<p>如果第 $ i $ 个朋友知道了高桥的秘密，那么他就会把这个秘密告诉第 $ A_i $ 个朋友（如果第 $ A_i $ 个朋友还不知道这个秘密的话）。</p>
<p>求最后有多少人会知道高桥的秘密。</p>
<p>$ 2\le N\le10^5 $</p>
<p>$ 2\le X\le N $</p>
<p>$ 1\le A_i\le N $</p>
<p>$ A_i\ne i $</p>
<hr>
<p>分析：</p>
<p>直接按照题意，模拟每个朋友知道这个秘密的顺序。</p>
<p>最后一遍模拟一遍计算答案即可。</p>
<p>因为每个朋友最多知道这个秘密一次，所以时间复杂度为 $ O(n) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;;i=a[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">break</span>;</span><br><span class="line">        vis[i]=<span class="number">1</span>;ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-C-Final-Day"><a href="#ABC228-C-Final-Day" class="headerlink" title="ABC228 C - Final Day"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_c">ABC228 C - Final Day</a></h2><p>现在有 $ N $ 名学生正在参加为期 $ 4 $ 天的考试。</p>
<p>每天考试的满分均为 $ 300 $ 分， $ 4 $ 天的总共的分数为 $ 1200 $分。</p>
<p>目前前三天的考试已经完成了，第 $ i(1\le i\le N) $ 个学生在第 $ j(1\le j\le 3) $ 的考试中拿到了 $ P_{i,j} $ 分。</p>
<p>对于每个学生，请确定他是否有可能在第四天考试后排名在前 $ K $ 。</p>
<p>注：第四天之后的学生排名定义为四天总成绩高于该学生的学生人数再加1。</p>
<p>$ 1\le K\le N\le 10^5 $</p>
<p>$ 0\le P_{i,j}\le 300(1\le i\le N,1\le j\le 3) $</p>
<hr>
<p>显然，当其他学生第四天考试成绩一直的情况下，某个学生第四天成绩越好，排名就越靠前。</p>
<p>所以当某个学生第 $ 4 $ 天考了 $ 300 $ 分，其他所有学生都考了 $ 0 $ 分的时候，这个学生能取得自己最高的排名。</p>
<p>对于每一个学生，我们只需要检查这个排名与 $ K $ 之间的大小关系就可以了。</p>
<p>排序即可，时间复杂度为 $ O(n\log n) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[i]=num[i]=x+y+z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(num+<span class="number">1</span>,num+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+<span class="number">300</span>&gt;=num[n-k+<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-D-Linear-Probing"><a href="#ABC228-D-Linear-Probing" class="headerlink" title="ABC228 D - Linear Probing"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_d">ABC228 D - Linear Probing</a></h2><p>有一个序列 $ A=(A_0,A_1,\dots,A_{N-1}),N=2^{20} $ ，并且所有数字一开始都为 $ -1 $ 。</p>
<p>现在有 $ Q $ 个查询，每个查询由两个数字 $ t_i,x_i $ 组成。</p>
<p>当 $ t_i=1 $ 时，找到 $ \bmod N $ 意义下大于等于 $ x_i $ 的第一个不等于 $ -1 $ 的数字，并将这个数字改成 $ x_i $。</p>
<p>当 $ t_i=2 $ 时，查询 $ A_{x_i\bmod N} $ 的值。</p>
<p>$ 1\le Q\le 2\times 10^5 $</p>
<p>$t_i\in\{1,2\}(1\le i\le N)$</p>
<p>$ 1\le x_i\le 10^{18}(1\le i\le Q) $</p>
<p>存在至少一个 $ i $ 使得 $ t_i=2 $ 。</p>
<hr>
<p>由于每一次只会更改一个地方的值，我们考虑维护这个序列。</p>
<p>现在的目标是快速找到某一个位置以后第一个为 $ -1 $ 的地方。</p>
<p>我们可以使用一个并查集，在初始的时候并查集每一个元素都指向自己。</p>
<p>在我们更改一个位置的值以后，将这个位置向它下一个位置合并过去。</p>
<p>这样子每一次从一个地方开始<code>find()</code>到的元素就是题目中要找的位置了。</p>
<p>查询的时候直接输出就可以了。</p>
<p>时间复杂度 $ O(n+\alpha(n)Q) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1048576</span>];</span><br><span class="line">ll a[<span class="number">1048576</span>];</span><br><span class="line"><span class="type">int</span> n=<span class="number">1048576</span>;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> fa[num]=<span class="built_in">find</span>(fa[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) fa[i]=i,a[i]=<span class="number">-1</span>;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;ll x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val=<span class="built_in">find</span>(x%n);</span><br><span class="line">            a[val]=x;</span><br><span class="line">            fa[val]=fa[val+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[x%n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-E-Integer-Sequence-Fair"><a href="#ABC228-E-Integer-Sequence-Fair" class="headerlink" title="ABC228 E - Integer Sequence Fair"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_e">ABC228 E - Integer Sequence Fair</a></h2><p>现在有许多个长度为 $ N $ 的整数序列，每个序列中的数字都在 $ [1,K] $ 内。</p>
<p>你现在要给每一个整数序列打分，分数是一个属于 $ [1,M] $ 的整数。</p>
<p>请问共有多少种不同的打分方案。（当有任何一个序列在两种方案中得到的分数不同时，这两个方案不同）</p>
<p>$ 1\le N,K,M\le 10^{18} $</p>
<hr>
<p>分析：显然，不同的序列共有 $ K^N $ 种，而分数也有 $ M $ 种取值。</p>
<p>所以答案为 $ M^ {K^N} $ ，使用欧拉定理直接算就可以 。</p>
<p>注：指数向 $ 998244352 $ 取模，每一次快速幂前记得先将底数取模。</p>
<p>时间复杂度 $ O(\log mod) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,ll b,<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">ll n,k,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;k%=(mod<span class="number">-1</span>),m%=mod;</span><br><span class="line">    ll num=<span class="built_in">qow</span>(k,n,mod<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qow</span>(m,num,mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-F-Stamp-Game"><a href="#ABC228-F-Stamp-Game" class="headerlink" title="ABC228 F - Stamp Game"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_f">ABC228 F - Stamp Game</a></h2><p>本题解包含ABC228的所有题目。</p>
<!--more-->
<p>现在有一个 $ H\times W $ 的方格，每个方格上都有一个数字。</p>
<p>从上面数第 $ i $ 行从左数第 $ j $ 列的格子上面的数字为 $ A_{i,j} $ 。</p>
<p>一开始的时候这些格子都是白色的。</p>
<p>现在又两个人，他们要进行一下操作：</p>
<ol>
<li><p>第一个人选一个高为 $ h_1 $ ，宽为 $ w_1 $ 的矩阵，并将这里的所有数字都涂黑。</p>
</li>
<li><p>第二个人在第一个人涂完后，选择一个高为 $ h_2 $ ，宽为 $ w_2 $ 的矩阵，并将这里的所有数字涂白。</p>
</li>
</ol>
<p>如果一个格子先被涂黑，再被涂白，那么这个格子最终是白色的。（意思就是每个格子最后的颜色取决于最后一次涂上了什么色，如果没有涂色那它就是白的）</p>
<p>第一个人想要让黑色的方格里数字之和最大化，第二个人想要让黑色的方格里数字之和最小化。</p>
<p>求最后这个黑色方格里面的数字之和是多少。</p>
<p>$ 1\le H,W\le 1000 $</p>
<p>$ 1\le h_1,h_2 \le H $</p>
<p>$ 1\le w_1,w_2 \le W $</p>
<p>$ 1\le A_{i,j}\le 10^9 $</p>
<hr>
<p>分析：首先我们可以令 $ h_2\gets \min(h_1,h_2),w_2\gets \min(w_1,w_2) $ 。</p>
<p>因为第二个人知道第一个人将哪些格子涂黑了，所以当 $ h_2&gt;h_1 $ 或 $ w_2&gt;w_1 $ 时，多出来的这部分实际上是没有意义的。</p>
<p>接下来我们不妨来枚举一下第一个人选的方格是哪一个。</p>
<p>这一步显然是 $ HW $ 的。</p>
<p>我们可以提前预处理出前缀和，这样我们就可以快速求得第一个人选择的方块中的数字之和。</p>
<p>那么如果第一个人已经确定了要选这个矩阵，第二个人会选哪一个矩阵呢？</p>
<p><del>用脑子稍微想一下你会发现，</del>他选的一定是和最大的那一个。</p>
<p>这不就好办了。</p>
<p>我们提前预处理出第二个人选每一个矩阵能够减少的贡献是多少。</p>
<p>然后枚举第一个人选的是哪一个矩阵，然后利用某些东西求出第二个人选的是哪一个矩阵，最后答案取最大值，不就可以了吗？</p>
<p>那我们用什么东西来维护第二个人选择哪个矩阵呢？</p>
<p>我们其实需要一个可以快速得到某一个二位区间（就是一个矩阵）中数字的最小值的东西。</p>
<p>直接二维线段树/二维st表搞定。</p>
<p>时间复杂度为 $ O(HW\log H\log W) $ 。</p>
<p>代码里用的是二维线段树。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll num[<span class="number">4001</span>][<span class="number">4001</span>];</span><br><span class="line">ll pre[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">ll b[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> v,<span class="type">int</span> vl,<span class="type">int</span> vr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vl==vr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pl==pr) num[p][v]=b[pl][vl];</span><br><span class="line">        <span class="keyword">else</span> num[p][v]=<span class="built_in">max</span>(num[p*<span class="number">2</span>][v],num[p*<span class="number">2</span>|<span class="number">1</span>][v]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(vl+vr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p,pl,pr,v*<span class="number">2</span>,vl,mid);</span><br><span class="line">    <span class="built_in">build</span>(p,pl,pr,v*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,vr);</span><br><span class="line">    num[p][v]=<span class="built_in">max</span>(num[p][v*<span class="number">2</span>],num[p][v*<span class="number">2</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl!=pr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p*<span class="number">2</span>,pl,mid);</span><br><span class="line">        <span class="built_in">build</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(p,pl,pr,<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v,<span class="type">int</span> vl,<span class="type">int</span> vr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=vl&amp;&amp;vr&lt;=r) <span class="keyword">return</span> num[p][v];</span><br><span class="line">    <span class="type">int</span> mid=(vl+vr)&gt;&gt;<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">get</span>(p,v*<span class="number">2</span>,vl,mid,l,r));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) ans=<span class="built_in">max</span>(ans,<span class="built_in">get</span>(p,v*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,vr,l,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> u,<span class="type">int</span> d,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=pl&amp;&amp;pr&lt;=d) <span class="keyword">return</span> <span class="built_in">get</span>(p,<span class="number">1</span>,<span class="number">1</span>,m,l,r);</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">get</span>(p*<span class="number">2</span>,pl,mid,u,d,l,r));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;d) ans=<span class="built_in">max</span>(ans,<span class="built_in">get</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,u,d,l,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">    x2=<span class="built_in">min</span>(x2,x1),y2=<span class="built_in">min</span>(y2,y1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line">        pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x2;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=y2;j&lt;=m;j++)</span><br><span class="line">        b[i][j]=pre[i][j]-pre[i-x2][j]-pre[i][j-y2]+pre[i-x2][j-y2];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x1;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=y1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num=pre[i][j]-pre[i-x1][j]-pre[i][j-y1]+pre[i-x1][j-y1];</span><br><span class="line">        num-=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,i-x1+x2,i,j-y1+y2,j);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-G-Digits-on-Grid"><a href="#ABC228-G-Digits-on-Grid" class="headerlink" title="ABC228 G - Digits on Grid"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_g">ABC228 G - Digits on Grid</a></h2><p>现在有一个 $ H\times W $ 的方格，每一个方格上都有一个在 $ 1 $ 到 $ 9 $ 之间的整数。从上数第 $ i $ 行左数第 $ j $ 列的方格上写的数字为 $ c_{i,j} $ 。</p>
<p>一开始的时候有一个棋子在这个网格上，并且还有一个数字 $ X $ 。$ X $ 初始为 $ 0 $ 。</p>
<p>你现在要做以下操作 $ N $ 次。</p>
<ol>
<li><p>将这个棋子移到同行的任何一个格子上（可以不移）。</p>
</li>
<li><p>将现在棋子所在方格上面的数字添加在 $ X $ 的末尾。</p>
</li>
<li><p>将这个棋子移到同列的任何一个格子上（可以不移）。</p>
</li>
<li><p>将现在棋子所在方格上面的数字添加在 $ X $ 的末尾。</p>
</li>
</ol>
<p>这个棋子一开始可以在任何一个位置，求最后 $ X $ 可以变成多少个不同的数字，对 $ 998244353 $ 取模。</p>
<p>注：如果有多种方法使得 $ X $ 变为一个数字，只算一次。</p>
<p>$ 1\le H,W \le 10 $</p>
<p>$ 1\le N\le 300 $</p>
<p>$ 1\le c_{i,j}\le 9 $</p>
<hr>
<p>分析：</p>
<p>不得不说，这是一道神仙题。</p>
<p>首先我们将题意进行转化：</p>
<blockquote>
<p>现在有一个二分图，左边有 $ H $ 个点，右边有 $ W $ 个点。</p>
<p>左边的每一个点与右边的每一个点都有连边，其中左边的第 $ i $ 个点与右边的第 $ j $ 个点之间的边有边权 $ c_{i,j} $ 。</p>
<p>现在有一个棋子在左边的任何一个点上，现在棋子要在这个图上沿着走 $ 2N $ 步，每走一步就要将走过边上的边权加到 $ X $ 的末尾，求 $ X $ 最后有多少可能的取值。</p>
</blockquote>
<p>不难发现，这个问题和刚刚问题的答案是一样的。</p>
<p>再联系到 $ 10 $ 的数据范围，我们不难想到状压dp。</p>
<p>我们不妨先令 $ dp_{sta,i} $ 表示走完 $ i $ 步以后，可以由 $ sta $ 中的点结尾走出的字符串的个数。</p>
<p>然后你就会发现这种玩意会算重。</p>
<p>那么我们能不能去一下重呢？</p>
<p>于是乎，就有一个神奇的状压dp出现了：</p>
<p>令 $ dp_{sta,i} $ 表示当前已经走了 $ i $ 步，能且仅能在以 $ sta $ 表示的节点作为当前节点表示出的字符串有多少。</p>
<p>举个例子，假如现在已经走过了 $ 3 $ 步，现在有 $ 34,54,64 $ 一共 $ 3 $ 个 $ X $ 可以且仅可以以第 $ 1 $ 个点为最后一个点走出，那么就有 $ dp_{sta_1,3}=3 $ 。</p>
<p>最后对 $ i $ 的奇偶性讨论进行转移即可。</p>
<p>时间复杂度 $ O(N(2^ H+2^W)) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">bool</span> num[<span class="number">20</span>][<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line">ll dp[<span class="number">601</span>][<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> in[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> m,n,k;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;in[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            val[i][in[i][j]-<span class="string">&#x27;0&#x27;</span>]|=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            val[j+m][in[i][j]-<span class="string">&#x27;0&#x27;</span>]|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k*<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fr=<span class="number">1</span>;fr&lt;(<span class="number">1</span>&lt;&lt;n);fr++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=<span class="number">9</span>;w++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> can=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(fr&amp;(<span class="number">1</span>&lt;&lt;j)) can|=val[j+m][w];</span><br><span class="line">                    dp[i+<span class="number">1</span>][can]=(dp[i+<span class="number">1</span>][can]+dp[i][fr])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fr=<span class="number">1</span>;fr&lt;(<span class="number">1</span>&lt;&lt;m);fr++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=<span class="number">9</span>;w++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> can=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="keyword">if</span>(fr&amp;(<span class="number">1</span>&lt;&lt;j)) can|=val[j][w];</span><br><span class="line">                    dp[i+<span class="number">1</span>][can]=(dp[i+<span class="number">1</span>][can]+dp[i][fr])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="built_in">max</span>(m,n));i++) ans=(ans+dp[k*<span class="number">2</span>][i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ABC228-H-Histogram"><a href="#ABC228-H-Histogram" class="headerlink" title="ABC228 H - Histogram"></a><a href="https://atcoder.jp/contests/abc228/tasks/abc228_h">ABC228 H - Histogram</a></h2><p>现在有两个长度为 $ N $ 的序列 $ A=(A_1,A_2,\dots,A_N) $ 和 $ C=(C_1,C_2,\dots,C_N) $ 。</p>
<p>你现在可以进行以下操作任意多次（不进行也可以）：</p>
<ol>
<li><p>选择一个 $ i $ 使得 $ 1\le i\le N $ 。</p>
</li>
<li><p>花费 $ C_i $ 的代价使得 $ A_i\gets A_i+1 $ 。</p>
</li>
</ol>
<p>最终的序列也有一个成本为 $ XK $ 。</p>
<p>其中 $ X $ 为输入中给定的数据， $ K $ 为最后 $ A $ 中不同的数字个数。</p>
<p>问最小的代价是多少。</p>
<p>代价为进行操作的代价加上最后序列的成本。</p>
<p>$ 1\le N\le 2\times 10^5 $</p>
<p>$ 1\le X\le 10^6 $</p>
<p>$ 1\le A_i,C_i\le 10^6(1\le i\le N) $</p>
<hr>
<p>分析：</p>
<p>不得不说，这还是一道神仙题。</p>
<p>首先我们将这两个序列进行排序，使得 $ A $ 序列单调不降。</p>
<p>为了方便，我们令 $ A’ $ 表示所有操作结束后 $ A $ 的值。</p>
<p>因为我们已经将 $ A $ 从小到大进行排序，所以会有：</p>
<blockquote>
<p>A’单调不降</p>
</blockquote>
<p>为什么呢？</p>
<p>假设存在两个下标 $ i,j $ 满足 $ i&lt;j,A’_i&gt;A’_j $ 。</p>
<p>因为我们之前排了序，所以还会有 $ A_i&lt;A_j $</p>
<p>那么这种情况显然不是最优的。</p>
<p>如果我们令 $ A’_j\gets A’_i $ ，那么操作的代价比原来小，最后序列的成本不比原来大，那么这种情况一定更优。</p>
<p>所以这是正确的。</p>
<p>那么一定就会存在两个序列 $ P,Q $ 使得：</p>
<p>$ 0=P_0&lt;P_1&lt;P_2&lt;\dots&lt;P_K=N $</p>
<p>$ 1\le Q_1&lt;Q_2&lt;\dots &lt;Q_K $</p>
<p>$ \forall P_{k-1}&lt;i\le P_k:A’_i=Q_k $</p>
<p>这个也很好理解，因为 $ A’ $ 不降，所以就会分成若干段，使得每一段内值都相同。</p>
<p>然后呢？</p>
<p>然后dp呀。</p>
<p>我们设 $ dp_i $ 为前 $ i $ 个元素的答案。</p>
<p>那么 $ A’ $ 中最后的一段的值肯定都为 $ A_i $ ，我们枚举上一段的末尾位置 $ j $ 。</p>
<p>就会有 $ dp_i=\min\limits_{j=0}^ {i-1}(dp_j+X+\sum\limits_{k=j+1}^i(A_i-A_k)C_k) $ 。</p>
<p>然后你就可以快乐的 $ O(n^2) $ 计算。</p>
<p>然后 $ 1 $ 分都拿不上。</p>
<p>考虑优化转移。</p>
<p>令 $ prec_i=\sum\limits_{j=1}^ iC_j,preac_i=\sum\limits_{j=1}^iA_jC_j $ 。</p>
<p>假设 $ dp_i $ 由 $ dp_j $ 转移而来，那么就会有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp_i&=dp_j+X+\sum_{k=j+1}^i(A_i-A_k)C_k\\
dp_i&=dp_j+X+A_i(prec_i-prec_j)-(preac_i-preac_j)\\
dp_i&=dp_j+X+A_iprec_i-A_iprec_j-preac_i+preac_j\\
dp_i-X-A_iprec_i+preac_i&=dp_j+preac_j-A_iprec_j
\end{aligned}</script><p>有没有发现哪里不对？</p>
<p>这个玩意可以斜率优化！</p>
<p>令 $ b_i=dp_i-X-A_iprec_i+preac_i,y_i=dp_i+preac_i,k_i=A_i,x_i=prec_i $</p>
<p>那么就有 $ b_i=y_j-k_ix_j $ 。</p>
<p>直接一个二分+斜优就可以了。</p>
<p>时间复杂度 $ O(n\log n) $ 。</p>
<p>注：事实上那个 $ A_iC_i $ 每一项都有，可以提到外面算。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,c;</span><br><span class="line">&#125;in[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> que[<span class="number">200001</span>];</span><br><span class="line">ll pre[<span class="number">200001</span>];</span><br><span class="line">ll dp[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">131072</span>;i;i&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(ans+i&lt;=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=que[ans+i<span class="number">-1</span>],y=que[ans+i];</span><br><span class="line">            <span class="keyword">if</span>((dp[y]-dp[x])&lt;k*(pre[y]-pre[x])) ans+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> que[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;head=tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i].a&gt;&gt;in[i].c;</span><br><span class="line">    <span class="built_in">sort</span>(in+<span class="number">1</span>,in+n+<span class="number">1</span>,[](node a,node b)&#123; <span class="keyword">return</span> a.a&lt;b.a;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=in[i].c+pre[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="built_in">run</span>(in[i].a);</span><br><span class="line">        dp[i]=dp[j]+(pre[i]-pre[j])*in[i].a+x;</span><br><span class="line">        <span class="keyword">while</span>(tail&gt;head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=que[tail<span class="number">-1</span>],y=que[tail];</span><br><span class="line">            <span class="keyword">if</span>((__int128)(dp[y]-dp[x])*(pre[i]-pre[y])&lt;(__int128)(dp[i]-dp[y])*(pre[y]-pre[x])) <span class="keyword">break</span>;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        que[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[n]-=(ll)in[i].a*in[i].c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完结撒花！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
  </entry>
  <entry>
    <title>ABC263H</title>
    <url>/ABC263H/</url>
    <content><![CDATA[<p>一道看起来难，但是知道算法后让你称妙的题。</p>
<p>打的时候还会发现很难打……</p>
<p><a href="https://atcoder.jp/contests/abc263/tasks/abc263_h">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在平面上有 $ N(N\leqslant 5\times 10^4) $ 条直线，每条直线方程为 $ Ax+By+C=0(|A|,|B|,|C|\leqslant 10^3) $ 。</p>
<p>不存在互相平行的直线。</p>
<p>相交的直线会有交点，他们一共会形成 $ \dfrac{N(N-1)}{2} $ 个交点；假如多个直线交于一点，交点要当成多个计算。</p>
<p>求这些交点中，和原点第 $ K(K\leqslant \dfrac{N(N-1)}{2}) $ 近的那个点，到原点的距离。</p>
<p>时限 $ 7s $ 。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，这题我们不能直接暴力计算原点坐标。</p>
<p>考虑进行二分答案。</p>
<p>现在我们的目标就变成了：给出一个圆心为原点的圆，求圆内有多少个交点。</p>
<p>首先，我们可以只看某条直线在圆内的部分，这明显是一条线段。</p>
<p>而且我们可以比较轻松地求出这条线段端点的坐标，<a href="https://shijiuwan.github.io/直线和圆交点公式/">具体求法看这里</a>。</p>
<p>然后，我们可以通过反三角函数，求出这些端点对于圆的方位角。</p>
<p>这样子，我们就可以知道端点之间的相对位置。</p>
<p>那么如果两条线段相交了，它们就会满足类似这样的关系：$ L_i\leqslant L_j\leqslant R_i\leqslant R_j $ 。</p>
<p>直接树状数组算就可以了。</p>
<p>没错，这题的算法就是这么简单。</p>
<p>但是它在Atocder的评分高达 $ 3041 $ ，当场也只有 $ 11 $ 位大佬场切。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ld PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> ld eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> i&amp;(-i);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;seg[<span class="number">50001</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">50001</span>];</span><br><span class="line">ld num[<span class="number">100001</span>];</span><br><span class="line">ld lth[<span class="number">50001</span>];</span><br><span class="line">ld rth[<span class="number">50001</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> A[<span class="number">50001</span>];</span><br><span class="line"><span class="type">int</span> B[<span class="number">50001</span>];</span><br><span class="line"><span class="type">int</span> C[<span class="number">50001</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line"><span class="function">ld <span class="title">get_theta</span><span class="params">(ld x,ld y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(x)&lt;=eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;=<span class="number">0</span>) <span class="keyword">return</span> PI/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> PI*<span class="number">3</span>/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ld k=y/x;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">0</span>) k=-k;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) k=-k;</span><br><span class="line">    ld ans=<span class="built_in">atan</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) ans=PI-ans;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">0</span>) ans=<span class="number">2</span>*PI-ans;</span><br><span class="line">    <span class="comment">// printf(&quot;%.6Lf %.6Lf : %.6Lf %.6Lf %.6Lf\n&quot;,x,y,k,ans,ans/PI*180);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=tot)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]++;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cal</span><span class="params">(ld r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;r=%.8Lf\n&quot;,r);</span></span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(B[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ld x=-<span class="built_in">ld</span>(C[i])/A[i];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;r) vis[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(x-r)&lt;=eps) </span><br><span class="line">            &#123;</span><br><span class="line">                ld y=<span class="number">0</span>;</span><br><span class="line">                lth[i]=rth[i]=<span class="built_in">get_theta</span>(x,y);</span><br><span class="line">                num[++tot]=lth[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ld y1=<span class="built_in">sqrtl</span>(r*r-x*x);</span><br><span class="line">                ld y2=-y1;</span><br><span class="line">                <span class="comment">// printf(&quot;%6Lf %6Lf &quot;,x,y1);</span></span><br><span class="line">                <span class="comment">// printf(&quot;%6Lf %6Lf\n&quot;,x,y2);</span></span><br><span class="line">                lth[i]=<span class="built_in">get_theta</span>(x,y1);</span><br><span class="line">                rth[i]=<span class="built_in">get_theta</span>(x,y2);</span><br><span class="line">                <span class="keyword">if</span>(lth[i]&gt;rth[i]) <span class="built_in">swap</span>(lth[i],rth[i]);</span><br><span class="line">                num[++tot]=lth[i];</span><br><span class="line">                num[++tot]=rth[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ld a=A[i]*A[i]+B[i]*B[i];</span><br><span class="line">        ld b=<span class="number">2</span>*A[i]*C[i];</span><br><span class="line">        ld c=C[i]*C[i]-r*r*B[i]*B[i];</span><br><span class="line">        ld delta=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">        <span class="keyword">if</span>(delta&lt;-eps) vis[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(delta)&lt;=eps)</span><br><span class="line">        &#123;</span><br><span class="line">            ld x=-b/a/<span class="number">2</span>;</span><br><span class="line">            ld y=-(A[i]*x+C[i])/B[i];</span><br><span class="line">            lth[i]=rth[i]=<span class="built_in">get_theta</span>(x,y);</span><br><span class="line">            num[++tot]=lth[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ld x1=(-b+<span class="built_in">sqrtl</span>(delta))/a/<span class="number">2</span>;</span><br><span class="line">            ld y1=-(A[i]*x1+C[i])/B[i];</span><br><span class="line">            ld x2=(-b-<span class="built_in">sqrtl</span>(delta))/a/<span class="number">2</span>;</span><br><span class="line">            ld y2=-(A[i]*x2+C[i])/B[i];</span><br><span class="line">            <span class="comment">// printf(&quot;%6Lf %6Lf &quot;,x1,y1);</span></span><br><span class="line">            <span class="comment">// printf(&quot;%6Lf %6Lf\n&quot;,x2,y2);</span></span><br><span class="line">            lth[i]=<span class="built_in">get_theta</span>(x1,y1);</span><br><span class="line">            rth[i]=<span class="built_in">get_theta</span>(x2,y2);</span><br><span class="line">            <span class="keyword">if</span>(lth[i]&gt;rth[i]) <span class="built_in">swap</span>(lth[i],rth[i]);</span><br><span class="line">            num[++tot]=lth[i];</span><br><span class="line">            num[++tot]=rth[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(num+<span class="number">1</span>,num+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(num+<span class="number">1</span>,num+tot+<span class="number">1</span>)-num<span class="number">-1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        seg[cnt].l=<span class="built_in">lower_bound</span>(num+<span class="number">1</span>,num+len+<span class="number">1</span>,lth[i])-num;</span><br><span class="line">        seg[cnt].r=<span class="built_in">lower_bound</span>(num+<span class="number">1</span>,num+len+<span class="number">1</span>,rth[i])-num;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;,seg[cnt].l,seg[cnt].r);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(seg+<span class="number">1</span>,seg+cnt+<span class="number">1</span>,[](node a,node b)&#123;<span class="keyword">return</span> a.l&lt;b.l;&#125;);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) t[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">get</span>(seg[i].r)-<span class="built_in">get</span>(seg[i].l<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(seg[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,A+i,B+i,C+i);</span><br><span class="line">    ld ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ld i=<span class="number">2097152</span>;i&gt;=eps;i/=<span class="number">2</span>) <span class="keyword">if</span>(!<span class="built_in">cal</span>(ans+i)) ans+=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8Lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码是真难打。</p>
<p>我数学贼烂，解析几何和三角函数都不会……</p>
<p>所以代码打得又臭又长。</p>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>解析几何</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC264H</title>
    <url>/ABC264H/</url>
    <content><![CDATA[<p>一个比较简单的dp。</p>
<p>从暴力到正解实际上只有一个第一眼感觉没用的小优化。</p>
<p><a href="https://atcoder.jp/contests/abc264/tasks/abc264_h">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给了你一棵有根树，现在让你在 $ 1\sim k $ 中选一些点，满足以下要求：</p>
<ol>
<li>$ 1 $ 需要被选；</li>
<li>所有被选的点构成了一棵以 $ 1 $ 为根的完美二叉树（所有叶子深度一样）。</li>
</ol>
<p>对于每一个 $ 1\leqslant k\leqslant n $ ，输出答案。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于每一个节点 $ i $ ，我们用 $ dp_{i,j} $ 表示以 $ i $ 为根的，深度为 $ j $ 的完美二叉树个数。</p>
<p>我们对于每一个 $ k $ ，重新跑一边dp。</p>
<p>这样子时间复杂度是 $ O(n^4) $ 的，状态 $ O(n^2) $ ，转移均摊 $ O(n) $ ，还要转移 $ O(n) $ ，显然过不了。</p>
<p>显然，可以优化一下转移，大概就是对于每一个节点，求一下儿子的 $ dp_j $ 之和。</p>
<p>然后，我们直接枚举一个儿子进行转移就彳亍，不用枚举两个。</p>
<p>这样这个dp就成 $ O(n^3) $ 的了。</p>
<p>你还会发现，每一次多出来一个点，对他祖先们的dp值，只有一个 $ dp_j $ 发生了变化，我们直接只转移变化的这一位。</p>
<p>时间复杂度是 $ O(n^2) $ 。</p>
<p>然后你会发现，一棵深度为 $ d $ 的二叉树，节点数高达$ 2^d-1 $ 。</p>
<p>这题一共就 $ 3\times 10^5 $ 个节点，二叉树深度最多也就 $ 18 $ 。</p>
<p>所以对于深度大于 $ 18 $ 的点，直接不处理了。</p>
<p>同时，对于 $ j&gt;18 $ 的部分，我们也不用处理了。</p>
<p>时间复杂度 $ O(18n)=O(n\log n) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> N,<span class="type">const</span> <span class="type">int</span> M&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> head[N+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> t[M+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> x[M+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> cntm;</span><br><span class="line">    <span class="built_in">graph</span>()&#123; cntm=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n=N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cntm=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cntm++;</span><br><span class="line">        t[cntm]=v;</span><br><span class="line">        x[cntm]=head[u];</span><br><span class="line">        head[u]=cntm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ad</span>(u,v);</span><br><span class="line">        <span class="built_in">ad</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">st</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> head[num];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">to</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> t[num];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nx</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> x[num];&#125;</span><br><span class="line">&#125;;</span><br><span class="line">graph&lt;<span class="number">300000</span>,<span class="number">600000</span>&gt;g;</span><br><span class="line">ll son[<span class="number">300001</span>][<span class="number">21</span>];</span><br><span class="line">ll dp[<span class="number">300001</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> dep[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=g.<span class="built_in">st</span>(num);i;i=g.<span class="built_in">nx</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=g.<span class="built_in">to</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p==fa[num]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[p]=dep[num]+<span class="number">1</span>,fa[p]=num,<span class="built_in">dfs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) g.<span class="built_in">add</span>(<span class="built_in">read</span>(),i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[i]&lt;=<span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;ll delta=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,nod=fa[i],lst=i;nod;j++,nod=fa[nod],lst=fa[lst])</span><br><span class="line">            &#123;</span><br><span class="line">                (son[nod][j<span class="number">-1</span>]+=delta)%=mod;</span><br><span class="line">                delta=(son[nod][j<span class="number">-1</span>]-dp[lst][j<span class="number">-1</span>]+mod)*delta%mod;</span><br><span class="line">                dp[nod][j]=(dp[nod][j]+delta)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++) ans=(ans+dp[<span class="number">1</span>][i])%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC270G</title>
    <url>/ABC270G/</url>
    <content><![CDATA[<p>一道很有意思的题。</p>
<p>告诉我们有的时候要敢于颓柿子。</p>
<p><a href="https://atcoder.jp/contests/abc270/tasks/abc270_g">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个序列 $ X $ ，满足这个条件：</p>
<script type="math/tex; mode=display">
X_i=
\begin{cases}
S&(i=0)\\
(AX_{i-1}+B)\bmod P&(i>0)
\end{cases}</script><p>求出一个最小的 $ i $ ，使得 $ X_i=G $ ，没有输出 $ -1 $ 。</p>
<p>一共 $ T $ 组询问。<br>$ 1\leqslant T\leqslant 100 $</p>
<p>$ 2\leqslant P\leqslant 10^9 $ 且 $ P $ 为质数。</p>
<p>$ 0\leqslant A,B,S,G&lt;P $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们可以化简一下 $ X $ 的定义，手动试一下可以发现：</p>
<p>$ X_i=A^iS+\dfrac{A^i-1}{A-1}\times B $</p>
<p>显然，当 $ A=0 $ 或 $ A=1 $ 时这个式子可能没有意义，所以需要特判。</p>
<p>对于 $ A=0 $ ，$ X $ 中显然只可能出现 $ B $ 与 $ S $ 两种值。</p>
<p>对于 $ A=1 $ ，$ X $ 是一个等差数列。</p>
<p>两种都很好计算。</p>
<p>然后我们就可以得到一个方程：</p>
<p>$ A^iS+\dfrac{A^i-1}{A-1}\times B=G $</p>
<p>最小的 $ i $ 就是答案。</p>
<p>我们会发现，这个未知数 $ i $ 只在 $ A $ 指数的位置上出现过。</p>
<p>考虑往BSGS这个方向靠近，下面先来推式子。</p>
<script type="math/tex; mode=display">
\begin{aligned}
A^iS+\dfrac{A^i-1}{A-1}\times B&=G \\
A^iS(A-1)+(A^i-1)B&=G(A-1)\\
A^{i+1}S-A^iS+A^iB-B&=AG-G\\
A^i(AS-S+B)&=AG-G+B\\
\end{aligned}</script><p>当 $ AS-S+B=0 $ 时，只有 $ AG-G+B=0 $ 才有解，特判一下即可。</p>
<p>否则就有 $ AS-S+B\ne 0 $ ，方程两边同时除以这个式子。</p>
<script type="math/tex; mode=display">
A^i=\dfrac{AG-G+B}{AS-S+B}</script><p>直接BSGS搞定。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>细节有点多，我挂了好久。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll a,b,s,g,mod;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">BSGS</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;,a,b);</span></span><br><span class="line">    <span class="type">int</span> sq=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;(sq+<span class="number">1</span>)*(sq+<span class="number">1</span>)&lt;=mod;sq++);</span><br><span class="line">    unordered_map&lt;ll,<span class="type">int</span>&gt;vis;</span><br><span class="line">    ll num=<span class="built_in">qow</span>(a,sq),now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*sq&lt;=mod;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(now)) vis[now]=i;</span><br><span class="line">        now=now*num%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    now=b,num=<span class="built_in">qow</span>(a,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sq;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">count</span>(now)) ans=<span class="built_in">min</span>(ans,vis[now]*sq+i);</span><br><span class="line">        now=now*num%mod;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0x3f3f3f3f</span>ll) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        mod=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),s=<span class="built_in">read</span>(),g=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(s==g)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(g-s+mod)*<span class="built_in">qow</span>(b,mod<span class="number">-2</span>)%mod);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b==g) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll num=(a*s-s+b+mod)%mod;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BSGS</span>(a,(a*g-g+b+mod)%mod*<span class="built_in">qow</span>(num,mod<span class="number">-2</span>)%mod));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">5 1 3 4 0</span></span><br><span class="line"><span class="comment">ans=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC276G</title>
    <url>/ABC276G/</url>
    <content><![CDATA[<p>这道题首先需要进行题意转化。</p>
<p>比较考验开放思维…</p>
<p><a href="https://atcoder.jp/contests/abc276/tasks/abc276_g">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你数字 $ N $ 与 $ M $ 要求构造一个长度为 $ N $ 的数列 $ a_1,a_2,\dots,a_N $ ，满足以下条件：</p>
<ol>
<li><p>$ 0\leqslant a_1\leqslant a_2\leqslant \dots\leqslant a_N\leqslant M $</p>
</li>
<li><p>$ a_i\not\equiv a_{i+1}\pmod 3(1\leqslant i&lt;N) $</p>
</li>
</ol>
<p>询问有多少种方案数，对 $ 998244353 $ 取模。</p>
<p>$ 2\leqslant N\leqslant 10^7 $</p>
<p>$ 1\leqslant M\leqslant 10^7 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们知道这个序列是递增的，那么我们求出它的差分序列 $ b_i=a_i-a_{i-1} $ ，特别地，$ b_{N+1}=M-a_N $。</p>
<p>这个时候，我们的要求就变成了：</p>
<ol>
<li>$ b_i\nmid 3(2\leqslant i\leqslant N) $</li>
<li>$ b_i\geqslant 0(1\leqslant i\leqslant N+1) $</li>
<li>$ \sum\limits_{i=1}^{N+1}b_i=M $</li>
</ol>
<p>不难发现，如果没有第一个条件，那么方案数很好算，就是 $ \dbinom{M+N}{N} $ ，可以使用插板法推出来。</p>
<p>这个时候我们可以想到，将每一个 $ b_i $ 使用别的方法“表示”出来。</p>
<p>现在，我们对 $ b_i $ 做带余除法，可以将 $ b_i $ 表达为 $ c_i+d_i(c_i=\left\lfloor\dfrac{b_i}{3}\times 3\right\rfloor,d_i=b_i-c_i) $ 。</p>
<p>特别地，对于 $ i=N+1 $ ，我们令 $ c_i=b_i,d_i=0 $ 。</p>
<p>那么现在，对于任意的一组 $ b_i $ ，就有了唯一的 $ c_i $ 和 $ d_i $ 用来表示。</p>
<p>那么现在，条件转化为：</p>
<ol>
<li>$ c_i,d_i\geqslant 0(1\leqslant i\leqslant N+1) $</li>
<li>$ \sum\limits_{i=1}^{N+1}(c_i+d_i)=M $</li>
</ol>
<p>然后，我们枚举 $ v=\sum\limits_{i=1}^{N+1}d_i $ ，考虑如何计算方案数。</p>
<p>首先 $ d_{N+1} $ 肯定是 $ 0 $ ，不考虑。</p>
<p>不难发现，当 $ i\ne 1 $ 时，因为有 $ b_i\nmid 3\Longleftrightarrow(c_i+d_i)\nmid 3 $ ，而 $ c_i $ 又是 $ 3 $ 的倍数，所以 $ d_i\nmid 3\Longleftrightarrow d_i=1,2 $。</p>
<p>然后使用插板法，当 $ d_1\ne 0 $ 时，方案数是 $ \dbinom{N}{v-N} $ 。</p>
<p>当 $ d_1=0 $ 时，方案数是 $ \dbinom{N-1}{v-N+1} $ 。</p>
<p>所以现在，我们只需要知道 $ c $ 的方案数即可，首先我们令 $ v’=\sum\limits_{i=1}^{N+1}c_i=M-v $ 。</p>
<p>我们又知道，$ c_i\mid 3(1\leqslant i\leqslant N) $ ，所以直接可以得到方案数为 $ \dbinom{\left\lfloor\frac{v’}{3}\right\rfloor+N}{N} $。</p>
<p>所以得到，最终答案为 $ \sum\limits_{v=0}^M\left(\dbinom{N}{v-N}+\dbinom{N-1}{v-N+1}\right)\times\dbinom{\left\lfloor\frac{m-v}{3}\right\rfloor+N}{N} $</p>
<p>时间复杂度 $ O(N+M) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll inv[<span class="number">20000001</span>];</span><br><span class="line">ll jc[<span class="number">20000001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">qow</span>(jc[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>||a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[a]*inv[b]%mod*inv[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">20000000</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll val=(<span class="built_in">C</span>(n,i-n)+<span class="built_in">C</span>(n<span class="number">-1</span>,i-n+<span class="number">1</span>))%mod;</span><br><span class="line">        ans=(ans+val*<span class="built_in">C</span>((m-i)/<span class="number">3</span>+n,n))%mod;</span><br><span class="line">        <span class="comment">// printf(&quot;%d : %lld\n&quot;,i,val*C((m-i)/3+n,n)%mod);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC281G</title>
    <url>/ABC281G/</url>
    <content><![CDATA[<p>一道很好的dp题。</p>
<p><a href="https://atcoder.jp/contests/abc281/tasks/abc281_g">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ N $ 个城市与一个数字 $ M $ 。</p>
<p>$ N $ 个城市之间用若干条无向边连接。并且任意两座城市互相可达。</p>
<p>并且满足对于任意城市 $ i(1\leqslant i&lt;N) $ ，都有城市 $ i $ 到城市 $ 1 $ 的距离<strong>严格小于</strong>城市 $ N $ 到城市 $ 1 $ 的距离。</p>
<p>求总共有多少中连边的方案，对数字 $ M $ 取模。$ M $ 可能不是质数。</p>
<p>$ 3\leqslant N\leqslant 500 $</p>
<p>$ 10^8\leqslant M\leqslant 10^9 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑一下符合条件的连边方式有什么特性。</p>
<p>想想就会发现，我们只要将所有点按照到 $ 1 $ 的距离进行“分层”，就能得到很好的性质。</p>
<p>举 $ 2 $ 个例子：</p>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-1">例子 $ 1 $</a></li><li class="tab"><a href="#unique-name-2">例子 $ 2 $</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-1"><p><img src="/pic/ABC281G1.png" alt=""></p>
<p>这张图符合条件，所有点到 $ 1 $ 的距离分别是 $ 0,1,1,2,2,2,3 $ 。</p>
<p>现在我们来分层。</p>
<p><img src="/pic/ABC281G2.png" alt=""></p>
<p>发现什么了吗？</p></div><div class="tab-pane" id="unique-name-2"><p><img src="/pic/ABC281G3.png" alt=""></p>
<p>这场图不符合条件。所有点到 $ 1 $ 的距离分别是 $ 0,1,1,2,2,2,2 $ 。</p>
<p>现在我们来分层。</p>
<p><img src="/pic/ABC281G4.png" alt=""></p>
<p>发现什么了吗？</p></div></div></div>
<p>我们可以发现满足条件的图都有这些性质：</p>
<ol>
<li>点 $ 1 $ 在第 $ 0 $ 层；</li>
<li>点 $ N $ 在最后一层，并且最后一层只有点 $ N $ ；</li>
<li>对于每一条边，两端的点所在层数只差不超过 $ 1 $ （也就是说，只可能存在同层之间连边，或相邻两层连边）。</li>
</ol>
<p>第 $ 3 $ 条性质可能不太显然，但推一下就会发现，不可能存在一条边，两端点分别在第 $ i,j $ 层且 $ i+1&lt;j $ 。</p>
<p>因为如果这样的话，在第 $ j $ 层的那个点最多应该在 $ i+1 $ 层，不可能在 $ j $ 层。</p>
<p>有了这几条性质，我们就可以直接进行dp了。</p>
<p>我们首先设 $ dp_{i,j} $ 为 $ i $ 个点形成了若干层，最后一层有 $ j $ 个点的连边方案数。</p>
<p>那么就有 $ dp_{i,j}=\sum\limits_{k=0}^{i-j}dp_{i-j,k}\times sum_{j,k}\times C_{n-1-(i-j)}^j\times 2^{\frac{j\times (j-1)}{2}} $ 。</p>
<p>其中，枚举 $ k $ 为倒数第二层有多少个节点。</p>
<p>$ sum_{j,k} $ 表示上一层有 $ k $ 个点，下一层有 $ j $ 个点，这两层之间连边方式有多少种。</p>
<p>可以知道 $ sum_{j,k}=(2^k-1)^j $ ，其中 $ 2^k-1 $ 是下一层其中一个点的方案数（每一个点至少与上一层连一条边）。</p>
<p>$ 2^{\frac{j\times(j-1)}{2}} $ 表示同层之间连边方案数，显然每一条边连不连都一样。</p>
<p>$ C_{n-1-(i-j)}^j $ 表示从剩下的所有点中，选出 $ j $ 个点，指定为当前最后一层的点。</p>
<p>因为点 $ 1 $ 和点 $ N $ 位置已经固定，所以看起来比较奇怪。</p>
<p>边界条件为 $ dp_{1,1}=1 $ 。</p>
<p>最后只需要根据 $ dp_{n-1} $ 的值算出答案即可。</p>
<p>时间复杂度为 $ O(n^3) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll C[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line">ll dp[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line">ll sum[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line">ll p[<span class="number">250001</span>];</span><br><span class="line">ll jc[<span class="number">501</span>];</span><br><span class="line">ll inv[<span class="number">501</span>];</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(ll &amp;a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=(a+b)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),mod=<span class="built_in">read</span>();</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) sum[i][j]=<span class="built_in">qow</span>(<span class="built_in">qow</span>(<span class="number">2</span>,j)<span class="number">-1</span>,i);</span><br><span class="line">    jc[<span class="number">0</span>]=p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++) p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i-j;k++)</span><br><span class="line">            <span class="built_in">Add</span>(dp[i][j],dp[i-j][k]*sum[j][k]%mod*C[n<span class="number">-1</span>-(i-j)][j]%mod*p[j*(j<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">Add</span>(ans,dp[n<span class="number">-1</span>][i]*sum[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC147D</title>
    <url>/ARC147D/</url>
    <content><![CDATA[<p>一道纯纯的思维题。</p>
<p>很考验观察能力与思维能力。</p>
<p><a href="https://atcoder.jp/contests/arc147/tasks/arc147_d">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ N $ 个集合 $ S_i $，每个集合内都是在 $ [1,M] $ 中的整数。</p>
<p>如果我们称一组集合 $ S_i $ 是辉煌的，当且仅当：</p>
<p>对于每一个 $ 1\leqslant i&lt;N $ ，在 $ S_i $ 与 $ S_{i+1} $ 中只出现<strong>一次</strong>的数，<strong>恰好</strong>都只有一个。</p>
<p>对于一组集合，我们定义它的权值为 $ \prod\limits_{i=1}^M(所有集合中含有数字i的集合个数) $ 。</p>
<p>求所有辉煌的集合的权值和。</p>
<p>$ 1\leqslant N,M\leqslant 2\times 10^5 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为相邻两个集合中只有一个数字不同，我们设第 $ i $ 个集合和第 $ i+1 $ 集合中，不同的那个数为 $ X_i $ 。</p>
<p>首先我们会有一个结论：</p>
<blockquote>
<p>确定了 $ S_1 $ 和所有 $ X_i $，就可以确定其他的 $ S_i $ 。</p>
</blockquote>
<p>这个比较显然，假如 $ S_i $ 已经确定，那就可以通过 $ X_i $ 得知 $ S_{i+1} $ 的值（如果 $ X_i\in S_i $ ，令 $ S_{i+1}\gets S_i-X_i$，否则，令 $ S_{i+1}\gets S_i\cup X_i $ 就行）</p>
<p>稍微推广一下：</p>
<blockquote>
<p>假如确定了所有 $ X_i $ ，那么一共有 $ 2^M $ 中不同的 $ S_i $ 。</p>
</blockquote>
<p>这个也比较显然，因为 $ S_1 $ 只有 $ 2^M $ 不同的选法，选定 $ S_1 $ 就相当于选定了所有 $ S_i $ 。</p>
<p>然后我们设两个序列 $ A_i,B_i $ ，分别表示 $ S_1 $ 存在数字 $ i $ 和不存在数字 $ i $ 时，有多少个集合包含数字 $ i $ 。</p>
<p>显然，有 $ A_i+B_i=N $ 。</p>
<p><strong>下面是重点：</strong></p>
<p>假如我们已经选定了一组 $ X_i $ 。</p>
<p>那么显然，假如 $ S_1 $ 为空的贡献权值为 $ B_1B_2B_3B_4\dots B_M $ ，只有一个数字 $ 1 $ 时权值为 $ A_1B_2B_3\dots B_M $。</p>
<p>所以我们可以推出，此时所有方案的权值和为 $ \prod\limits_{i=1}^M(A_i+B_i)=N^M $ 。</p>
<p>而我们一共有 $ M^{N-1} $ 中不同 $ X $ 的取值。</p>
<p>所以最终答案为 $ N^M\times M^{N-1} $ 。</p>
<p>时间复杂度是 $ O(\log N+\log M) $ 。</p>
<p>然而 $ N,M $ 都是 $ 2\times 10^5 $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qow</span>(n,m)*<span class="built_in">qow</span>(m,n<span class="number">-1</span>)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC151C</title>
    <url>/ARC151C/</url>
    <content><![CDATA[<p>这场做完B就去写作业了…</p>
<p>题目当时瞅了一眼，感觉不算特别难。</p>
<p><a href="https://atcoder.jp/contests/arc151/tasks/arc151_c">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ N $ 个格子，编号为 $ 1\sim N $ 。对于每一个 $ 1\leqslant i&lt;N $ ，格子 $ i $ 与格子 $ i+1 $ 是相邻的。</p>
<p>最初，有 $ M $ 个方格上写有数字，第 $ X_i $ 个方格上写的数字是 $ Y_i $ ，每一个格子上面的数字只能是 $ 0 $ 或 $ 1 $ 。剩下的 $ N-M $ 个方格上没有数字。</p>
<p>现在，高桥和青木将轮流执行一下操作，高桥先执行。</p>
<p>选择一个上面没有数字的方格，在上面写下 $ 0 $ 或 $ 1 $ ，需要保证这个方格与它相邻的方格，上面的数字不同。</p>
<p>如果一个人不能操作，游戏结束，那个不能操作的人就输了。</p>
<p>如果两个人都按最优方案进行操作，谁会赢？</p>
<p>$ 1\leqslant N\leqslant 10^{18} $</p>
<p>$ 1\leqslant M\leqslant \min\{2\times 10^5,N\} $</p>
<p>$ 1\leqslant X_1&lt;X_2&lt;\dots&lt;X_M\leqslant N $</p>
<p>$ Y_i\in\{0,1\} $</p>
<p>$ X_i+1=X_{i+1}\Longrightarrow Y_i\ne Y_{i+1} -$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们知道，这题是个博弈论（废话</p>
<p>我们会发现，假如有两段空白的区域，中间用若干个数字隔开，那么这两段在操作的时候是不会互相影响的。</p>
<p>并且两个人可执行的操作是完全相同的。</p>
<p>所以我们知道，这道题是一个公平博弈，而且使用SG函数大概率可以做出来。</p>
<p>不过这道题的SG函数比较复杂，因为需要多种情况进行讨论。</p>
<p>我们设 $ sg_{i,0} $ 为一段长度为 $ i $ 的两端数字相等的空白区域的SG函数值。</p>
<p>设 $ sg_{i,1} $ 为一段长度为 $ i $ 的两端数字不等的空白区域的SG函数值。</p>
<p>设 $ sg_{i,2} $ 为一段长度为 $ i $ 的一端为格子边界（1或 $ N $ ）的空白区域的SG函数值。</p>
<p>设 $ sg_{i,3} $ 为一段长度为 $ i $ 的两端都为格子边界的空白区域的SG函数值。</p>
<p>看起来很不好求，所以我们进行打表。</p>
<p>打出来的结果放在这里：</p>
<p><img src="https://s1.ax1x.com/2022/10/18/xrZXRS.png" alt=""></p>
<p><a href="https://www.luogu.com.cn/paste/z64fe7ir">打表程序</a></p>
<p>会发现SG函数的特征还是比较明显的。</p>
<p>做到这里其实就可以直接使用SG函数解决了，时间复杂度是 $ O(M) $ 的。</p>
<p>不过这个结论终究是打表看出来的，下面来证明一下：</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们现在需要证明的是对于任何正整数 $ i $ ，都有 $ sg_{i,0}=1,sg_{i,1}=0,sg_{i,2}=i,sg_{i,3}=i\And 1 $ 。</p>
<p>是用数学归纳法。</p>
<p>首先对于 $ i=1 $ ，结论显然成立。</p>
<p>现在假设，对于一个 $ k\geqslant 2 $ ，所有 $ 1\leqslant i&lt;k $ 都满足结论，现在证明对于 $ i=k $ ，也满足结论。</p>
<h4 id="sg-i-0"><a href="#sg-i-0" class="headerlink" title="$ sg_{i,0} $"></a>$ sg_{i,0} $</h4><p>显然，一共有两种情况：</p>
<ol>
<li>分成两段长度 $ &gt;0 $ 的两端相同的空白段，此时可达到的 $ sg $ 值为 $ 0 $ 。</li>
<li>分成两段长度 $ \geqslant 0 $ 的两端不同的空白段，此时可达到的 $ sg $ 值为 $ 0 $ 。</li>
</ol>
<p>所以 $ sg_{i,0}=\operatorname{mex}\{0\}=1 $ 。</p>
<h4 id="sg-i-1"><a href="#sg-i-1" class="headerlink" title="$ sg_{i,1} $"></a>$ sg_{i,1} $</h4><p>显然，一共有一种情况。</p>
<p>分成一段长度 $ &gt;0 $ 的两端相同的空白段和一段长度 $ \geqslant 0 $ 的两端不同的空白段。</p>
<p>可以达到的 $ sg $ 值为 $ 1 $ 。</p>
<p>所以 $ sg_{i,1}=\operatorname{mex}\{1\}=0 $ 。</p>
<h4 id="sg-i-2"><a href="#sg-i-2" class="headerlink" title="$ sg_{i,2} $"></a>$ sg_{i,2} $</h4><p>显然，一共有两种情况。</p>
<ol>
<li><p>分成一段长度 $ &gt;0 $ 的两端相同的空白段和一段长度 $ \geqslant 0 $ 的一端为边界的空白段，设含边界的一段长度为 $ j(0\leqslant j\leqslant i-2) $ 。</p>
<p>则此时可以到达的 $ sg $ 值为 $ j\wedge 1 $ ，并且可以知道： $0\leqslant j\wedge 1\leqslant i-1 $ 。</p>
</li>
<li><p>分成一段长度 $ \geqslant 0 $ 的两端不同的空白段和一段长度 $ \geqslant 0 $ 的一端为边界的空白段，设含边界的一段长度为 $ j(0\leqslant j\leqslant i-1) $ 。</p>
<p>则此时可以到达的 $ sg $ 为 $ j $ ，并且可以知道，可以到达的所有 $ sg $ 恰好为 $ [0,i-1] $ 的所有整数。</p>
</li>
</ol>
<p>所以 $ sg_{i,2}=\operatorname{mex}\{j|0\leqslant j&lt;i,j\in\mathbb{N}\}=i $ 。</p>
<h4 id="sg-i-3"><a href="#sg-i-3" class="headerlink" title="$ sg_{i,3} $"></a>$ sg_{i,3} $</h4><p>显然，一共有一种情况。</p>
<p>分成两端长度 $ \geqslant 0 $ 的一端为边界的空白段，假设其中一段的长度为 $ j $ ，则另一段的长度为 $ i-j-1 $ 。</p>
<ol>
<li><p>当 $ i $ 为偶数时，$ j $ 与 $ i-j-1 $ 恰好有一个是偶数，一个是奇数。</p>
<p>此时 $ sg_{i,3}=\operatorname{mex}S(0\not\in S)=0 $</p>
</li>
<li><p>当 $ i $ 为奇数时，$ j $ 与 $ i-j-1 $ 奇偶性相同。</p>
<p>取 $ j=\dfrac{i-1}{2} $ 时，$ j=i-j-1 $ ，到达的 $ sg $ 值为 $ 0 $ 。</p>
<p>因为他们两个奇偶性相同，所以到达的 $ sg $ 值不可能为奇数。</p>
<p>此时 $ sg_{i,3}=\operatorname{mex}S(0\in S\wedge 1\not\in S)=1 $ 。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> lst,<span class="type">int</span> now,ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lst==<span class="number">-1</span>||now==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lst==<span class="number">-1</span>&amp;&amp;now==<span class="number">-1</span>) <span class="keyword">return</span> len&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lst==now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">lread</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    ll lst=<span class="number">0</span>;<span class="type">int</span> type=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll now=<span class="built_in">lread</span>();<span class="type">int</span> ty=<span class="built_in">read</span>();</span><br><span class="line">        ans^=<span class="built_in">get</span>(type,ty,now-lst<span class="number">-1</span>);</span><br><span class="line">        lst=now,type=ty;</span><br><span class="line">    &#125;</span><br><span class="line">    ans^=<span class="built_in">get</span>(type,<span class="number">-1</span>,n-lst);</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="built_in">printf</span>(<span class="string">&quot;Takahashi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Aoki\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CERC2016] 机棚障碍</title>
    <url>/CERC2016%E6%9C%BA%E6%A3%9A%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<p>感觉是一道比较水的黑题。</p>
<p>是对重构树的应用，但是只要想到重构树，这道题就能做出来。</p>
<p>我是不会告诉你我想了好久才想到重构树的（</p>
<p><a href="https://www.luogu.com.cn/problem/P3684">题目链接</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们考虑，假如只有一组询问，如何计算答案。</p>
<p>首先我们可以通过二分求的数组 $ v_{i,j} $ 表示，若一个集装箱的中心坐标为 $ (i,j) $ ，那么这个集装箱的最大大小是多少（也就是每一个地方最大能放多大的集装箱）。</p>
<p>对于每一次查询，其实就是求一条路径，使得路径起点为 $ (A_x,A_y) $ ，终点是 $ (B_x,B_y) $ ，这条路径上 $ v_{i,j} $ 的最小值，就是通过这条路径能走的最大的集装箱大小。</p>
<p>也就是说，现在我们知道了起点，知道了终点，需要求得一条路径，使得路径上点权最小值最大。</p>
<p>这个就很明显了，对相邻的两个位置建边，然后使用Kruskal重构树来解决。</p>
<p>特别地，这道题是点权，而平时的重构树，我们求的是边权。</p>
<p>所以我们定义一条边的权值为，两个顶点 $ v $ 的最小值。</p>
<p>对于每一个询问，答案就是重构树上两个点lca的权值。</p>
<p>时间复杂度是 $ O(n^2\log n+q\log n^2) $ 。</p>
<p>额，题解好短，说明这题雀食很水。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">2000001</span>][<span class="number">23</span>];</span><br><span class="line"><span class="type">char</span> in[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="type">int</span> ma[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> dep[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2000001</span>];</span><br><span class="line">vc&lt;pi&gt;a[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getma</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in[x][y]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">512</span>;i;i&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(x-i-ans&gt;=<span class="number">1</span>&amp;&amp;x+i+ans&lt;=n&amp;&amp;y-i-ans&gt;=<span class="number">1</span>&amp;&amp;y+i+ans&lt;=n&amp;&amp;</span><br><span class="line">    pre[x+i+ans][y+i+ans]-pre[x+i+ans][y-i-ans<span class="number">-1</span>]-pre[x-i-ans<span class="number">-1</span>][y+i+ans]+pre[x-i-ans<span class="number">-1</span>][y-i-ans<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">        ans+=i;</span><br><span class="line">    <span class="keyword">return</span> ans*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> f[num]=<span class="built_in">find</span>(f[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(dep[u]-(<span class="number">1</span>&lt;&lt;i)&gt;=dep[v]) u=fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> w[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];</span><br><span class="line">    <span class="keyword">return</span> w[fa[u][<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+(in[i][j]==<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=<span class="built_in">read</span>();cnt=n*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) w[<span class="built_in">id</span>(i,j)]=ma[i][j]=<span class="built_in">getma</span>(i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n) a[<span class="built_in">min</span>(ma[i][j],ma[i+<span class="number">1</span>][j])].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i+<span class="number">1</span>,j)));</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n) a[<span class="built_in">min</span>(ma[i][j],ma[i][j+<span class="number">1</span>])].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--) <span class="keyword">for</span>(pi j:a[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find</span>(j.first),v=<span class="built_in">find</span>(j.second);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++,f[u]=f[v]=f[cnt]=cnt;</span><br><span class="line">        fa[u][<span class="number">0</span>]=fa[v][<span class="number">0</span>]=cnt;</span><br><span class="line">        w[cnt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt<span class="number">-1</span>;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dep[i]=dep[fa[i][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;fa[fa[i][j]][j];j++) fa[i][j+<span class="number">1</span>]=fa[fa[i][j]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xa=<span class="built_in">read</span>(),ya=<span class="built_in">read</span>(),xb=<span class="built_in">read</span>(),yb=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="built_in">id</span>(xa,ya),<span class="built_in">id</span>(xb,yb)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC145D</title>
    <url>/ARC145D/</url>
    <content><![CDATA[<p>一道三进制分组的好题，完全看不出来。</p>
<p>不得不说，这道题很神仙。</p>
<p>事实上，这道题可以乱搞过去。</p>
<p><a href="https://atcoder.jp/contests/arc145/tasks/arc145_d">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在给你两个数字 $ N,M $ ，满足 $ 1\leqslant N\leqslant 10^4,|M|\leqslant N\times 10^6 $ .</p>
<p>你需要构造一个长度为 $ N $ 的序列 $ s_1,s_2,\dots,s_N $ 使得：</p>
<ol>
<li>序列内数字两两不同</li>
<li>$ |s_i|\leqslant 10^7 $</li>
<li>序列中不存在三个数字 $ x&lt;y&lt;z $ 且 $ y-x=z-y $</li>
<li>$ \sum\limits_{i=1}^ns_i=M $</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了方便，我们首先对上述要求做一个小转化。</p>
<p>我们构造的序列不能存在 $ y-x=z-y $ ，这个式子可以写作 $ x+z=2y $ 。</p>
<p>接下来就是本体最神仙的部分：三进制分组。</p>
<h3 id="三进制分组"><a href="#三进制分组" class="headerlink" title="三进制分组"></a>三进制分组</h3><p>我们定义一个数是“好的”当且仅当这个数字在写成 $ 3 $ 进制后，只存在 $ 0 $ 和 $ 1 $ 。</p>
<p>举个例子，数字 $ 22=2\times 3^2+3+1=211_{(3)} $ ，所以 $ 22 $ 就是不好的；</p>
<p>数字 $ 37=3^ 3+3^2+1=1101_{(3)} $，所以 $ 37 $ 是好的。</p>
<p>那么就有一个结论：如果一个序列的数字全是好的，那么这个序列就不存在 $ x+z=2y $ 的情况。</p>
<p>想要证明这个结论，我们只需要证明对于任意 $ 3 $ 个好的数字 $ x,y,z $ ，不存在 $ x+z=2y $ 就可以。</p>
<p>首先 $ y $ 这个数字是好的，那么就说明 $ y $ 在 $ 3 $ 进制表示下，只存在数字 $ 0 $ 和数字 $ 2 $ 。</p>
<p>$ x,z $ 都是好的，那么 $ 3 $ 进制表示下，$ x+z $ 就不会存在进位的情况。</p>
<p>同时，$ x+z $ 和 $ y $ 这两个数字在三进制下<strong>每一位都相等</strong>。</p>
<p>那就是说，对于每一位 $ i $ 都有 $ x_i=y_i=z_i=0 $ 或 $ x_i=y_i=z_i=1 $ ,这里 $ a_i $ 表示 $ a $ 在 $ 3 $ 进制下的第 $ i $ 位。</p>
<p>所以就会有 $ x=y=z $ ，显然这个结论成立。</p>
<p>这个时候我们就构造了一个序列，这个序列只剩下第 $ 4 $ 个条件没有满足。</p>
<h3 id="第-4-个条件"><a href="#第-4-个条件" class="headerlink" title="第$ 4 $个条件"></a>第$ 4 $个条件</h3><p>首先会有这么一个结论：如果一个序列满足第三个要求，现在我们把这个序列整体加上一个值，那么这个序列肯定还满足要求。</p>
<p>这个很好证明，因为所有数字都加上了一个值，这个时候 $ y-x $ 和 $ z-y $ 的值都不会变化。</p>
<p>所以这个时候，我们就可以通过 给整个序列 $ +1/-1 $ 来实现让这个序列的和 $ +n/-n $ 。</p>
<p>剩下就是最关键的一个问题，如果这个时候我们要调整的值小于 $ N $ 怎么办？</p>
<p>我们能不能在整个序列中选若干个数字，将他们 $ +1 $ ，使得之后这个序列的所有数字还是”好的“呢？</p>
<p>直接这样做显然不可行，因为能选的数字大概只占整个序列的一半。</p>
<p>怎样能使这个方法正确呢？</p>
<p>我们只需要让一开始构造的序列，里面的数字全是 $ 3 $ 的倍数就可以了。</p>
<p>这个时候，所有数字在 $ 3 $ 进制下，最后一位全是 $ 0 $ ，这就意味着所有数字 $ +1 $ 之后，还是”好的“。</p>
<p>其他部分按照我们刚刚步骤就可以啦。</p>
<p>代码也很短。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">18</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">lread</span>();ll sum=<span class="number">0</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">18</span>;i++) p[i]=p[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">18</span>;j++) <span class="keyword">if</span>((<span class="number">2</span>*i)&amp;(<span class="number">1</span>&lt;&lt;j)) a[i]+=p[j];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum=m-sum;</span><br><span class="line">    <span class="type">int</span> y=(sum%n+n)%n,x=(sum-y)/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++) a[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]+x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>三进制分组</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1598D</title>
    <url>/CF1598D/</url>
    <content><![CDATA[<p>本人早期题解，题目不算太难。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1598D">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现有 $ n $ 道题，每道题有一个主题 $ a_i $ 和一个难度 $ b_i $。现在要从其中选出三道题，使得他们满足以下条件的<strong>任意一条</strong>：</p>
<ol>
<li><p>这三道题的主题互不相同；</p>
</li>
<li><p>这三道题的难度互不相同。</p>
</li>
</ol>
<p>求出合法的方案数，题目保证不存在两道题，使得他们主题与难度都一样。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于上述两个条件之间是或的关系，也就是说一个合法的选择方案只需要满足任意一个条件就可以，这样很不好想，我们考虑算出不合法的方案总数，在用总方案数减去就可以了。</p>
<p>总数很好算：从 $ n $ 个数中选出三个数，共有 $ C_n^3 $ 种方案，也就是 $ \dfrac{n\left(n-1\right)\left(n-2\right)}{6} $ 种。</p>
<p>根据题意，我们可以知道不满足的方案必然<strong>同时满足</strong>以下两个条件：</p>
<ol>
<li><p>三道题中有至少两道题主体一致；</p>
</li>
<li><p>三道题中有至少两道题难度一致。</p>
</li>
</ol>
<p>由于题目中已经告诉我们，不存在两道题主题与难度都相等，所以两个条件转化为：</p>
<ol>
<li><p>三道题中有两道题主体一致；</p>
</li>
<li><p>三道题中有两道题难度一致。</p>
</li>
</ol>
<p><del>虽然感觉没有什么变化，但是下面这两条显然更清晰。</del></p>
<p>现在，我们不妨将一道题看作二维平面上的一个点，其中第 $ i $ 道题的坐标为 $ \left(a_i,b_i\right) $。</p>
<p>再次转化不合法方案的条件：</p>
<ol>
<li><p>三个点中有两个点横坐标一致；</p>
</li>
<li><p>三个点中有两个点纵坐标一致。</p>
</li>
</ol>
<p>通俗一点说，这三个点在二维平面上组成了一个 L 形（当然，这个 L 形也有可能是旋转过的）。</p>
<p>那么，我们不妨枚举这个 L 形上拐弯处那个点，这样就可以求出不合法的方案数了。</p>
<p>最后减掉就可以了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> numa[<span class="number">200001</span>];<span class="comment">//numa[i]表示横坐标为i的点的个数</span></span><br><span class="line"><span class="type">int</span> numb[<span class="number">200001</span>];<span class="comment">//numb[i]表示纵坐标为i的点的个数</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">200001</span>];<span class="comment">//点的横坐标/题目主题</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">200001</span>];<span class="comment">//点的纵坐标/题目难度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        numa[i]=numb[i]=<span class="number">0</span>;<span class="comment">//多组数据记得清空</span></span><br><span class="line">        ans=(<span class="type">long</span> <span class="type">long</span>)n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">6</span>;<span class="comment">//n是int类型，注意相乘要开long long</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]=<span class="built_in">read</span>(),numa[a[i]]++;</span><br><span class="line">            b[i]=<span class="built_in">read</span>(),numb[b[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans-=(<span class="type">long</span> <span class="type">long</span>)(numa[a[i]]<span class="number">-1</span>)*(numb[b[i]]<span class="number">-1</span>);<span class="comment">//减去的1是拐弯点自己</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>早期题解，感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数形结合</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1733E</title>
    <url>/CF1733E/</url>
    <content><![CDATA[<p>一道挺有意思的题。</p>
<p>考场上推了半天，没推出来，直接弃了。</p>
<p>但是实际上算法很简单。</p>
<p><a href="https://codeforces.com/contest/1733/problem/E">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个长度、宽度都为 $ 120 $ 的网格，每个格子上都是一个传送带。</p>
<p>从上数第 $ i $ 行，从左数第 $ j $ 列的网格称为 $ (i,j) $ ，最左边的列是第 $ 0 $ 列（行同理）。</p>
<p>每一个格子上的传送带一开始都指向右边。</p>
<p>一开始，传送带 $ (0,0) $ 上有一滴水，其他格子是空的，每一秒会进行这样的变化：</p>
<ol>
<li>每一滴水按照传送带方向，挪一个格子。如果对应方向上没有格子，水滴就会消失。两个水滴同时到一个格子，它们就会合并。</li>
<li>在上次移动前的时候所有有水的各自，全部切换方向（原来向右的指向下方，原来向下的指向右方）。</li>
<li>传送带 $ (0,0) $ 上多出一滴水。</li>
</ol>
<p>现在有 $ q $ 组询问，每一次给出 $ t,x,y $ ，问在 $ t $ 秒时，格子 $ (x,y) $ 上有没有水。</p>
<p>$ 1\leqslant q\leqslant 10^4 $</p>
<p>$ 0\leqslant x,y&lt;120 $</p>
<p>$ 0\leqslant t\leqslant 10^{18} $</p>
<p>每一秒传送带的情况可以去原题查看图片。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们定义“对角线 $ i $”为所有满足 $ x+y=i $ 的格子 $ (x,y) $ 。</p>
<p>然后我们就会发现，每一次移动时，每一个水滴不是向右移，就是向下移。</p>
<p>所以如果上一秒一个水滴在对角线 $ i $ ，那么这个水滴在移动之后一定在对角线 $ i+1 $ 。</p>
<p>或者再加强一下这个结论：一个在时间 $ a $ 出现的水滴，在时间 $ a+b $ 时（一共移动了 $ b $ 次）会出现在对角线 $ b $ 的一个格子上。</p>
<p>所以我们可以知道，所有的水滴是永远不会相遇（合并）的。</p>
<p>然后我们还能知道，对于一组询问 $ t,x,y $ ，假如在时间 $ t $ 时 $ (x,y) $ 上有水滴，那么这个水滴一定是在时间 $ t-x-y $ 出现的。</p>
<p>所以对于每一个 $ x+y&gt;t $ 的询问，我们可以直接进行回答（永远不可能出现这样的情况）。</p>
<p>然后对于没一组询问，令数组 $ dp_{i,j} $ 为，前 $ t-x-y $ 出现的所有水滴中，经过格子 $ (x,y) $ 的有多少个。</p>
<p>首先我们知道，每一个水滴一开始都在 $ (0,0) $，所以就会有 $ dp_{0,0}=t-x-y+1 $ 。</p>
<p>然后呢？怎么转移？</p>
<p>我们会发现，假如一共有 $ c $ 个水滴经过了格子 $ (a,b) $ ，那么这 $ c $ 个水滴中，一定会有 $ \left\lceil\frac{c}{2}\right\rceil $ 个水滴向右走，有 $ \left\lfloor\frac{c}{2}\right\rfloor $ 个水滴向下走。</p>
<p>所以我们就可以得到转移：</p>
<script type="math/tex; mode=display">
dp_{i,j}=\left\lfloor\dfrac{dp_{i-1,j}}{2}\right\rfloor+\left\lceil\dfrac{dp_{i,j-1}}{2}\right\rceil</script><p>现在我们就可以直接模拟，这个水滴的行走路径了，大概是这个样子：</p>
<p>假如这个水滴现在在格子 $ (a,b) $ ，那么我们知道，这个水滴一定是第 $ dp_{a,b} $ 个到达这个水滴的格子，因为我们的 $ dp $ 统计的是这个水滴及之前的水滴中，到达过这个格子的水滴数。</p>
<p>那么如果 $ dp_{a,b}\bmod 2=0 $ ，这个水滴一定向下走。</p>
<p>否则就会向右走。</p>
<p>我们模拟 $ x+y $ 步，看有没有 $ (x,y)=(a,b) $ 就可以了。</p>
<p>时间复杂度为 $ O(t\times 120^2) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码里 $ dp $ 的推导和上面不太一样，使用的是顺推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">121</span>][<span class="number">121</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t=<span class="built_in">lread</span>();<span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x+y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=t=t-x-y+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">120</span>;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">119</span>) dp[i][j+<span class="number">1</span>]+=(dp[i][j]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">119</span>) dp[i+<span class="number">1</span>][j]+=dp[i][j]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll nowx=<span class="number">0</span>,nowy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+y;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[nowx][nowy]&amp;<span class="number">1</span>) nowy++;</span><br><span class="line">            <span class="keyword">else</span> nowx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nowx==x) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC149D</title>
    <url>/ARC149D/</url>
    <content><![CDATA[<p>一道很不错的思维题，没啥算法基础。</p>
<p>场上离做出来就差最后一步。</p>
<p>难度评分为 $ 2991 $ 。</p>
<p><a href="https://atcoder.jp/contests/arc149/tasks/arc149_d">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p> 在一个坐标轴上有 $ N $ 个棋子，第 $ i $ 个棋子的坐标是 $ X_i $ 。</p>
<p>现在将每一个棋子移动 $ M $ 次，移动规则是这样的：</p>
<p>对于第 $ i $ 次移动，如果某个棋子坐标大于 $ 0 $ ，将它向左移 $ D_i $ ；如果坐标小于 $ 0 $ ，将它向右移 $ D_i $ ；坐标为 $ 0 $ 则不变。</p>
<p>对于每一个棋子，按照规则移动完这 $ M $ 次以后，输出以下值：</p>
<p>如果这个棋子的坐标最后不是 $ 0 $ ，输出坐标，否则输出这个棋子在第几次移动后到达坐标 $ 0 $ 。</p>
<p>$ 1\leqslant N,M\leqslant 3\times 10^5 $</p>
<p>$ 1\leqslant X_1\leqslant X_2\leqslant \dots\leqslant X_N\leqslant 10^6 $</p>
<p>$ 1\leqslant D_i\leqslant 10^6 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们观察范围，会发现 $ 1\leqslant X_i\leqslant 10^6 $ ，值域非常小。</p>
<p>这提示我们不妨假设 $ 1\sim 10^6 $ 范围内，每一个地方都有一个棋子。如果我们能把这些答案都求出来，那么题目中所给的 $ N $ 个坐标肯定也没问题。</p>
<p>然后我们会发现一个性质。</p>
<blockquote>
<p>假如有两个棋子在第 $ i $ 次操作后坐标互为相反数/相等。</p>
<p>那么它们在第 $ j(j&gt;i) $ 次操作之后，坐标肯定也互为相反数/相等。</p>
</blockquote>
<p>这个性质很显然。</p>
<p>然后我们再来想，对于一段棋子 $ l\sim r $ ，如果我们进行一次操作，里面的棋子最多有三个结果：落在原点，或者原点左边/右边。</p>
<p>落在原点的棋子我们不用看，以后无论怎么操作，它肯定都在原点。</p>
<p>现在假如有一部分棋子落在原点左边，有一部分棋子落在原点右边。</p>
<p>结合一些上面的性质。</p>
<p>我们会发现有一些棋子会”结合“起来，它们的坐标以后都互为相反数，这个时候我们只需要计算它们其中的一部分。</p>
<p>举一个例子：</p>
<p>现在 $ 1\sim 12 $ 上各有一个棋子，我们现在进行操作 $ 8 $ 。</p>
<p>所有棋子向左移 $ 8 $ 格，坐标为 $ 8 $ 的棋子到了原点，棋子 $ 1\sim 7 $ 到了原点左边，棋子 $ 9\sim 12 $ 到了原点右边。</p>
<p>不难发现，棋子 $ 7 $ 现在坐标为 $ -1 $ ，棋子 $ 9 $ 坐标为 $ 1 $ ,它们的坐标现在互为相反数，所以以后它们的坐标都会互为相反数。我们只要知道了棋子 $ 7 $ 之后某一时刻的坐标，就能知道棋子 $ 9 $ 在那个时候的坐标。</p>
<p>同理，棋子 $ 6,10 $ ，棋子 $ 5,11 $ ，棋子 $ 4,12 $ 都有这样的关系。</p>
<p>所以在之后的某一个时刻中，我们如果知道了棋子 $ 1\sim 7 $ 的坐标，我们就能知道棋子 $ 9\sim12 $ 的坐标。</p>
<p>现在回到原来的问题：坐标 $ 1\sim 10^6 $ 上各有一个棋子，经过若干次操作，求它们的最终位置。</p>
<p>这告诉我们，每一次操作之后，如果整个序列被分成了两段，那么我们只需要计算出长的那一段的最终位置，并且记录短的那一段与长的那一段，坐标的关系即可。</p>
<p>假如我们称每一次操作后，被分成的两段中，较长的一段为”关键段“。</p>
<p>那么我们只需要在每一次操作后维护，当前关键段的位置，以及关键段由哪些棋子组成。然后记录”关键段“与较短段的关系。</p>
<p>上面的这两个东西都可以直接递推。</p>
<p>记录关系可以直接进行建边。我们将”关键段“里的棋子连一条边向较短段里的对应棋子，表示后者的坐标是前者的相反数。</p>
<p>例如，在上面那个例子中，我们就可以从 $ 7\to 9 $，$ 6\to 10 $  ……</p>
<p>处理到最后一个询问时，我们就知道关键段中点的答案（以及其中一些算出的，到达原点的棋子编号），这个时候我们就可以通过之前连的有向边，求出 $ 1\sim 10^6 $ 中所有点的答案。</p>
<p>可以看一看<strong>官方题解中的图</strong>，假设记忆。</p>
<p><img src="https://img.atcoder.jp/arc149/9aa345ea3aa518aa46d7cd6f112c0760.png" alt="9aa345ea3aa518aa46d7cd6f112c0760.png (800×866) (atcoder.jp)"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>细节还是比较多的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;t[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">bool</span> t0[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> x[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">1000001</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;a0;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p:t[num])</span><br><span class="line">    &#123;</span><br><span class="line">        t0[p]=t0[num],ans[p]=ans[num];</span><br><span class="line">        <span class="keyword">if</span>(!t0[p]) ans[p]=-ans[p];</span><br><span class="line">        <span class="built_in">dfs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),l=<span class="number">1</span>,r=<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) d[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;d[i]||r&lt;d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                l-=d[i],r-=d[i],sum-=d[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t0[d[i]-sum]=<span class="number">1</span>,ans[d[i]-sum]=i;</span><br><span class="line">            a0.<span class="built_in">push_back</span>(d[i]-sum);</span><br><span class="line">            <span class="type">int</span> l1=l,r1=d[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> l2=d[i]+<span class="number">1</span>,r2=r;</span><br><span class="line">            <span class="keyword">if</span>(r1-l1&gt;=r2-l2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r2-l2;i++) t[r1-i-sum].<span class="built_in">push_back</span>(l2+i-sum);</span><br><span class="line">                l=l1-d[i],r=r1-d[i],sum-=d[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r1-l1;i++) t[l2+i-sum].<span class="built_in">push_back</span>(r1-i-sum);</span><br><span class="line">                l=l2-d[i],r=r2-d[i],sum-=d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(-r&gt;d[i]||-l&lt;d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                l+=d[i],r+=d[i],sum+=d[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t0[-d[i]-sum]=<span class="number">1</span>,ans[-d[i]-sum]=i;</span><br><span class="line">            a0.<span class="built_in">push_back</span>(-d[i]-sum);</span><br><span class="line">            <span class="type">int</span> l1=l,r1=-d[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> l2=-d[i]+<span class="number">1</span>,r2=r;</span><br><span class="line">            <span class="keyword">if</span>(r1-l1&gt;=r2-l2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r2-l2;i++) t[r1-i-sum].<span class="built_in">push_back</span>(l2+i-sum);</span><br><span class="line">                l=l1+d[i],r=r1+d[i],sum+=d[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r1-l1;i++) t[l2+i-sum].<span class="built_in">push_back</span>(r1-i-sum);</span><br><span class="line">                l=l2+d[i],r=r2+d[i],sum+=d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) ans[i-sum]=i,<span class="built_in">dfs</span>(i-sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:a0) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t0[x[i]]) <span class="built_in">printf</span>(<span class="string">&quot;Yes %d\n&quot;</span>,ans[x[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No %d\n&quot;</span>,ans[x[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
      </categories>
  </entry>
  <entry>
    <title>CF1738E</title>
    <url>/CF1738E/</url>
    <content><![CDATA[<p>一道有趣的数列题，然而场上没有做出来。</p>
<p>看完题解发现跟我想的差不多，<del>就是我码风太屎</del>。</p>
<p>里面分类讨论和组合数学的部分感觉出的很不错。</p>
<p>主要是对官方题解的翻译，并加入了我的理解。</p>
<p><a href="https://codeforces.com/contest/1738/problem/E">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个数列 $ a_1,a_2,\dots,a_n $ 你需要将这个数列分为若干非空的段。</p>
<p>假设你将这个数列分成了 $ k $ 段，分成的所有段中，第 $ i $ 段中所有数字的和为 $ s_i $ 。</p>
<p>我们称一种分的方法为平衡的，当且仅当对于每一个 $ 1\leqslant i\leqslant k $ ，都有 $ s_i=s_{k-i+1} $ 。</p>
<p>求一共有多少种平衡的分法，对 $ 998244353 $ 取模。</p>
<p>多组数据。</p>
<p>$ 1\leqslant \sum n\leqslant 10^5 $</p>
<p>$ 0\leqslant a_i\leqslant 10^9 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们来考虑一个暴力的思路。</p>
<p>设 $ dp_{i,j} $ 为区间 $ [i,j] $ 的答案，我们要求的就是 $ dp_{1,n} $。</p>
<p>我们暴力枚举最左边和最右边区间的范围，进行转移。</p>
<p>时间复杂度是 $ O(n^4) $ 的。</p>
<p>虽然这个时间复杂度无法接受，但是这个方法可以优化。</p>
<p>现在我们来看具体求一个区间 $ dp_{l,r} $ 的方法，大力分类讨论：</p>
<ol>
<li><p>$ a_l=a_{l+1}=\dots=a_{r-1}=a_r=0 $ ，那么显然所有方法都可行，所以答案为 $ 2^{r-l} $ 。</p>
</li>
<li><p>$ a_l=a_r=0 $ ，我们设区间 $ [l,r] $ 最左边共有 $ x $ 个连续的 $ 0 $ ，最右边一共有 $ y $ 个连续的 $ 0 $ 。</p>
<p>如果分成的区间中，最左边和最右边 $ k $ 段的和都为 $ 0 $ ，那么此时方案数为 $ \dbinom{x}{k}\times \dbinom{y}{k}\times dp_{l+x,r-y} $</p>
<p>其中 $ \dbinom{x}{k} $ 表示将左边的 $ x $ 个 $ 0 $ 分成 $ k+1 $ 段（左边的 $ k $ 段是上一行说的和为 $ 0 $ 的 $ k $ 段，最后一段给区间 $ [l+x,r-y] $ 最左边的一段分过去），并且其中 $ k $ 段要求非空的方案数，$ \dbinom{y}{k} $ 同理。</p>
<p>最后整个乘以 $ dp_{l+x,r-y} $ 表示考虑了最左边和最右边的 $ k $ 段以后，中间切分的方案数。</p>
<p>所以此时最终答案为 $ dp_{l+x,r-y}\times \sum\limits_{k=0}^{\min(x,y)}\dbinom{x}{k}\times \dbinom{y}{k} $ 。</p>
</li>
<li><p>对于剩下的情况，我们设：</p>
<p>最小的 $ x $ 和最大的 $ y $ 使得 $ \sum\limits_{i=l}^xa_i=\sum\limits_{i=y}^ra_i&gt;0 $ 。</p>
<p>这个 $ x $ 和 $ y $ 可以使用双指针去找。</p>
<p>然后再进行分类讨论：</p>
<ol>
<li><p>如果 $ x=r $ 或 $ y=l $ ，说明这个序列不存在分成 $ \geqslant 2 $ 段的方案，所以此时答案为 $ 1 $ 。</p>
<p>并且可以注意到，对于所有剩余的情况，肯定会有 $ x&lt;y $ ，并且 $ a_x\ne 0\ne a_y $。</p>
</li>
<li><p>$ a_{x+1}=a_{x+2}=\dots=a_{y-2}=a_{y-1}=0 $ 。</p>
<p>可以知道，此时当且仅当 $ [l,x] $ 中所有元素在同一段里，$ [y,r] $ 中所有元素在同一段里，这个切分方案就是合法的。</p>
<p>所以此时答案为 $ 2^{y-x} $ 。</p>
</li>
<li><p>对于剩下的所有情况，我们设区间 $ [x+1,y-1] $ 中最左边共有 $ l_0 $ 个连续的 $ 0 $ ，最右边共有 $ r_0 $ 个连续的 $ 0 $ 。</p>
<p>当且仅当满足这三个条件是，一个切分方案是合法的：</p>
<ol>
<li>区间 $ [l,x] $ 在同一段，$ [y,r] $ 在同一段。</li>
<li>区间 $ [x+1,x+l_0] $ 中和为 $ 0 $ 的段数=区间 $ [y-l_0,y-1] $ 中和为 $ 0 $ 的段数。</li>
<li>区间 $ [x+l_0+1,y-r_0-1] $ 的切分方案合法。</li>
</ol>
<p>所以我们还是枚举区间 $ [x+1,x+l_0] $ 中共有 $ k $ 段和为 $ 0 $ 。</p>
<p>这时方案数为 $ \dbinom{l_0+1}{k+1}\times \dbinom{r_0+1}{k+1}\times dp_{x+l_0+1,y-r_0-1} $ 。</p>
<p>其中 $ \dbinom{l_0+1}{k+1} $ 表示将左边这些 $ 0 $ 分为 $ k+2 $ 段（中间的 $ k $ 段是上面说的和为 $ 0 $ 的 $ k $ 段，最左边的一段给 $ [l,x] $ ，最右边的一段给 $ [x+l_0+1,y-r_0-1] $），并且中间 $ k $ 段非空的方案数。$ \dbinom{r_0+1}{k+1} $ 同理。</p>
<p>所以此时的方案数为 $ dp_{x+l_0+1,y-r_0-1}\times\left(1+\sum\limits_{k=0}^{\min(l_0,r_0)}\dbinom{l_0+1}{k+1}\times\dbinom{r_0+1}{k+1}\right) $ 。</p>
<p>之所以有一个 $ 1 $ ，是因为存在方案，使得 $ [l,x+l_0] $ 全部属于 $ [x+l_0+1,y-r_0-1] $ 的最左边的一段，$ [y-r_0,r] $ 全部属于 $ [x+l_0+1,y-r_0-1] $ 的最右边的一段。</p>
</li>
</ol>
</li>
</ol>
<p>直接递归就可以了，细节不算多，但是也不算特别少。</p>
<p>时间复杂度 $ T(n)=T(n-m)+O(m)=O(n) $ 。</p>
<p>需要预处理阶乘及其逆元，也可以做到 $ O(n) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我懒了亿点，预处理写的是 $ O(n\log n) $ 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll inv[<span class="number">200001</span>];</span><br><span class="line">ll jc[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=<span class="built_in">qow</span>(jc[i],mod<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jc[a]*inv[b]%mod*inv[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[r]-pre[l<span class="number">-1</span>]==r-l+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">qow</span>(<span class="number">2</span>,r-l);</span><br><span class="line">    <span class="keyword">if</span>(a[l]==<span class="number">0</span>&amp;&amp;a[r]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[l]==<span class="number">0</span>) x++,l++;</span><br><span class="line">        <span class="keyword">while</span>(a[r]==<span class="number">0</span>) y++,r--;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=x&amp;&amp;i&lt;=y;i++) ans=(ans+<span class="built_in">C</span>(x,i)*<span class="built_in">C</span>(y,i))%mod;</span><br><span class="line">        ans=ans*<span class="built_in">solve</span>(l,r)%mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    ll suml=<span class="number">0</span>,sumr=<span class="number">0</span>;<span class="type">int</span> x=l<span class="number">-1</span>,y=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(suml!=sumr||suml==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(suml&lt;=sumr) suml+=a[++x];</span><br><span class="line">        <span class="keyword">else</span> sumr+=a[--y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y==l||x==r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[y<span class="number">-1</span>]-pre[x]==y-x<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">qow</span>(<span class="number">2</span>,y-x);</span><br><span class="line">    <span class="type">int</span> l0=<span class="number">0</span>,r0=<span class="number">0</span>,nx=x+<span class="number">1</span>,ny=y<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[nx]==<span class="number">0</span>) l0++,nx++;</span><br><span class="line">    <span class="keyword">while</span>(a[ny]==<span class="number">0</span>) r0++,ny--;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=l0&amp;&amp;i&lt;=r0;i++) ans=(ans+<span class="built_in">C</span>(l0+<span class="number">1</span>,i+<span class="number">1</span>)*<span class="built_in">C</span>(r0+<span class="number">1</span>,i+<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans*<span class="built_in">solve</span>(nx,ny)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]=<span class="built_in">read</span>();</span><br><span class="line">            pre[i]=pre[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1806E</title>
    <url>/CF1806E/</url>
    <content><![CDATA[<p>服了，暴力没卡过去。</p>
<p>CF评测姬好慢。</p>
<p><a href="https://www.luogu.com.cn/problem/CF1806E">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵 $ n $ 个结点的树，点有点权，根是 $ 1 $ 。对于两个深度相等的节点 $ x,y $ ，定义 $ f(x,y)=f(fa_x,fa_y)+a_xa_y $ ，特别地，$ f(1,1)=a_1^2 $ 。 给出 $ q $ 次询问，每次询问 $ f(x,y) $ 。</p>
<p>$ 1\le n,q\le 10^5 $</p>
<p>$ 1\le a_i\le 10^5 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑对于每一个询问，暴力找父亲，直到找到根。显然时间复杂度是 $ O(nq) $ ，过不了。</p>
<p>但是如果加上一个记忆化，时间复杂度就对了。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>假设哈希表的时间复杂度为 $ O(1) $ 。</p>
<p>设深度为 $ i $ 的节点个数为 $ c_i $ 。</p>
<p>当 $ c_i\le\sqrt{n} $ 时，时间复杂度为 $ O(c_i^2)\le O(c_i\sqrt{n}) $ 。</p>
<p>因为 $ \sum c_i\le n $  ，所以 $ O(\sum c_i\sqrt{n})\le O(n\sqrt{n}) $ 。</p>
<p>当 $ c_i &gt; \sqrt{n} $ 时，时间复杂度为 $ O(q) $ 。</p>
<p>因为 $ \sum c_i\le n $ ，所以这样的 $ i $ 的数量不会超过 $ \sqrt{n} $ 个。</p>
<p>时间复杂度为 $ O((n+q)\sqrt{n}) $ 。</p>
<p>还有一种不需要哈希表的方式：</p>
<p>对于每一个 $ c_i\le\sqrt{n} $ 的深度，我们进行记忆化，空间复杂度是 $ O(n\sqrt{n}) $ 。</p>
<p>对于剩下的深度，我们暴力做，这种情况单次询问不会超过 $ O(\sqrt{n}) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> N,<span class="type">const</span> <span class="type">int</span> M&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> head[N+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> t[M+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> x[M+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> cntm;</span><br><span class="line">    <span class="built_in">graph</span>()&#123; cntm=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n=N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cntm=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cntm++;</span><br><span class="line">        t[cntm]=v;</span><br><span class="line">        x[cntm]=head[u];</span><br><span class="line">        head[u]=cntm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ad</span>(u,v);</span><br><span class="line">        <span class="built_in">ad</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">st</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> head[num];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">to</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> t[num];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nx</span><span class="params">(<span class="type">int</span> num)</span></span>&#123; <span class="keyword">return</span> x[num];&#125;</span><br><span class="line">&#125;;</span><br><span class="line">graph&lt;<span class="number">100000</span>,<span class="number">100000</span>&gt;g;</span><br><span class="line">ll mem[<span class="number">100001</span>][<span class="number">335</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;v[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> sq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[num]=c[dep[num]]++,v[dep[num]].<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=g.<span class="built_in">st</span>(num);i;i=g.<span class="built_in">nx</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=g.<span class="built_in">to</span>(i);</span><br><span class="line">        dep[p]=dep[num]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[dep[x]]&lt;=sq&amp;&amp;mem[x][id[y]]) <span class="keyword">return</span> mem[x][id[y]];</span><br><span class="line">    ll ans=<span class="built_in">get</span>(fa[x],fa[y])+(ll)a[x]*a[y];</span><br><span class="line">    <span class="keyword">if</span>(c[dep[x]]&lt;=sq) mem[x][id[y]]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(;(sq+<span class="number">1</span>)*(sq+<span class="number">1</span>)&lt;=n;sq++);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) g.<span class="built_in">ad</span>(fa[i]=<span class="built_in">read</span>(),i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>),mem[<span class="number">1</span>][<span class="number">0</span>]=(ll)a[<span class="number">1</span>]*a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">get</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>记忆化</tag>
      </tags>
  </entry>
  <entry>
    <title>[COCI2021-2022#3] Kućice</title>
    <url>/COCI2021_35/</url>
    <content><![CDATA[<p>小清新思维题，但并不简单</p>
<p>教练留的作业题，卡了我一下午</p>
<p><a href="https://www.luogu.com.cn/problem/P8031">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在二维平面上有 $ n $ 个点，第 $ i $ 个点坐标是 $ (x_i,y_i) $ ，每一个点有存在和不存在两种状态。</p>
<p>显然全局一共有 $ 2^n $ 种状态，求所有状态下，$ \sum \textbf{存在的点构成的凸包中点的数量(不存在的点也算)} $ 。</p>
<p>$ 1\le n\le 10^3 $</p>
<p>$ |x_i|,|y_i|\le 10^6 $</p>
<p>任意两点不重合，三点不共线</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>凸包内有多少点不好算，考虑对于每一个点算出，有多少种情况，这个点不在凸包内。</p>
<p>首先，若一个点 $ i $ 不在凸包内，则 $ i $ 一定没有被选（废话</p>
<p>再枚举一下，$ i $ 和这个凸包的第一条切线(顺时针)切在了哪个点 $ j $ 上，那么角度最大点一定不会超过 $ \pi  $ 。</p>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-1">点 $ i $ 不在凸包内</a></li><li class="tab"><a href="#unique-name-2">点 $ i $ 在凸包内</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-1"><p><img src="/pic/COCI2021_35_1.png" style="zoom:67%;" /></p>
<p><img src="/pic/COCI2021_35_2.png" style="zoom:67%;" /></p></div><div class="tab-pane" id="unique-name-2"><p><img src="/pic/COCI2021_35_3.png" style="zoom:67%;" /></p>
<p><img src="/pic/COCI2021_35_4.png" style="zoom:67%;" /></p></div></div></div>
<p>所以我们枚举一个点 $ i $ ，将所有点按照极角排序。</p>
<p>然后枚举点 $ j $ ，双指针可以得到一个点 $ k $ ，使得它是最后一个，和 $ j $ 极角相差不超过 $ \pi $ 的点。</p>
<p>则点 $ j $ 必须选，$ (j,k] $ 这些点可选可不选，就可以算出 $ i $ 不位于凸包内的方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> ld PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll p[<span class="number">2001</span>];</span><br><span class="line">ld d[<span class="number">2001</span>];</span><br><span class="line"><span class="type">int</span> x[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> y[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>(),p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    ll ans=(p[n]<span class="number">-1</span>)*n%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(i!=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[j]==x[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(y[j]&gt;y[i]) d[++c]=<span class="number">90</span>,d[++c]=<span class="number">450</span>;</span><br><span class="line">                <span class="keyword">else</span> d[++c]=<span class="number">270</span>,d[++c]=<span class="number">630</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ld T=(ld)(y[j]-y[i])/(x[j]-x[i]);</span><br><span class="line">                ld D=<span class="built_in">atan</span>(T)/PI*<span class="number">180</span>;</span><br><span class="line">                <span class="keyword">if</span>(x[j]&lt;=x[i]) D+=<span class="number">180</span>;</span><br><span class="line">                <span class="keyword">if</span>(D&lt;<span class="number">0</span>) D+=<span class="number">360</span>;</span><br><span class="line">                d[++c]=D,d[++c]=D+<span class="number">360</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(d+<span class="number">1</span>,d+c+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(d[lst]-d[i]&lt;=<span class="number">180</span>) lst++;</span><br><span class="line">            ans=(ans+mod-p[lst-i<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>COCI</category>
      </categories>
      <tags>
        <tag>解析几何</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSGRound3]出游</title>
    <url>/CSGRound3%E5%87%BA%E6%B8%B8/</url>
    <content><![CDATA[<p>额，虽然这道题在你谷上的评分是蓝，但我觉得并不简单。</p>
<p>顺便让我复习了一下暑假讲过的知识点。</p>
<p><a href="https://www.luogu.com.cn/problem/P6016">题目链接</a></p>
<span id="more"></span>
<p><img src="/pic/紫得发黑.png" alt=""></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在一共有 $ n $ 个人，其中第 $ i $ 个人有 $ a_i $ 个朋友，并且朋友关系是单向的。（即可能存在两个人A,B，使得A是B的朋友，但是B不是A的朋友）</p>
<p>现在有一场派对，持续若干天。第 $ 0 $ 天时，第 $ i $ 个人有 $ p_i $ 的概率参加派对，有 $ 1-p_i $ 的概率不参加派对。</p>
<p>对于第 $ i(i\geqslant 1) $ 天来说，第 $ j $ 个人参加派对，当且仅当存在至少一个 $ j $ 的朋友 $ k $ ，使得第 $ k $ 个人在第 $ i-1 $ 天参加了派对。</p>
<p>求第 $ T $ 天时，参加派对的期望人数，对 $ 998244353 $ 取模。</p>
<p>$ 1\leqslant n\leqslant 500 $</p>
<p>$ 1\leqslant T\leqslant 10^9 $</p>
<p>$ 0\leqslant p_i&lt;998244353 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先来考虑 $ T=1 $ 的时候怎么做。</p>
<p>显然对于任何一个人 $ i $ ，只要他有一个朋友在第 $ 0 $ 天时参加派对，$ i $ 就会去参加派对。</p>
<p>这个时候我们可以直接算出 $ i $ 不参加派对的概率，从而算出 $ i $ 参加派对的概率。</p>
<p>现在来考虑 $ T=2 $ 。</p>
<p>显然对于任何一个人 $ i $ ，只要存在一个人 $ j $ 在第 $ 0 $ 天参加派对，并且 $ j $ 是 $ i $ 朋友的朋友，$ i $ 就会去参加派对。</p>
<p>显然，这种“朋友套朋友”的关系不好叙述，我们换一种方式。</p>
<p>我们把一个人看作一个点，如果人 $ i $ 是人 $ j $ 的朋友，我们再连一条 $ j\to i $ 的边。</p>
<p>这样子朋友的关系就很好叙述了。</p>
<p>对于 $ T=2 $ ，也就是对于每一个 $ i $ ，只要存在一个人 $ j $ 在第 $ 0 $ 天参加派对，并且从 $ j $ 经过恰好两条边可以到达点 $ i $ ，$ i $ 就会去参加派对。</p>
<p>如果 $ T $ 为任意数，那么对于任何一个人 $ i $ ，只要存在一个人 $ j $ 在第 $ 0 $ 天参加派对，并且从 $ j $ 经过恰好 $ T $ 条边可以到达点 $ i $ ，$ i $ 就回去参加派对。</p>
<p>现在如果我们对于每一个人 $ i $ ，如果能求出所有的人 $ j $ ，那么这个问题就解决了。</p>
<p>这个问题显然可以使用倍增Floyd来解决，我们设 $ dp_{i,j,k} $ 表示第 $ j $ 个人走 $ 2^i $ 条边，是否可以走到 $ k $ ，转移的时候枚举中间点即可。</p>
<p>这样时间复杂度是 $ O(n^3\log T) $ ，离满分还差一点。</p>
<p>这个时候我们能发现，对于每一个 $ dp_{i,j,k} $ ，它的值不是 $ 0 $ 就是 $ 1 $（废话。</p>
<p>所以我们可以使用bitset进行优化。</p>
<p>也就是说我们开若干个bitset，其中 $ dp_{i,j} $ 表示的是第 $ j $ 个人走 $ 2^i $ 条边，走到的人的集合。</p>
<p>时间复杂度是 $ O\left(\dfrac{n^3\log T}{w}\right) $ ，能过。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">bitset&lt;501&gt;f[<span class="number">501</span>][<span class="number">31</span>];</span><br><span class="line">bitset&lt;501&gt;num[<span class="number">501</span>];</span><br><span class="line">bitset&lt;501&gt;mem[<span class="number">501</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">501</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=<span class="built_in">read</span>(),num[i][i]=<span class="number">1</span>;<span class="type">int</span> c=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++) f[i][<span class="number">0</span>][<span class="built_in">read</span>()]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++) <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        <span class="keyword">if</span>(f[u][i<span class="number">-1</span>][v]) f[u][i]|=f[v][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++) <span class="keyword">if</span>(m&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++) mem[u]=num[u],num[u].<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++) <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++) <span class="keyword">if</span>(mem[u][v]==<span class="number">1</span>)</span><br><span class="line">            num[u]|=f[v][i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) printf(&quot;%d%c&quot;,(int)num[i][j],&quot; \n&quot;[j==n]);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll val=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(num[i][j]==<span class="number">1</span>) val=val*(mod+<span class="number">1</span>-p[j])%mod;</span><br><span class="line">        ans+=mod+<span class="number">1</span>-val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>Catalan数</title>
    <url>/Catalan/</url>
    <content><![CDATA[<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>使用 $ n $ 个相同的节点可构造多少种不同的二叉树？其中 $ 1\le n\le5000 $。</p>
<p>设 $ f_i $ 表示用 $ i $ 个节点构造的的二叉树形态的个数，不难发现 $ f_0=1 $,为空树。</p>
<p>由于非空的二叉树是由根节点、左子树、右子树组成的，考虑对左子树节点数量进行枚举，所以有：</p>
<script type="math/tex; mode=display">
f_n=\sum\limits_{i=0}^{n-1}f_i\times f_{n-1-i}</script><p>这里 $ f $ 序列就是 $ Catalan $ 序列。</p>
<span id="more"></span>
<h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><h4 id="模型-1："><a href="#模型-1：" class="headerlink" title="模型 1："></a>模型 1：</h4><p>给定 $ n $ 个相同的节点，求可以组成的二叉树形态总数。</p>
<p>一开始就已经说过了，证明略。</p>
<h4 id="模型-2："><a href="#模型-2：" class="headerlink" title="模型 2："></a>模型 2：</h4><p>长度为 $ 2n $ 的合法括号序列的形态个数。</p>
<p><strong>证明：</strong></p>
<p>记长度为 $ 2i $ 的合法括号序列形态个数为 $ h_i $。</p>
<p>首先当 $ n $ 为 $ 0 $ 或 $ 1 $ 时，都只有一种形态，即 $ h_0=h_1=1 $。</p>
<p>考虑 $ n\ge2$ 的情况，由于这是一个合法的括号序列，所以最后一个括号必定为右括号。</p>
<p>我们再将最后一个右括号所对应的左括号表示出来，括号序列就可以表示为如下形式：A(B)。</p>
<p>其中 A 与 B 必为合法的括号序列（可能为空），枚举 A 的长度，所以有：</p>
<script type="math/tex; mode=display">
h_n=\sum\limits_{i=0}^{n-1}h_i\times h_{n-i-1}</script><p>所以这是卡特兰数。</p>
<h4 id="模型-3："><a href="#模型-3：" class="headerlink" title="模型 3："></a>模型 3：</h4><p>长度为 $ n $ 的序列的出栈序列种数：</p>
<p><strong>证明：</strong></p>
<p>不难发现，对于两种不同的进出栈操作，他们的出栈序列肯定是不同的，所以出栈序列种数其实就是求合法操作数。</p>
<p>那什么样的操作是合法的呢？</p>
<p>我们将一次进栈操作看为一个左括号，一次出栈操作看为一个右括号。</p>
<p>那么，当进栈次数与出栈次数相同，且任何时候当前进栈次数大于等于出栈次数时，</p>
<p>这个出栈序列是合法的，且括号序列也是合法的。</p>
<p>反之也成立。</p>
<p>所以其实这和模型2是一样的。</p>
<h4 id="模型-4："><a href="#模型-4：" class="headerlink" title="模型 4："></a>模型 4：</h4><p>给定 $ -1 $ 与 $ 1 $ 各 $ n $ 个，让他们组成一个长度为 $ 2n $ 的序列 $ a $，问这样的 $ a $ 的个数：对于每一个 $ i\in\left[1,2n\right] $ 都有 $ \sum\limits^{i}_{j=1}a_j\ge0 $。</p>
<p><strong>证明：</strong></p>
<p>只需要让任何时候 $ 1 $ 的数量大于等于 $ -1 $ 的数量即可。</p>
<p>将 $ 1 $ 看作左括号， $ -1 $ 看作右括号，其实就是求合法的括号序列数，与模型2一模一样。</p>
<h4 id="模型-5："><a href="#模型-5：" class="headerlink" title="模型 5："></a>模型 5：</h4><p>给定 $ -1 $ 与 $ 1 $ 各 $ n $ 个，让他们组成一个长度为 $ 2n $ 的序列 $ a $，问这样的 $ a $ 的个数：存在一个 $ i\in\left[1,2n\right]$ 使得 $ \sum\limits_{j=1}^{i}a_j&gt;0 $。</p>
<p><strong>证明：</strong></p>
<p>$ Catalan_n $ 是对于任何 $ i\in\left[1,2n\right]$，都有 $ \sum\limits_{j=1}^{i}a_j\le0 $ 的序列个数（大于等于和小于等于是一样的）。</p>
<p>很容易发现这就是不合法的序列的个数。</p>
<p>所以答案为 $ C^n_{2n}-Catalan_n $。</p>
<h4 id="模型-6："><a href="#模型-6：" class="headerlink" title="模型 6："></a>模型 6：</h4><p>一个圆上有 $ 2n $ 个点，求连 $ n $ 条线段使得任两线段之间没有交点的方案数（端点处相交也算有交点）。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>将这 $ 2n $ 个点按顺序进行标号（顺时针或逆时针都行），枚举 $ 1 $ 号点与几号点连线，之后这个圆就被分为了两个圆弧。</p>
<p>设答案为 $ f_{2n} $，则 $ f_{2n}=\sum\limits_{i\in[2,2n]\textbf{且}i|2}f_{i-2}\times f_{2n-i} $。</p>
<p>解释：$ i $ 为与 $ 1 $ 连线的节点，要求 $ i|2 $ 是为了分成的两端圆弧所含的点的个数都为偶数，$ i-2 $ 和 $ 2n-i $ 是分成的两段圆弧的点的个数。</p>
<p>设 $ g_n=f_{2n} $，并使用 $ 2j $ 替换上式中的 $ i $，有：</p>
<p>$ g_n=\sum\limits_{2j\in[2,2n]}f_{2j-2}\times f_{2n-2j}=\sum\limits_{j=1}^ng_{j-1}\times g_{n-j}=\sum\limits_{j=0}^{n-1}g_j\times g_{n-j+1} $</p>
<p>$ g $ 序列即为 $ Catalan $ 序列</p>
<h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>使用 $ n $ 个相同的节点可构造多少种不同的二叉树？其中 $ 1\le n\le10^5 $。</p>
<p>显然，如果利用上述公式进行计算，时间复杂度为 $ O\left(n^2\right) $,无法接受。</p>
<h4 id="定理一："><a href="#定理一：" class="headerlink" title="定理一："></a>定理一：</h4><script type="math/tex; mode=display">
Catalan_n=C_{2n}^n-C_{2n}^{n+1}</script><p>证明：</p>
<p>使用模型 $ 4 $,考虑求出合法方案数。</p>
<p>首先我们知道 $ 1 $ 与 $ -1 $ 各有 $ n $ 个，我们先将这 $ n $ 个 $ 1 $ 插入 $ 2n $ 个空中，总方案数（可能不合法）即为 $ C_{2n}^n $。</p>
<p>如果一个序列是不合法的，那么说明至少存在一个 $ i\in[1,2n] $，使得 $ \sum\limits_{j=1}^{2n}a_j&lt;0 $。</p>
<p>那么我们设这样的 $ i $ 中最小的一个为 $ k $。</p>
<p>假如对于下面这个序列，满足条件的 $ i $ 为 $ 5,9 $，那么 $ k=5 $。</p>
<p>显然会有 $ \sum\limits_{i=1}^ka_i=a_k=-1 $ </p>
<p>举个梨子，假如序列长这个样子：</p>
<p>$ 1,1,-1,-1,-1,1,1,-1,-1,1 $</p>
<p>我们把他的图画出来。</p>
<p><img src="https://s4.ax1x.com/2022/02/13/HDfr36.png" alt="HDfr36.png"></p>
<p>显然，在这个例子中 $ k=5 $ ，是第一个使得前缀和 $ &lt;0 $ 的位置。</p>
<p>然后我们将前 $ k $ 个数翻转（将 $ 1 $ 变成 $ -1 $，将 $ -1 $ 变成 $ 1 $）。</p>
<p>显然，会得到的一个有 $ n+1 $ 个 $ 1 $ 和 $ n-1 $ 个 $ -1 $ 的序列。</p>
<p>上面的序列翻转后得到的序列是 $ -1,-1,1,1,1,1,1,-1,-1,1 $。</p>
<p><img src="https://s4.ax1x.com/2022/02/13/HD4CWt.png" alt="HD4CWt.png"></p>
<p>假设翻转后的序列为 $ b $。</p>
<p>显然会有 $ \sum\limits_{i=1}^kb_i=b_k=1 $</p>
<p>显然，对于每一个序列 $ a $，都有一个<strong>唯一的</strong>序列 $ b $ 与之对应。对于每一个序列 $ a $ 我们能且只能找出唯一一个序列 $ k $ ，这对应了唯一的一的序列 $ b $ 。</p>
<p>对于每一个序列 $ b $，肯定都有一个<strong>唯一的</strong>序列 $ a $ 与之对应。</p>
<p>证明方法差不多，找出第一个使前缀和 $ &gt;0 $ 的位置 $ k $ ，并将前 $ k $ 个数字翻转。</p>
<p>值得注意的是，因为 $ b $ 序列最后一个位置在 $ 2 $ ，所以肯定存在一个合法的 $ k $ 。</p>
<p>翻转之后就能变成一个序列 $ a $ 。</p>
<p>综上所述，$ a $ 序列与 $ b $ 序列是两两对应的，所以他们的数量是相等的。</p>
<p>又因为 $ b $ 序列是由 $ n+1 $ 个 $ 1 $ 与 $ n-1 $ 个 $ -1 $ 组成的，</p>
<p>所以他们的数量都为 $ C_{2n}^{n+1} $。</p>
<p>合法序列数量即为 $ C^ n_{2n}-C^{n+1}_{2n} $。</p>
<script type="math/tex; mode=display">
\therefore Catalan_n=C_{2n}^n-C_{2n}^{n+1}</script><h4 id="定理二："><a href="#定理二：" class="headerlink" title="定理二："></a>定理二：</h4><script type="math/tex; mode=display">
Catalan_n=\dfrac{C_{2n}^n}{n+1}</script><p>证明：</p>
<p>考虑使用定理一进行推导：</p>
<script type="math/tex; mode=display">
Catalan_n=C_{2n}^n-C_{2n}^{n+1}</script><script type="math/tex; mode=display">
=\dfrac{\left(2n\right)!}{n!\times n!}-\dfrac{\left(2n\right)!}{\left(n+1\right)!\times\left(n-1\right)!}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\left(\dfrac{\left(2n\right)!\times\left(n+1\right)}{n!\times n!}-\dfrac{\left(2n\right)!\times\left(n+1\right)}{\left(n+1\right)!\times\left(n-1\right)!}\right)</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\left(\dfrac{\left(2n\right)!\times\left(n+1\right)}{n!\times n!}-\dfrac{\left(2n\right)!}{n!\times\left(n-1\right)!}\right)</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\left(\dfrac{\left(2n\right)!\times\left(n+1\right)}{n!\times n!}-\dfrac{\left(2n\right)!\times n}{n!\times n!}\right)</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\left(\dfrac{\left(2n\right)!\times\left(n+1\right)}{n!\times n!}-\dfrac{\left(2n\right)!\times n}{n!\times n!}\right)</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\dfrac{\left(2n\right)!}{n!\times n!}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times C_{2n}^n</script><script type="math/tex; mode=display">
\therefore Catalan_n=\dfrac{C_{2n}^n}{n+1}</script><p>他的另一种形式是：</p>
<script type="math/tex; mode=display">
\therefore Catalan_n=\dfrac{\left(2n\right)!}{n!\times n! \times\left(n+1\right)}</script><script type="math/tex; mode=display">
=\dfrac{\left(2n\right)!}{\left(n+1\right)!\times n!}</script><script type="math/tex; mode=display">
=\dfrac{\prod\limits_{i=n+2}^{2n}i}{\prod\limits_{i=1}^ni}</script><h4 id="定理三："><a href="#定理三：" class="headerlink" title="定理三："></a>定理三：</h4><script type="math/tex; mode=display">
Catalan_n=\dfrac{4n-2}{n+1}\times Catalan_{n-1}</script><p>证明：</p>
<p>考虑使用定理二：</p>
<script type="math/tex; mode=display">
Catalan_n=\dfrac{C_{2n}^n}{n+1}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\dfrac{\left(2n\right)!}{n!\times n!}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\dfrac{\left(2n-2\right)!\times \left(2n-1\right)\times\left(2n\right)}{\left(n-1\right)!\times\left(n-1\right)!\times n^2}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\dfrac{\left(2n-1\right)\times\left(2n\right)}{n}\times\dfrac{1}{n}\times\dfrac{\left(2n-2\right)!}{\left(n-1\right)!\times\left(n-1\right)!}</script><script type="math/tex; mode=display">
=\dfrac{1}{n+1}\times\dfrac{2\left(2n-1\right)}{n}\times C_{2n-2}^{n-1}</script><script type="math/tex; mode=display">
=\dfrac{4n-2}{n+1}\times\dfrac{C_{2n-2}^{n-1}}{n}</script><script type="math/tex; mode=display">
\therefore Catalan_n=\dfrac{4n-2}{n+1}\times Catalan_{n-1}</script><p>注：上述证明参考自：</p>
<p><a href="https://www.136.la/shida/show-228451.html">Catalan通项公式的推导</a></p>
<p><a href="https://www.cnblogs.com/suijie/p/3989352.html">n对括号的匹配方式以及Catalan数通项公式的推导</a></p>
<p><a href="https://www.cnblogs.com/zyt1253679098/p/9190217.html">【知识总结】卡特兰数 (Catalan Number) 公式的推导</a></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><a href="https://luogu.com.cn/problem/P1044">洛谷P1044栈</a></p>
<p>与模型三一样，证明略。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><a href="https://www.luogu.com.cn/problem/P2532">洛谷P2532树屋阶梯</a></p>
<p>我们不妨将每一行最后一个格子成为特殊格。</p>
<p>不难发现，每摆放一份钢材，最多只有一个特殊格被覆盖，所以每一次摆放钢材时必须要覆盖到一个特殊格。</p>
<p>显然，最左下角的格子也会被覆盖一次（没错，这是一句废话），那么我们就可以枚举一下和左下角格子一起被覆盖的是哪一个特殊格。</p>
<p>给出 $ n=4 $ 时第一次放钢材的方案，供大家理解：</p>
<p><img src="https://s1.ax1x.com/2022/05/27/XZjh4J.md.png" alt="XZjh4J.md.png"></p>
<p><img src="https://s1.ax1x.com/2022/05/27/XZjfN4.md.png" alt="XZjfN4.md.png"></p>
<p><img src="https://s1.ax1x.com/2022/05/27/XZjWEF.md.png" alt="XZjWEF.md.png"></p>
<p><img src="https://s1.ax1x.com/2022/05/27/XZj5C9.md.png" alt="XZj5C9.md.png"></p>
<p>摆放钢材后这个楼梯形状的物品便被分为了两个楼梯，故这是一个 Catalan 数列。</p>
<p>注意：本题没有模，所以需要使用高精。</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><a href="https://www.luogu.com.cn/problem/P1641">洛谷P1641生成字符串</a></p>
<p>与模型 $ 4 $ 一样，证明略。</p>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p><a href="https://www.luogu.com.cn/problem/P3200">洛谷P3200有趣的数列</a></p>
<p>首先我们对题意进行转化，不妨将整个序列拆成两个，一个由原下标为奇数的组成，另一个由原下标为偶数的组成。</p>
<p>显然，这两个序列都是递增的。</p>
<p>那么，题意就可以转化为：对于 $ 1 $ 至 $ 2n $ 中的每个正整数，要么将其放到奇数序列的当前最后一个的后面，要么将其放到偶数序列当前最后一个的后面。</p>
<p>现在我们还有一个条件：就是奇数序列对应数字比偶数序列对应数字小。</p>
<p>这该怎么办呢？其实我们再将这个条件进行转化：</p>
<p>在任意时候，偶数序列数字个数都比奇数序列数字个数多。</p>
<p>所以，当序列长度为 $ 2n $ 时，答案即为 $ Catalan_n $。</p>
<p>本题还有一个难点，就是没有保证模数是质数。实际上，我们只要求出 $ 2\sim 2n $ 中，每个正整数的质因数及个数，再利用公式：</p>
<script type="math/tex; mode=display">
Catalan_n=\dfrac{\prod\limits_{i=n+2}^{2n}i}{\prod\limits_{i=1}^ni}</script><p>即可计算答案。</p>
<p>目前还没有找到别的啥题要讲，就先咕咕咕。</p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOI2018] 会议</title>
    <url>/IOI2018%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<p>最近打模拟赛遇到的，不得不说非常神仙。</p>
<p><del>又难打又难调</del>，写篇题解纪念一下。</p>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5044">luoguP5044</a>。</p>
<span id="more"></span>
<h4 id="Subtask2"><a href="#Subtask2" class="headerlink" title="Subtask2"></a>Subtask2</h4><p>我们先来看这个部分分。</p>
<p>这是一个比较显然的区间dp。（<del>虽然我在模拟赛时并没有看出来</del>）</p>
<p>设 $ dp_{l,r} $ 为区间 $ [l,r] $ 的最优解， $ p $ 为这个区间内<strong>任何</strong>一个最大值的<strong>位置</strong>。</p>
<p>当 $ l=r $ 时，显然 $ dp_{l,r}=h_l $ 。</p>
<p>否则这个方程有两种转移方式。</p>
<p>当 $ l\ne p $ 时，有转移 $ dp_{l,r}=dp_{l,p-1}+(r-p+1)h_p $ 。</p>
<p>当 $ r\ne p $ 时，有转移 $ dp_{l,r}=dp_{p+1,r}+(p-l+1)h_p $ 。</p>
<p>当 $ l\ne r $ 时，会议在 $ p $ 召开显然不会最优，所以忽略。</p>
<p>其中第一种方式是会议地址在最大值左边的情况，第二种方式会议地址在最大值右边。</p>
<p>因为会议地址在最大值一边时，另一边所有点的代价显然都是区间最大值。</p>
<p>并且显然会议地址只能有上述两种方式。</p>
<p>所以这种dp是正确的。</p>
<p>快乐的 $ O(n^2) $ dp。</p>
<p>喜提 $ 19 $ 分。</p>
<h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>我们发现这个dp与区间最大值的位置有关系，所以考虑在笛卡尔树进行dp。</p>
<p>我们首先可以把st表和笛卡尔树建出来（因为 $ n $ 不算特别大，所以还是可以 $ O(n\log n) $ 进行建树的）。</p>
<p>首先我们可以想到的思路是对于笛卡尔树上的每一个节点，我们将它所对应区间的dp值求出来。</p>
<p>但是会发现，虽然这样子是可以预处理的，但是无法处理询问，因为如果数列是递增/递降的，笛卡尔树高就会为 $ n $ 。</p>
<p>并且我们在每一次询问的区间不一定对应着笛卡尔树上<strong>恰好</strong>一个节点，这个区间很可能是由许多节点“拼起来”的。</p>
<p>那么我们对于每一个询问就要访问这个区间的所有节点，极限情况下要访问 $ O(n) $ 个节点。</p>
<p>时间复杂度为 $ O(nq) $ 。</p>
<p>所以我们只能考虑别的方法。</p>
<p>首先我们根据上面的结论：若区间值不唯一，则最优解的位置一定不在区间最大值。</p>
<p>那么我们可以将一个询问拆成两个：一个是最优解在最大值左边的情况，一个是最优解在最大值右边的情况。（最大值选任何一个）</p>
<p>那么这两个询问显然可以通过同一种方式来处理，我们这里主要讲解第二种询问。</p>
<p>第一种询问可以通过将这个序列翻转，然后再做一遍。</p>
<p>那么拆出的这个询问和原来的询问有什么区别呢？</p>
<p>其他地方没什么不同，但是拆出的这个询问多了一个条件——这个区间左边的值大于等于询问区间内所有数的值。</p>
<p>那么这个时候就会有一个新的可行思路:</p>
<p>假设当前节点所对应的下标为 $ mid $ （也就是对应区间最大值的位置） ，所对应的区间为 $ [l,r] $ 。</p>
<p>那么我们能不能将所有的 $ dp_{l,i}(l\le i\le r) $ 求出来呢？</p>
<p>现在我们假设这个节点的左右儿子的 $ dp $ 值都处理完毕，考虑合并 $ dp $ 值。</p>
<p>对于 $ dp_{l,i}(i&lt;mid) $ ，这部分dp只已经在左儿子里求出来了，不用管。</p>
<p>对于 $ dp_{l,i}(i=mid) $ ，有 $ dp_{l,i}=dp_{l,i-1}+h_i $ 。（因为最优解一定不在区间最大值）</p>
<p>对于 $ dp_{l,i}(i&gt;mid) $ ，有 $ dp_{l,i}=\min(dp_{l,mid}+(i-mid)h_{mid},dp_{mid+1,i}+(mid-l+1)h_{mid}) $ 。</p>
<p>这个 $ \min $ 的第一个值表示会议地址在最大值左边，第二个值表示会议地址在最大值右边。</p>
<p>和 $ 19 $ 分做法的dp方程差不多。</p>
<p>好像也不好做啊。</p>
<p>我们再来仔细观察，就会发现当 $ mid&lt;i&lt;r $ 时一定会有 $ dp_{mid+1,i+1}\le dp_{mid+1,i}+h_{mid} $ 。因为一定有 $ h_{i+1}\le h_{mid} $ 此时就算会议地址和原来选一个，代价也只会增加 $ h_{mid} $ 。</p>
<p>再来观察上面的 $ dp $ 方程。随着 $ i $ 的增加，左边的值会增加 $ h_{mid} $ ，而右边的值增加量一定小于等于 $ h_{mid} $ 。</p>
<p>这告诉我们对于这个区间，一定是左边的一部分用第一种决策，剩下的部分都用第二种决策。</p>
<p>所以我们可以二分出这两种决策的分界线。</p>
<p>那么如何转移呢？</p>
<p>对于第二种转移，需要在原来的基础上区间加一个值；对于第一种转移，则需要先区间赋 $ 0 $ ，再加上一个一次函数。</p>
<p>再结合之前二分的需求，我们就可以用一个支持区间赋值、区间增加一次函数（假设常数也算一次函数）的线段树来解决问题。</p>
<p>最后询问只需要在拆出的两次询问中选最小值即可。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pi&gt;q[<span class="number">750001</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">750001</span>][<span class="number">21</span>];</span><br><span class="line">ll tagk[<span class="number">3000001</span>];</span><br><span class="line">ll tagb[<span class="number">3000001</span>];</span><br><span class="line">ll tagf[<span class="number">3000001</span>];</span><br><span class="line">ll num[<span class="number">3000001</span>];</span><br><span class="line"><span class="type">int</span> mid[<span class="number">750001</span>];</span><br><span class="line">ll ans[<span class="number">750001</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">750001</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">750001</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">750001</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">750001</span>];</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=p[r-l],val1=st[l][num],val2=st[r-(<span class="number">1</span>&lt;&lt;num)+<span class="number">1</span>][num];</span><br><span class="line">    <span class="comment">// printf(&quot;get_max %d %d %d : %d\n&quot;,l,r,num,h[val1]&gt;h[val2]?val1:val2);</span></span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">return</span> h[val1]&gt;h[val2]?val1:val2;</span><br><span class="line">    <span class="keyword">return</span> h[val1]&gt;=h[val2]?val1:val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_st</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;j++)</span><br><span class="line">        st[i][j]=<span class="built_in">get_max</span>(i,i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(~tagf[p])</span><br><span class="line">    &#123;</span><br><span class="line">        tagk[p*<span class="number">2</span>]=tagk[p*<span class="number">2</span>|<span class="number">1</span>]=tagb[p*<span class="number">2</span>]=tagb[p*<span class="number">2</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        tagf[p*<span class="number">2</span>]=tagf[p*<span class="number">2</span>|<span class="number">1</span>]=num[p*<span class="number">2</span>]=num[p*<span class="number">2</span>|<span class="number">1</span>]=tagf[p];</span><br><span class="line">        tagf[p]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[p*<span class="number">2</span>]+=mid*tagk[p]+tagb[p];</span><br><span class="line">    num[p*<span class="number">2</span>|<span class="number">1</span>]+=pr*tagk[p]+tagb[p];</span><br><span class="line">    tagk[p*<span class="number">2</span>]+=tagk[p],tagk[p*<span class="number">2</span>|<span class="number">1</span>]+=tagk[p],tagk[p]=<span class="number">0</span>;</span><br><span class="line">    tagb[p*<span class="number">2</span>]+=tagb[p],tagb[p*<span class="number">2</span>|<span class="number">1</span>]+=tagb[p],tagb[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[p]=num[p*<span class="number">2</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r)&#123; tagk[p]=tagb[p]=<span class="number">0</span>,tagf[p]=num[p]=y;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p,pl,pr);</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">cover</span>(p*<span class="number">2</span>,pl,mid,l,r,y);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) <span class="built_in">cover</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r,y);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> tagf[p]+tagk[p]*pl+tagb[p];</span><br><span class="line">    <span class="built_in">push_down</span>(p,pl,pr);</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">get</span>(p*<span class="number">2</span>,pl,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> len,ll dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp+(ll)(pl-l+<span class="number">1</span>)*h[l<span class="number">-1</span>]&lt;=num[p]+(ll)len*h[l<span class="number">-1</span>]) <span class="keyword">return</span> pl;</span><br><span class="line">        <span class="keyword">return</span> pl<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p,pl,pr);</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">cal</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r,len,dp);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=r) <span class="keyword">return</span> <span class="built_in">cal</span>(p*<span class="number">2</span>,pl,mid,l,r,len,dp);</span><br><span class="line">    <span class="keyword">if</span>(dp+(ll)(mid-l+<span class="number">1</span>)*h[l<span class="number">-1</span>]&lt;=num[p*<span class="number">2</span>]+(ll)len*h[l<span class="number">-1</span>]) <span class="keyword">return</span> <span class="built_in">cal</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r,len,dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cal</span>(p*<span class="number">2</span>,pl,mid,l,r,len,dp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r,ll k,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;add %d %d %d %d %d %lld %lld : %lld\n&quot;,p,pl,pr,l,r,k,b,num[p]);</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tagk[p]+=k,tagb[p]+=b;</span><br><span class="line">        num[p]+=k*pr+b;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p,pl,pr);</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(p*<span class="number">2</span>,pl,mid,l,r,k,b);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) <span class="built_in">add</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r,k,b);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">get_max</span>(nl,nr),nb=<span class="number">-1</span>;ll dp;</span><br><span class="line">    <span class="keyword">if</span>(num!=nl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nl,num<span class="number">-1</span>);</span><br><span class="line">        dp=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,num<span class="number">-1</span>)+h[num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dp=h[num];</span><br><span class="line">    <span class="built_in">cover</span>(<span class="number">1</span>,<span class="number">1</span>,n,num,num,dp);</span><br><span class="line">    <span class="keyword">if</span>(num!=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(num+<span class="number">1</span>,nr);</span><br><span class="line">        <span class="type">int</span> mi=nb=<span class="built_in">cal</span>(<span class="number">1</span>,<span class="number">1</span>,n,num+<span class="number">1</span>,nr,num-nl+<span class="number">1</span>,dp);</span><br><span class="line">        <span class="keyword">if</span>(mi&gt;num)<span class="comment">//(num,mi]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cover</span>(<span class="number">1</span>,<span class="number">1</span>,n,num+<span class="number">1</span>,mi,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,num+<span class="number">1</span>,mi,h[num],dp-(ll)num*h[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mi&lt;nr)<span class="comment">//(mi,nr]</span></span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,mi+<span class="number">1</span>,nr,<span class="number">0</span>,(ll)(num-nl+<span class="number">1</span>)*h[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;dfs %d %d %d %d\n&quot;,nl,nr,num,nb);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:q[num])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id=i.first,qr=i.second;</span><br><span class="line">        ans[id]=<span class="built_in">min</span>(ans[id],<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,qr)+(ll)(mid[id]-l[id]+<span class="number">1</span>)*h[mid[id]]);</span><br><span class="line">        <span class="comment">// printf(&quot;id=%d qr=%d\n&quot;,id,qr);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(154&lt;=nl&amp;&amp;nr&lt;=158) for(int i=nl;i&lt;=nr;i++) printf(&quot;%lld &quot;,get(1,1,n,i));</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(mid[i]!=r[i])</span><br><span class="line">        q[<span class="built_in">get_max</span>(mid[i]+<span class="number">1</span>,r[i])].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(i,r[i]));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=m;i++) printf(&quot;%lld\n&quot;,ans[i]);</span></span><br><span class="line">    <span class="built_in">cover</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">0</span>),<span class="built_in">reverse</span>(h+<span class="number">1</span>,h+n+<span class="number">1</span>),<span class="built_in">run_st</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i]=n-l[i]+<span class="number">1</span>,r[i]=n-r[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l[i],r[i]),mid[i]=<span class="built_in">get_max</span>(l[i],r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="built_in">read</span>(),st[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++) p[<span class="number">1</span>&lt;&lt;i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!p[i]) p[i]=p[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">run_st</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i]=<span class="built_in">read</span>()+<span class="number">1</span>,r[i]=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">        mid[i]=<span class="built_in">get_max</span>(l[i],r[i]);</span><br><span class="line">        ans[i]=(ll)(r[i]-l[i]+<span class="number">1</span>)*h[mid[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">run</span>(),<span class="built_in">reverse</span>(),<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13 1</span></span><br><span class="line"><span class="comment">2 3 2 4 5 1 2 4 4 3 3 3 3 </span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我来说一下我都翻过什么智障错误：</p>
<ol>
<li><p>线段树查询的时候不加<code>push_down</code>。</p>
</li>
<li><p>st表从前往后处理。</p>
</li>
<li><p>线段树上二分没有判区间范围。</p>
</li>
</ol>
<p>甚至我在调第三个错误的时候对着一组 $ n=220 $ 的数据看了半天。</p>
<p>注意：还有一个小细节，就是翻转数组之后，笛卡尔树一定要<strong>严格</strong>镜像翻转。</p>
<p>也就是说假如一个区间有多个最大值，第一次你选了最左边的最大值当作区间的根，那么翻转之后也一定要让原来这个元素当根，也就是现在区间最右边的最大值。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>IOI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>dp</tag>
        <tag>笛卡尔树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>FMT/FWT学习笔记</title>
    <url>/FMT-FWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>FMT是快速莫比乌斯变换，FWT是快速沃尔什变换。</p>
<p>他们两个是用来解决位运算卷积问题的。</p>
<span id="more"></span>
<p>详细点来说，已知两个多项式 $ f,g $ 和一种运算 $ \oplus $ 。</p>
<p>需要快速求 $ h_i=\sum\limits_{j\oplus k=i}f_j\times g_k $ 。</p>
<p>当 $ \oplus $ 为按位与，按位或的时候可以使用 FMT 来解决。</p>
<p>当 $ \oplus $ 为按位异或，按位同或的时候可以使用 FWT 来解决。</p>
<p>当 $ \oplus $ 为加法时就是上面讲过的 FFT/NTT。</p>
<p>先摆出板题：</p>
<p><a href="https://www.luogu.com.cn/problem/P4717">P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)</a></p>
<p>这道题里面只有与运算，或运算和异或运算，我们一个一个看。</p>
<p>我们令一个多项式 $ a $ 的最高次项的项数 为 $ |a| $ 。</p>
<p>下面的所有描述都假设 $ |f|+1,|g|+1 $ 为 $ 2 $ 的整数次幂，即恰好有 $ 2 $ 的整数次幂项。</p>
<p>一个多项式 $ b $ ，我们使用 $ b_0 $ 表示它的前半部分(次数较小的那一半)， $ b_1 $ 表示它的后半部分(次数较大的后一半)， $ b[i] $ 表示 $ i $ 次方项的系数。</p>
<p>两个多项式 $ c,d $ ，我们使用 $ c+d $ 表示 $ c $ 和 $ d $ 逐项相加的结果；用 $ (c,d) $ 表示 $ c $ 和 $ d $ 首位相接得到的结果，例如 $ (c_0,c_1)=c $ 。</p>
<p>对于两个自然数 $ i,j $ ，我们用 $ i\in j $ 表示 $ i\And j=i $ ，同时也可以知道 $ i|j=j $ 。</p>
<h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h2><p>首先我们定义一个关于多项式的函数 $ FMT(f) $ ：</p>
<script type="math/tex; mode=display">
FMT(f)[i]=\sum\limits_{i\in j}f[j]</script><p>简单来说，就是所有“包含” $ i $ 的位置的和，也就是超集和。</p>
<p>我们的目标就是算出 $ FMT(f),FMT(g) $ ，然后算出 $ FMT(h) $ ，然后算出 $ h $ 。</p>
<p>显然我们就可以在 $ O(|f|^{\log_23}) $ 的时间内求出 $ FMT(f) $ 。</p>
<h3 id="正变换"><a href="#正变换" class="headerlink" title="正变换"></a>正变换</h3><p>显然，这样的时间复杂度我们不太可以接受。</p>
<p>所以就会有一个递归公式：</p>
<script type="math/tex; mode=display">
FMT(f)=
\begin{cases}
f&|f|=1\\
(FMT(f_0)+FMT(f_1),FMT(f_1)) & |f|\ne1
\end{cases}</script><h4 id="正变换递归公式证明"><a href="#正变换递归公式证明" class="headerlink" title="正变换递归公式证明"></a>正变换递归公式证明</h4><p>采用数学归纳法。</p>
<p>当 $ |f|=2^0 $ 时，显然。</p>
<p>假设 $ |f|=2^n $ ，则对于 $ f_0,f_1 $ ，此公式正确。</p>
<p>类比分治的思想，我们将一个区间分成两段，则只需要计算“跨越”中点的贡献，两边进行分治即可。</p>
<p>现在我们想要计算的就是 $ f_1 $ 向 $ f_0 $ 的贡献。(显然 $ f_0 $ 对 $ f_1 $ 没有贡献)</p>
<p>对于一个下标 $ i&lt;2^{n-1} $ ，现在他所缺少的贡献为 $ \sum\limits_{j&lt;2^{n-1}\wedge i\in j}f_{j+2^{n-1}} $ 。</p>
<p>仔细看这个 $ \sum $ ，看到了什么？</p>
<script type="math/tex; mode=display">
\sum\limits_{j<2^{n-1}\wedge i\in j}f_{j+2^{n-1}}=FMT(f_1)[i]</script><p>所以这个公式显然是正确的。</p>
<p>至此，我们可以在 $ O(|f|\log |f|) $ 内的时间内求出 $ FMT(f) $ 。</p>
<h3 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h3><p>首先有一个结论：$ FMT(h)=FMT(f)\ast FMT(g) $ ，这里 $ \ast  $ 为按位乘。 下来我们来证明。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&FMT(h)[i]\\
=&\sum\limits_{i\in j}h_j\\
=&\sum\limits_{i\in j}\sum\limits_{p\And q=j}f_p\times g_q\\
=&\sum\limits_{i\in(p\And q)}f_p\times g_q\\
=&\sum\limits_{i\in p\wedge i\in q}f_p\times g_q\\
=&(\sum\limits_{i\in p}f_p)\times(\sum\limits_{i\in q}g_q)\\
=&FMT(f)[i]\times FMT(g)[i]\\
\therefore&FMT(h)=FMT(f)*FMT(g)
\end{aligned}</script><p>所以说，我们就可直接将 $ FMT(f),FMT(g) $  乘起来，得到 $ FMT(h) $ 。</p>
<h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>现在我们知道了 $ FMT(h) $ 的值，想要求出 $ h $ 。</p>
<p>我们定义 $ FMT $ 的逆变换 $ UFMT $ ，使得 $ UFMT(FMT(h))=h $ 。</p>
<p>我们可以从 $ FMT $ 的定义出发，我们知道 $ FMT $ 就是超集和，所以我们只需从大到小，枚举每一个数字的超集即可。</p>
<p>和暴力 $ FMT $ 的时间复杂度是一样的，为 $ O(|f|^{\log_23}) $ 。</p>
<p>显然，<del>万恶的出题人表示无法接受</del>。</p>
<p>所以还是有一个递归公式：</p>
<script type="math/tex; mode=display">
UFMT(f)=
\begin{cases}
f&|f|=1\\
(UFMT(f_0)-UFMT(f_1),UFMT(f_1))&|f|\ne 1
\end{cases}</script><h4 id="逆变换递归公式证明"><a href="#逆变换递归公式证明" class="headerlink" title="逆变换递归公式证明"></a>逆变换递归公式证明</h4><p>首先我们根据数学归纳法证明 $ UFMT(A)+UFMT(B)=UFMT(A+B) $ 与 $ FMT(A)+FMT(B)=FMT(A+B) $。</p>
<p>$ |f|=1 $ 时显然，否则根据 $ UFMT $ 定义展开即可。</p>
<p>再进行数学归纳法证明 $ UFMT(FMT(f))=f $ ：</p>
<p>当 $ |f|=1 $ 时，显然。</p>
<p>根据定义展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&UFMT(FMT(f))\\
=&UFMT(FMT(f_0)+FMT(f_1),FMT(f_1))\\
=&UFMT(FMT(f_0+f_1),FMT(f_1))\\
=&(UFMT(FMT(f_0+f_1))-UFMT(FMT(f_1)),UFMT(FMT(f_1)))\\
=&(f_0+f_1-f_1,f_1)\\
=&(f_0,f_1)\\
=&f
\end{aligned}</script><p>所以 $ UFMT(FMT(f))=f $</p>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h2><p>其实这里和与运算差不多，会的小伙伴可以忽略。</p>
<p>我们还是定义一个关于多项式的函数 $ FMT(f) $ ：</p>
<script type="math/tex; mode=display">
FMT(f)[i]=\sum\limits_{j\in i}f[j]</script><p>简单来说，就是所有 $ i $ “包含“的位置的和，也就是子集和。</p>
<p>我们的目标就是算出 $ FMT(f),FMT(g) $ ，然后算出 $ FMT(h) $ ，然后算出 $ h $ 。</p>
<p>显然我们就可以在 $ O(|f|^{\log_23}) $ 的时间内求出 $ FMT(f) $ 。</p>
<h3 id="正变换-1"><a href="#正变换-1" class="headerlink" title="正变换"></a>正变换</h3><p>显然，这样的时间复杂度我们不太可以接受。</p>
<p>所以就会有一个递归公式：</p>
<script type="math/tex; mode=display">
FMT(f)=
\begin{cases}
f&|f|=1\\
(FMT(f_0),FMT(f_1)+FMT(f_0)) & |f|\ne1
\end{cases}</script><h4 id="正变换递归公式证明-1"><a href="#正变换递归公式证明-1" class="headerlink" title="正变换递归公式证明"></a>正变换递归公式证明</h4><p>采用数学归纳法。</p>
<p>当 $ |f|=2^0 $ 时，显然。</p>
<p>假设 $ |f|=2^n $ ，则对于 $ f_0,f_1 $ ，此公式正确。</p>
<p>类比分治的思想，我们将一个区间分成两段，则只需要计算“跨越”中点的贡献，两边进行分治即可。</p>
<p>现在我们想要计算的就是 $ f_0 $ 向 $ f_1 $ 的贡献。(显然 $ f_1 $ 对 $ f_0 $ 没有贡献)</p>
<p>对于一个下标 $ i\geqslant 2^{n-1} $ ，现在他所缺少的贡献为 $ \sum\limits_{j&lt;2^{n-1}\wedge j\in i}f_{j} $ 。</p>
<p>仔细看这个 $ \sum $ ，看到了什么？</p>
<script type="math/tex; mode=display">
\sum\limits_{j<2^{n-1}\wedge j\in i}f_{j}=\sum\limits_{j<2^{n-1}\wedge j\in (i-2^{n-1})}f_{j}=FMT(f_0)[i-2^{n-1}]</script><p>所以这个公式显然是正确的。</p>
<p>至此，我们可以在 $ O(|f|\log |f|) $ 内的时间内求出 $ FMT(f) $ 。</p>
<h3 id="相乘-1"><a href="#相乘-1" class="headerlink" title="相乘"></a>相乘</h3><p>首先有一个结论：$ FMT(h)=FMT(f)\ast FMT(g) $ ，这里 $ \ast  $ 为按位乘。 下来我们来证明。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&FMT(h)[i]\\
=&\sum\limits_{j\in i}h_j\\
=&\sum\limits_{j\in i}\sum\limits_{p|q=j}f_p\times g_q\\
=&\sum\limits_{(p|q)\in i}f_p\times g_q\\
=&\sum\limits_{p\in i\wedge q\in i}f_p\times g_q\\
=&(\sum\limits_{p\in i}f_p)\times(\sum\limits_{q\in i}g_q)\\
=&FMT(f)[i]\times FMT(g)[i]\\
\therefore&FMT(h)=FMT(f)*FMT(g)
\end{aligned}</script><p>所以说，我们就可直接将 $ FMT(f),FMT(g) $  乘起来，得到 $ FMT(h) $ 。</p>
<h3 id="逆变换-1"><a href="#逆变换-1" class="headerlink" title="逆变换"></a>逆变换</h3><p>现在我们知道了 $ FMT(h) $ 的值，想要求出 $ h $ 。</p>
<p>我们定义 $ FMT $ 的逆变换 $ UFMT $ ，使得 $ UFMT(FMT(h))=h $ 。</p>
<p>我们可以从 $ FMT $ 的定义出发，我们知道 $ FMT $ 就是子集和，所以我们只需从大到小，枚举每一个数字的子集即可。</p>
<p>和暴力 $ FMT $ 的时间复杂度是一样的，为 $ O(|f|^{\log_23}) $ 。</p>
<p>显然，<del>万恶的出题人表示无法接受</del>。</p>
<p>所以还是有一个递归公式：</p>
<script type="math/tex; mode=display">
UFMT(f)=
\begin{cases}
f&|f|=1\\
(UFMT(f_0),UFMT(f_1)-UFMT(f_0))&|f|\ne 1
\end{cases}</script><h4 id="逆变换递归公式证明-1"><a href="#逆变换递归公式证明-1" class="headerlink" title="逆变换递归公式证明"></a>逆变换递归公式证明</h4><p>首先我们根据数学归纳法证明 $ UFMT(A)+UFMT(B)=UFMT(A+B) $ 与 $ FMT(A)+FMT(B)=FMT(A+B) $。</p>
<p>$ |f|=1 $ 时显然，否则根据 $ UFMT $ 定义展开即可。</p>
<p>再进行数学归纳法证明 $ UFMT(FMT(f))=f $ ：</p>
<p>当 $ |f|=1 $ 时，显然。</p>
<p>根据定义展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&UFMT(FMT(f))\\
=&UFMT(FMT(f_0),FMT(f_0)+FMT(f_1))\\
=&UFMT(FMT(f_0),FMT(f_0+f_1))\\
=&(UFMT(FMT(f_0)),UFMT(FMT(f_0+f_1))-UFMT(FMT(f_0)))\\
=&(f_0,f_0+f_1-f_0)\\
=&(f_0,f_1)\\
=&f
\end{aligned}</script><p>所以 $ UFMT(FMT(f))=f $</p>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><p>这里就不是FMT了，就是FWT了。</p>
<p>我们还是定义一个关于多项式的函数 $ FWT(f) $ ：</p>
<script type="math/tex; mode=display">
FWT(f)[i]=\sum_{j=0}^{|f|-1}f_j\times(-1)^{\operatorname{popcount(i\And j)}}</script><p>小朋友，你是否有很多问号。</p>
<p>我们的目标还是算出 $ FWT(f),FWT(g) $ ，然后算出 $ FWT(h) $ ，然后算出 $ h $ 。</p>
<p>显然我们就可以在 $ O(|f|^2) $ 的时间内求出 $ FWT(f) $ 。</p>
<h3 id="正变换-2"><a href="#正变换-2" class="headerlink" title="正变换"></a>正变换</h3><p>这个复杂度我都看不下去了。</p>
<p>所以又会有一个递归公式：</p>
<script type="math/tex; mode=display">
FWT(f)=
\begin{cases}
f&|f|=1\\
(FWT(f_0)+FWT(f_1),FWT(f_0)-FWT(f_1)) & |f|\ne1
\end{cases}</script><h4 id="正变换递归公式证明-2"><a href="#正变换递归公式证明-2" class="headerlink" title="正变换递归公式证明"></a>正变换递归公式证明</h4><p>采用数学归纳法。</p>
<p>当 $ |f|=2^0 $ 时，显然。</p>
<p>假设 $ |f|=2^n $ ，则对于 $ f_0,f_1 $ ，此公式正确。</p>
<p>类比分治的思想，我们将一个区间分成两段，则只需要计算“跨越”中点的贡献，两边进行分治即可。</p>
<p>先来考虑 $ f_1 $ 向 $ f_0 $ 的贡献。</p>
<p>对于两个数字 $ i,j\leqslant 2^{n-1} $ ，$ f_1[j] $ 向 $ f_0[i] $ 贡献的<strong>系数</strong>显然和 $ f_1[j] $ 向 $ f_1[i] $ 贡献的<strong>系数</strong>相同。</p>
<p>所以实际上 $ f_1 $ 对 $ f_0[i] $ 的贡献就是 $ FWT(f_1)[i] $ 。</p>
<p>同样， $ f_0 $ 向 $ f_1[i] $ 的贡献就是 $ FWT(f_0)[i] $ 。</p>
<p>只是这个时候要注意，因为 $ f_0 $ 和 $ f_1 $ 拼在了一起，所以 $ f_1 $ 所有下标最高位都多了 $ 1 $ ，所以要乘上 $ -1 $，也就是公式中的那个减号。</p>
<h3 id="相乘-2"><a href="#相乘-2" class="headerlink" title="相乘"></a>相乘</h3><p>还是有一个结论：$ FWT(h)=FWT(f)\ast FWT(g) $ ，这里 $ \ast  $ 为按位乘。 下来我们来证明。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&FWT(h)[i]\\
=&\sum\limits_jh_j\times(-1)^{\operatorname{popcount}(i\And j)}\\
=&\sum\limits_j\sum\limits_{p\wedge q=j}f_p\times g_q\times(-1)^{\operatorname{popcount}(i\And j)}\\
=&\sum\limits_j\sum\limits_{p\wedge q=j}f_p\times g_q\times(-1)^{\operatorname{popcount}(i\And p)}\times(-1)^{\operatorname{popcount}(i\And q)}\\
=&\sum\limits_{p,q}f_p\times g_q\times(-1)^{\operatorname{popcount}(i\And p)}\times(-1)^{\operatorname{popcount}(i\And q)}\\
=&(\sum\limits_pf_p\times(-1)^{\operatorname{popcount}(i\And p)})\times(\sum\limits_qg_q\times(-1)^{\operatorname{popcount}(i\And q)})\\
=&FWT(f)[i]\times FWT(g)[i]\\
\therefore&FWT(h)=FWT(f)*FWT(g)
\end{aligned}</script><p>中途用到一个小结论，就是如果 $ p\wedge q=j $ 那么 $ \operatorname{popcount}(i\And j) $ 和 $\operatorname{popcount}(i\And p)+\operatorname{popcount}(i\And q) $ 奇偶性相同。</p>
<p>考虑所有 $ i $ 和 $ j $ 上都是 $ 1 $ 的位，因为 $ j $ 的这一位上是 $1 $ ，所以 $ p $ 和 $ q $ 肯定有且只有一个这一位上是 $ 1 $ 。</p>
<p>如果某一位 $ i $ 上是 $ 1 $ ，$ j $ 上是 $ 0 $ ，那么 $ p $ 和 $ q $ 肯定要么全是 $ 1 $ ，要么全是 $ 0 $ ，奇偶性不变。</p>
<p>如果某一位 $ i $ 上是 $ 0 $ ，那么这三个 $ \operatorname{popcount} $ 的值肯定全是 $ 0 $ 。</p>
<p>综上所述， $ i $ 和 $ j $ 无论怎么取，这两个式子的奇偶性都一样。</p>
<p>所以说，我们就可直接将 $ FWT(f),FWT(g) $  乘起来，得到 $ FWT(h) $ 。</p>
<h3 id="逆变换-2"><a href="#逆变换-2" class="headerlink" title="逆变换"></a>逆变换</h3><p>现在我们知道了 $ FWT(h) $ 的值，想要求出 $ h $ 。</p>
<p>定义递归公式 $ UFWT(f) $：</p>
<script type="math/tex; mode=display">
UFWT(f)=
\begin{cases}
f&|f|=1\\
(\dfrac{UFWT(f_0)+UFWT(f_1)}{2},\dfrac{UFWT(f_0)-UFWT(f_1)}{2})&|f|\ne 1
\end{cases}</script><p>现在我们想要证明 $ UFWT(FWT(f))=f $</p>
<h4 id="逆变换递归公式证明-2"><a href="#逆变换递归公式证明-2" class="headerlink" title="逆变换递归公式证明"></a>逆变换递归公式证明</h4><p>首先我们根据数学归纳法证明 $ UFWT(A)+UFWT(B)=UFWT(A+B) $ 与 $ FWT(A)+FWT(B)=FWT(A+B) $。</p>
<p>$ |f|=1 $ 时显然，否则根据 $ UFWT $ 定义展开即可。</p>
<p>再进行数学归纳法证明 $ UFWT(FWT(f))=f $ ：</p>
<p>当 $ |f|=1 $ 时，显然。</p>
<p>根据定义展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&UFWT(FWT(f))\\
=&UFWT(FWT(f_0)+FWT(f_1),FWT(f_0)-FWT(f_1))\\
=&UFWT(FWT(f_0+f_1),FWT(f_0-f_1))\\
=&(\dfrac{UFWT(FWT(f_0+f_1))+UFWT(FWT(f_0-f_1))}{2},\dfrac{UFWT(FWT(f_0+f_1))-UFWT(FWT(f_0-f_1))}{2})\\
=&(\dfrac{f_0+f_1+f_0-f_1}{2},\dfrac{f_0+f_1-f_0+f_1}{2})\\
=&(f_0,f_1)\\
=&f
\end{aligned}</script><p>所以 $ UFWT(FWT(f))=f $</p>
<p>代码放上：</p>
<p><a href="https://www.luogu.com.cn/record/76728624">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/e0toyfyi">代码</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>FMT</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT学习笔记</title>
    <url>/FFT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>FFT 的中文名称为快速傅里叶变换，英文全称为 Fast Fourier Transform。</p>
<p>主要用于快速计算多项式乘法。</p>
<span id="more"></span>
<h2 id="系数表示法"><a href="#系数表示法" class="headerlink" title="系数表示法"></a>系数表示法</h2><p>我们知道，每一个多项式都有唯一的一组系数，每一组系数也对应着唯一的一个多项式，所以我们可以用一组系数来表示一个多项式：</p>
<script type="math/tex; mode=display">
f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n\iff f(x)=\{a_0,a_1,a_2,\cdots,a_n\}</script><h2 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h2><p>我们可以把这个多项式看作平面直角坐标系上的一个函数，那么我们就可以从上面选 $ n+1 $ 个点，这些点一定可以唯一表示这个多项式。</p>
<p>为什么这么说呢？我们假设这 $ n+1 $ 个点分别是 $ (x_0,y_0),(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n) $。</p>
<p>那么我们可以由此列出方程：</p>
<script type="math/tex; mode=display">
\begin{cases}
y_0=a_0+a_1x_0^1+a_2x_0^2+\cdots+a_nx_0^n\\
y_1=a_0+a_1x_1^1+a_2x_1^2+\cdots+a_nx_1^n\\
y_2=a_0+a_1x_2^1+a_2x_2^2+\cdots+a_nx_2^n\\
\cdots\\
y_n=a_0+a_1x_n^1+a_2x_n^2+\cdots+a_nx_n^n\\
\end{cases}</script><p>我们将这些 $ x_i $ 和 $ y_i $ 带入方程组中，便得到了一个有 $ n+1 $ 个方程和 $ n+1 $ 个未知数的方程组。只要所给出的 $ x_i $ 互不相同，那么我们正好可以解得唯一的一组 $ a $，也就可以表示这个多项式了。</p>
<h2 id="FFT的基本理论"><a href="#FFT的基本理论" class="headerlink" title="FFT的基本理论"></a>FFT的基本理论</h2><p>FFT 在OI中干的事情就是快速求出两个多项式 $ f(x),g(x) $ 的乘积 $ h(x) $ ，下面我们来看他是怎么做到的。</p>
<p>首先，我们还是把 $ f(x) $ 与 $ g(x) $ 由系数表示法变为点值表示法，这个过程被叫为 DFT。</p>
<p>假设函数 $ f(x) $ 对应的点坐标分别为 $ (x_i,y_{0,i}) $，函数 $ g(x) $ 对应的点坐标分别为 $ (x_i,y_{1,i}) $。（没错，他们的横坐标要相等）</p>
<p>那么我们就可以得到 $ h(x)=\{(x_0,y_{0,0}y_{1,0}),(x_1,y_{0,1}y_{1,1}),(x_2,y_{0,2}y_{1,2}),\cdots,(x_n,y_{0,n}y_{1,n})\} $。</p>
<p>那么现在我们知道了 $ h(x) $ 的点值表示法，现在我们就可以将他表示为系数表示法，这个过程被叫为 IDFT。</p>
<p>FFT 的理论就是这个样子，但是我们也知道 DFT 暴力的时间复杂度为 $ O(n^2) $，IDFT 采用高斯消元的做法时间复杂度也为 $ O(n^3) $，使用拉格朗日插值可以做到 $ O(n^2) $。显然，FFT 的效率还不如暴力高。那么我们的主要问题就为优化 FFT 了。</p>
<p>当然，上述做法有一些漏洞。假如 $ f(x) $ 与 $ g(x) $ 的最高次项系数都为 $ n $，那么 $ h(x) $ 的最高次项系数就是 $ 2n $。此时肯定是无法用 $ n+1 $  个点表达 $ h(x) $ 这个多项式了，所以实际上我们需要不止 $ n $ 个点参与计算。</p>
<h2 id="坐标的取值"><a href="#坐标的取值" class="headerlink" title="坐标的取值"></a>坐标的取值</h2><p>我们会发现无论如何，似乎 FFT 的时间复杂度都无法得到有效的优化，那么如果我们取的横坐标是一些特殊的值呢？</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>设方程 $ x^n=1 $ 在复数意义下的解是 $ n $ 次复根，那么这样的解显然会有 $ n $ 个。设 $ \omega_n=e^\frac{2\pi i}{n} $，那么 $ x^n=1 $ 这个方程的解为 $ \omega_n^k\{k|0,1,\cdots,n-1\} $。</p>
<p>另一方面我们可以根据欧拉公式，也可以得到 $ \omega_n=e^\frac{2\pi i}{n}=\cos\left(\dfrac{2\pi}{n}\right)+i\times \sin\left(\dfrac{2\pi}{n}\right) $。</p>
<p>放一张 oi-wiki 上的图片，有助于理解。</p>
<p><img src="https://oi-wiki.org/math/poly/images/fft3.png" alt=""></p>
<h3 id="复数的性质"><a href="#复数的性质" class="headerlink" title="复数的性质"></a>复数的性质</h3><p>对于任意的正整数 $ n $ 及整数 $ k $。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_n^n&=1&(1)\\
\omega^k_n&=\omega_{2n}^{2k}&(2)\\
\omega_n^{k+\frac{n}{2}}&=-\omega_n^k&(3)
\end{aligned}</script><p>三个公式放到上面那张图里面都不难理解。</p>
<h3 id="复数的运算"><a href="#复数的运算" class="headerlink" title="复数的运算"></a>复数的运算</h3><p>设 $ x=ai+b,y=ci+d $，下面我们来推导复数的计算。</p>
<script type="math/tex; mode=display">
\begin{aligned}
x+y&=ai+b+ci+d\\
&=(a+c)i+(b+d)\\
\\
x-y&=ai+b-(ci+d)\\
&=(a-c)i+(b-d)\\
\\
x\times y&=(ai+b)(ci+d)\\
&=-ac+adi+bci+bd\\
&=(ad+bc)i+(bd-ac)
\end{aligned}</script><p>复数的除法也是可以推导的，不过我们暂时用不到。</p>
<p>我们可以打出一份复数的结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fs</span><span class="comment">//因为英语不好，所以就用拼音了......</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;<span class="comment">//x为实部，y为虚部，也就是说这个复数为x+yi</span></span><br><span class="line">    <span class="built_in">fs</span>(<span class="type">double</span> xx=<span class="number">0</span>,<span class="type">double</span> yy=<span class="number">0</span>)&#123; x=xx,y=yy;&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> + (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x+b.x,y+b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> - (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x-b.x,y-b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> * (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x*b.x-y*b.y,x*b.y+y*b.x);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h2><p>首先我们要将一个函数由系数表示法变为点值表示法，我们设这个函数为 $ f(x) $，且第 $ i $ 项的系数为 $ a_i $。</p>
<p>为了方便起见，我们设 $ f(x) $ 的项数 $ n $ 为 $ 2 $ 的整数次幂，如果项数不够可以补齐。</p>
<p>首先我们设：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&=\sum_{i\textbf{为偶数且}0\le i<n}a_ix^i\\
h(x)&=\sum_{i\textbf{为奇数且}0\le i<n}a_ix^i\\
\end{aligned}</script><p>那么就会有 $ f(x)=g(x ^2)+xh(x ^2) $。</p>
<p>我们现在要得到 $ n $ 个点的坐标，他们的横坐标分别为 $ \omega _n ^0,\omega _n ^1,\cdots,\omega _n ^{n-1} $，下面我们来推式子<del>（颓柿子）</del>。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f\left(\omega^k_n\right)&=g\left(\left(\omega^k_n\right)^2\right)+\omega_n^k\times h\left(\left(\omega^k_n\right)^2\right)\\
&=g\left(\omega_n^{2k}\right)+\omega_n^k\times h\left(\omega_n^{2k}\right)\\
&=g\left(\omega_{\frac{n}{2}}^k\right)+\omega_n^k\times h\left(\omega^k_\frac{n}{2}\right)&\textbf{这里运用了公式（2）}
\\
f\left(\omega_n^{k+\frac{n}{2}}\right)&=g\left(\left(\omega_n^{k+\frac{n}{2}}\right)^2\right)+\omega_n^{k+\frac{n}{2}}\times h\left(\left(\omega_n^{k+\frac{n}{2}}\right)^2\right)\\
&=g\left(\omega_n^{2k+n}\right)+\omega_n^{k+\frac{n}{2}}\times h\left(\omega_n^{2k+n}\right)\\
&=g\left(\omega_n^{2k}\right)+\omega_n^{k+\frac{n}{2}}\times h\left(\omega_n^{2k}\right)\\
&=g\left(\omega_n^{2k}\right)-\omega_n^k\times h\left(\omega_n^{2k}\right)&\textbf{这里运用了公式（3）}\\
&=g\left(\omega_\frac{n}{2}^k\right)-\omega_n^k\times h\left(\omega_\frac{n}{2}^k\right)&\textbf{这里运用了公式（2）}\\
\end{aligned}</script><p>可以发现什么？$ f(\omega_n^k) $ 与 $ f\left(\omega_n^{k+\frac{n}{2}}\right) $ 经过化简后第一项相同，第二项互为相反数。这时我们是否可以快速进行 DFT 呢？</p>
<p>设对一个项数为 $ n $ 的多项式进行 DFT 的过程时间复杂度为 $ T(n)=2T\left(\dfrac{n}{2}\right)+O(n) $。</p>
<p>根据主定理分析可得时间复杂度为 $ T(n)=O(n\log n) $。</p>
<p>那么我们就可以把 DFT 的代码打出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里前面还需要复数的结构体，但是前面已经打过了，不再重复</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);<span class="comment">//这个函数可以得到精确的圆周率</span></span><br><span class="line"><span class="function">fs <span class="title">omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI/n));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(fs *a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    vector&lt;fs&gt;<span class="built_in">mem</span>(n);<span class="comment">//开一个数组记录之前的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) mem[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i]=mem[<span class="number">2</span>*i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i+n/<span class="number">2</span>]=mem[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将一个函数f进行分治，a的前半部分为g，后半部分为h</span></span><br><span class="line">    <span class="built_in">DFT</span>(a,n/<span class="number">2</span>),<span class="built_in">DFT</span>(a+n/<span class="number">2</span>,n/<span class="number">2</span>);<span class="comment">//进行分治</span></span><br><span class="line">    <span class="function">fs <span class="title">now</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,step</span>=<span class="built_in">omega</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据公式计算a[i]与a[i+n/2]</span></span><br><span class="line">        <span class="comment">//注意这里顺序不能错，一定要先计算a[i+n/2]</span></span><br><span class="line">        fs num=a[i+n/<span class="number">2</span>];</span><br><span class="line">        a[i+n/<span class="number">2</span>]=a[i]-now*num;</span><br><span class="line">        a[i]=a[i]+now*num;</span><br><span class="line">        now=now*step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码还可以进行一些常数优化，不过我们后面一起进行优化。</p>
<h2 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h2><p>这个时候我们得到了答案多项式的点值表示法，我们设这个函数的第 $ i $ 项的系数为 $ a _i $ ，$ n $ 个点的坐标分别为 $ (\omega _n ^i,y _i) $ 。</p>
<p>首先我们可以换一个方式表示这些点与系数的关系。</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_0&=a_0\omega_n^0+a_1\omega_n^0+a_2\omega_n^0+\cdots+a_{n-1}\omega_n^0\\
y_1&=a_0\omega_n^0+a_1\omega_n^1+a_2\omega_n^2+\cdots+a_{n-1}\omega_n^{n-1}\\
y_2&=a_0\omega_n^0+a_1\omega_n^2+a_2\omega_n^4+\cdots+a_{n-1}\omega_n^{2(n-1)}\\
&\cdots\\
y_{n-1}&=a_0\omega_n^0+a_1\omega_n^{n-1}+a_2\omega_n^{2(n-1)}+\cdots+a_{n-1}\omega_n^{(n-1)(n-1)}\\
\end{aligned}</script><p>我们把这些式子写成矩阵的形式。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\omega_n^0&\omega_n^0&\omega_n^0&\cdots&\omega_n^0\\
\omega_n^0&\omega_n^1&\omega_n^2&\cdots&\omega_n^{n-1}\\
\omega_n^0&\omega_n^2&\omega_n^4&\cdots&\omega_n^{2(n-1)}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
\omega_n^0&\omega_n^{n-1}&\omega_n^{2(n-1)}&\cdots&\omega_n^{(n-1)(n-1)}
\end{bmatrix}
\times
\begin{bmatrix}
a_0\\a_1\\a_2\\\vdots\\a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
y_0\\y_1\\y_2\\\vdots\\y_{n-1}
\end{bmatrix}</script><p>我们再来看一看最左边的这个矩阵有什么性质：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\omega_n^0&\omega_n^0&\omega_n^0&\cdots&\omega_n^0\\
\omega_n^0&\omega_n^1&\omega_n^2&\cdots&\omega_n^{n-1}\\
\omega_n^0&\omega_n^2&\omega_n^4&\cdots&\omega_n^{2(n-1)}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
\omega_n^0&\omega_n^{n-1}&\omega_n^{2(n-1)}&\cdots&\omega_n^{(n-1)(n-1)}
\end{bmatrix}
\times
\begin{bmatrix}
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^0}&\cdots&\dfrac{1}{\omega_n^0}\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^1}&\dfrac{1}{\omega_n^2}&\cdots&\dfrac{1}{\omega_n^{n-1}}\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^2}&\dfrac{1}{\omega_n^4}&\cdots&\dfrac{1}{\omega_n^{2(n-1)}}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^{n-1}}&\dfrac{1}{\omega_n^{2(n-1)}}&\cdots&\dfrac{1}{\omega_n^{(n-1)(n-1)}}
\end{bmatrix}
=
\begin{bmatrix}
n&0&0&\cdots&0\\
0&n&0&\cdots&0\\
0&0&n&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&n
\end{bmatrix}</script><p> 右边的那个矩阵恰好是单位矩阵的 $ n $ 倍，那么我们就可以把最上面的那个矩阵进行转化。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_0\\a_1\\a_2\\\vdots\\a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^0}&\cdots&\dfrac{1}{\omega_n^0}\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^1}&\dfrac{1}{\omega_n^2}&\cdots&\dfrac{1}{\omega_n^{n-1}}\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^2}&\dfrac{1}{\omega_n^4}&\cdots&\dfrac{1}{\omega_n^{2(n-1)}}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
\dfrac{1}{\omega_n^0}&\dfrac{1}{\omega_n^{n-1}}&\dfrac{1}{\omega_n^{2(n-1)}}&\cdots&\dfrac{1}{\omega_n^{(n-1)(n-1)}}
\end{bmatrix}
\times
\begin{bmatrix}
y_0\\y_1\\y_2\\\vdots\\y_{n-1}
\end{bmatrix}
\times
\dfrac{1}{n}</script><p>我们有什么好方法？照样采用 DFT 的方法，对函数按照奇偶进行计算。</p>
<p>首先我们知道 $ \dfrac{1}{\omega _n ^{i}}=\omega _n ^{-i} $，那么我们再对上面的式子进行转化。</p>
<script type="math/tex; mode=display">
n\times
\begin{bmatrix}
a_0\\a_1\\a_2\\\vdots\\a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
\omega_n^0&\omega_n^0&\omega_n^0&\cdots&\omega_n^0\\
\omega_n^0&\omega_n^{-1}&\omega_n^{-2}&\cdots&\omega_n^{-(n-1)}\\
\omega_n^0&\omega_n^{-2}&\omega_n^{-4}&\cdots&\omega_n^{-2(n-1)}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
\omega_n^0&\omega_n^{-(n-1)}&\omega_n^{-2(n-1)}&\cdots&\omega_n^{-(n-1)(n-1)}
\end{bmatrix}
\times
\begin{bmatrix}
y_0\\y_1\\y_2\\\vdots\\y_{n-1}
\end{bmatrix}</script><p>令 $ f(\omega _n ^{-i})=na _i=\sum\limits _{j=0} ^{n-1}\omega _n ^{-ij}y _j $</p>
<p>还是像上面一样，我们设：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&=\sum_{i\textbf{为偶数且}0\le i<n}x^iy_i\\
h(x)&=\sum_{i\textbf{为奇数且}0\le i<n}x^iy_i\\
\end{aligned}</script><p>那么就有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f\left(\omega_n^{-k}\right)&=g\left(\omega_n^{-2k}\right)+\omega_n^{-k}\times h\left(\omega_n^{-2k}\right)\\
&=g\left(\omega_\frac{n}{2}^{-k}\right)+\omega_n^{-k}\times h\left(\omega_\frac{n}{2}^{-k}\right)\\
\\
f\left(\omega_n^{-k-\frac{n}{2}}\right)&=g\left(\omega_n^{-2k-n}\right)+\omega_n^{-k-\frac{n}{2}}\times h\left(\omega_n^{-2k-n}\right)\\
&=g\left(\omega_n^{-2k}\right)+\omega_n^{-k-\frac{n}{2}}\times h(\omega_n^{-2k})\\
&=g\left(\omega_n^{-2k}\right)-\omega_n^{-k}\times h(\omega_n^{-2k})\\
&=g\left(\omega_\frac{n}{2}^{-k}\right)-\omega_n^{-k}\times h(\omega_\frac{n}{2}^{-k})
\end{aligned}</script><p>我们又可以发现什么？$ f(\omega_n^{-k}) $ 与 $ f\left(\omega_n^{-k-\frac{n}{2}}\right) $ 经过化简后第一项相同，第二项互为相反数。这时我们是否可以快速进行 IDFT 呢？</p>
<p>设对一个项数为 $ n $ 的多项式进行 IDFT 的过程时间复杂度为 $ T(n)=2T\left(\dfrac{n}{2}\right)+O(n) $。</p>
<p>分析可得时间复杂度为 $ T(n)=O(n\log n) $。</p>
<p>那么我们就可以把 IDFT 的代码打出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里前面还需要复数的结构体，但是前面已经打过了，不再重复</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);<span class="comment">//这个函数可以得到精确的圆周率</span></span><br><span class="line"><span class="function">fs <span class="title">omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI/n));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(fs *a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    vector&lt;fs&gt;<span class="built_in">mem</span>(n);<span class="comment">//开一个数组记录之前的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) mem[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i]=mem[<span class="number">2</span>*i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i+n/<span class="number">2</span>]=mem[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将一个函数f进行分治，a的前半部分为g，后半部分为h</span></span><br><span class="line">    <span class="built_in">IDFT</span>(a,n/<span class="number">2</span>),<span class="built_in">IDFT</span>(a+n/<span class="number">2</span>,n/<span class="number">2</span>);<span class="comment">//进行分治</span></span><br><span class="line">    <span class="function">fs <span class="title">now</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,step</span>=<span class="built_in">omega</span>(n);</span><br><span class="line">    step.y=-step.y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据公式计算a[i]与a[i+n/2]</span></span><br><span class="line">        <span class="comment">//注意这里顺序不能错，一定要先计算a[i+n/2]</span></span><br><span class="line">        fs num=a[i+n/<span class="number">2</span>];</span><br><span class="line">        a[i+n/<span class="number">2</span>]=a[i]-now*num;</span><br><span class="line">        a[i]=a[i]+now*num;</span><br><span class="line">        now=now*step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别忘了最后要把所有a[i]变为a[i]/n</span></span><br></pre></td></tr></table></figure>
<p><del>没错这一整段是从上面那里复制之后改了一下。</del></p>
<h2 id="FFT的优化"><a href="#FFT的优化" class="headerlink" title="FFT的优化"></a>FFT的优化</h2><p>首先解决一个问题：我们在进行 DFT 与 IDFT 时都默认 $ n $ 为一个形如 $ 2^k $ 的数字，但是我们在实际应用中并不会全是这种情况。</p>
<p>其实只需要取一个比这个数大并且的最小的 $ 2^k $ 就可以了。</p>
<h3 id="合二为一"><a href="#合二为一" class="headerlink" title="合二为一"></a>合二为一</h3><p>我们可以发现 DFT 与 IDFT 的函数中只有一句不一样，那么我们就可以把这两个函数合二为一。</p>
<p>现在我们已经打得差不多了，我们来提交试一下。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);<span class="comment">//这个函数可以得到精确的圆周率</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fs</span><span class="comment">//因为英语不好，所以就用拼音了......</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;<span class="comment">//x为实部，y为虚部，也就是说这个复数为x+yi</span></span><br><span class="line">    <span class="built_in">fs</span>(<span class="type">double</span> xx=<span class="number">0</span>,<span class="type">double</span> yy=<span class="number">0</span>)&#123; x=xx,y=yy;&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> + (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x+b.x,y+b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> - (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x-b.x,y-b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> * (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x*b.x-y*b.y,x*b.y+y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">fs <span class="title">omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI/n));&#125;</span><br><span class="line">fs a[<span class="number">5000000</span>];</span><br><span class="line">fs b[<span class="number">5000000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(fs *a,<span class="type">int</span> n,<span class="type">bool</span> dft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当dft为1的时候，进行DFT</span></span><br><span class="line">    <span class="comment">//当dft为0的时候，进行IDFT</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    vector&lt;fs&gt;<span class="built_in">mem</span>(n);<span class="comment">//开一个数组记录之前的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) mem[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i]=mem[<span class="number">2</span>*i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++) a[i+n/<span class="number">2</span>]=mem[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将一个函数f进行分治，a的前半部分为g，后半部分为h</span></span><br><span class="line">    <span class="built_in">DFT</span>(a,n/<span class="number">2</span>,dft),<span class="built_in">DFT</span>(a+n/<span class="number">2</span>,n/<span class="number">2</span>,dft);<span class="comment">//进行分治</span></span><br><span class="line">    <span class="function">fs <span class="title">now</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,step</span>=<span class="built_in">omega</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(!dft) step.y=-step.y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据公式计算a[i]与a[i+n/2]</span></span><br><span class="line">        <span class="comment">//注意这里顺序不能错，一定要先计算a[i+n/2]</span></span><br><span class="line">        fs num=a[i+n/<span class="number">2</span>];</span><br><span class="line">        a[i+n/<span class="number">2</span>]=a[i]-now*num;</span><br><span class="line">        a[i]=a[i]+now*num;</span><br><span class="line">        now=now*step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    m+=n,n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">1</span>),<span class="built_in">DFT</span>(b,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)(a[i].x/n+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/record/72933524">提交记录</a></p>
<h3 id="蝴蝶变换"><a href="#蝴蝶变换" class="headerlink" title="蝴蝶变换"></a>蝴蝶变换</h3><p>虽然这份代码 AC 了，但是它显然还不够快，我们还需要进行亿点点常数优化。</p>
<p>可以注意到一个过程中常数比较大的地方：就是 DFT 过程中数组的打乱。不难发现，这个部分的时间复杂度为 $ O(n\log n) $，而且我们这里还多开了大约 $ 2n $ 个复数（就是那个叫<code>mem</code>的 vector）。</p>
<p>我们来找一下这个地方数字变化的规律，这里以 $ n=8 $ 举例，而且<strong>数字的下标以二进制书写</strong>，便于发现规律。</p>
<script type="math/tex; mode=display">
\begin{aligned}
初始：&a_{000}\kern{15pt}a_{001}\kern{15pt}a_{010}\kern{15pt}a_{011}\kern{15pt}a_{100}\kern{15pt}a_{101}\kern{15pt}a_{110}\kern{15pt}a_{111}\\
第一次变换：&a_{000}\kern{15pt}a_{010}\kern{15pt}a_{100}\kern{15pt}a_{110}\kern{15pt}a_{001}\kern{15pt}a_{011}\kern{15pt}a_{101}\kern{15pt}a_{111}\\
第二次变换：&a_{000}\kern{15pt}a_{100}\kern{15pt}a_{010}\kern{15pt}a_{110}\kern{15pt}a_{001}\kern{15pt}a_{101}\kern{15pt}a_{011}\kern{15pt}a_{111}\\
第三次变换：&a_{000}\kern{15pt}a_{100}\kern{15pt}a_{010}\kern{15pt}a_{110}\kern{15pt}a_{001}\kern{15pt}a_{101}\kern{15pt}a_{011}\kern{15pt}a_{111}\\
\end{aligned}</script><p>我们可以发现什么？</p>
<p>没错，交换前后每个位置上的数字的二进制位全部是相反的。</p>
<p>当然这是我们发现的结论，现在我们来证明。</p>
<p>采用数学归纳法：</p>
<p>首先我们知道当 $ n=1 $ 时，这个结论显然成立，因为这个时候只有一个数字。</p>
<p>现在我们要证明当 $ n=2^k(k&gt;0) $ 时结论成立，我们假设当 $ n=2^{k-1} $ 时结论成立。</p>
<p>设 $ f_{i,j} $ 为第 $ i $ 个位置上的数在 $ n=2^j $ 时经过交换之后到的地方，一个数字 $ i $ 二进制下的最低位为 $ a_i $。</p>
<p>那么 $ f_{i,k}=a_i\times 2^{k-1}+f_ {i \mod 2^{k-1} ,k-1} $ 。</p>
<p>显然，$ i $ 的最后一位放到了最前面，前面的 $ k-1 $ 位经过翻转后放到了后面，这个结论显然是正确的。</p>
<p>现在要做的就是快速计算这个翻转后的值，显然也是可以快速进行计算的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wh[i]表示i这个数经过翻转以后所对应的值</span></span><br><span class="line"><span class="comment">//wh[0]=0,不进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) wh[i]=(wh[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?n&gt;&gt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="comment">//当i的最后一位为0时，wh[i]=(wh[i&gt;&gt;1]&gt;&gt;1)</span></span><br><span class="line"><span class="comment">//当i的最后一位为1时，wh[i]=(wh[i&gt;&gt;1]&gt;&gt;1)+(n&gt;&gt;1)</span></span><br><span class="line"><span class="comment">//这个显然是正确的，道理和上面证明的过程差不多。</span></span><br></pre></td></tr></table></figure>
<p>这部分时间复杂度为 $ O(n) $，这种 FFT 比起之前的常数小了一些。</p>
<p>此外还有一些别的优化，例如提前计算 <code>step</code> 的值，将递归改为循环等，由于比较简单，这里不详细展开。</p>
<p>我们就直接重写代码，看一下提交结果。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">fs</span>(<span class="type">double</span> xx=<span class="number">0</span>,<span class="type">double</span> yy=<span class="number">0</span>)&#123; x=xx,y=yy;&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> + (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x+b.x,y+b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> - (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x-b.x,y-b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> * (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x*b.x-y*b.y,x*b.y+y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">fs <span class="title">omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI/n));&#125;</span><br><span class="line">fs step[<span class="number">5000001</span>];</span><br><span class="line"><span class="type">int</span> wh[<span class="number">5000001</span>];</span><br><span class="line">fs a[<span class="number">5000000</span>];</span><br><span class="line">fs b[<span class="number">5000000</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(fs *a,<span class="type">int</span> n,<span class="type">bool</span> dft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;wh[i]) <span class="built_in">swap</span>(a[i],a[wh[i]]);</span><br><span class="line">    <span class="comment">//有这个if就可以确保只换一次，当然也可以写成if(i&gt;wh[i])...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fs ste=step[len];</span><br><span class="line">        <span class="keyword">if</span>(!dft) ste.y=-ste.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">fs <span class="title">now</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;l+len/<span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                fs num=a[i+len/<span class="number">2</span>]*now;</span><br><span class="line">                a[i+len/<span class="number">2</span>]=a[i]-num;</span><br><span class="line">                a[i]=a[i]+num;</span><br><span class="line">                now=now*ste;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(fs *a,fs *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>) step[i]=<span class="built_in">omega</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) wh[i]=(wh[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?n&gt;&gt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">1</span>),<span class="built_in">DFT</span>(b,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    m+=n,n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a,b,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)(a[i].x/n+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/record/72999362">提交记录</a></p>
<h3 id="三次变两次"><a href="#三次变两次" class="headerlink" title="三次变两次"></a>三次变两次</h3><p>三次变两次是通过一种特殊的方法，少进行一次 DFT 的优化（由原来的 $ 2 $ 次 DFT 和 $ 1 $ IDFT变为各有一次）。</p>
<p>假设我们现在想要求两个多项式 $ f(x) $ 和 $ g(x) $ 的乘积，不妨设<strong>复多项式</strong> $ h(x)=f(x)+g(x)i $。</p>
<p>那么就有 $ h ^2(x)=(f(x)+g(x)i) ^2=f ^2(x)-g ^2(x)+2f(x)g(x)i $。</p>
<p>它的虚部不就正好是我们要求的乘积的两倍吗？</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">fs</span>(<span class="type">double</span> xx=<span class="number">0</span>,<span class="type">double</span> yy=<span class="number">0</span>)&#123; x=xx,y=yy;&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> + (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x+b.x,y+b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> - (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x-b.x,y-b.y);&#125;</span><br><span class="line">    fs <span class="keyword">operator</span> * (fs b)&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(x*b.x-y*b.y,x*b.y+y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">fs <span class="title">omega</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fs</span>(<span class="built_in">cos</span>(<span class="number">2</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2</span>*PI/n));&#125;</span><br><span class="line">fs step[<span class="number">5000001</span>];</span><br><span class="line"><span class="type">int</span> wh[<span class="number">5000001</span>];</span><br><span class="line">fs a[<span class="number">5000000</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(fs *a,<span class="type">int</span> n,<span class="type">bool</span> dft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;wh[i]) <span class="built_in">swap</span>(a[i],a[wh[i]]);</span><br><span class="line">    <span class="comment">//有这个if就可以确保只换一次，当然也可以写成if(i&gt;wh[i])...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fs ste=step[len];</span><br><span class="line">        <span class="keyword">if</span>(!dft) ste.y=-ste.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">fs <span class="title">now</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;l+len/<span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                fs num=a[i+len/<span class="number">2</span>]*now;</span><br><span class="line">                a[i+len/<span class="number">2</span>]=a[i]-num;</span><br><span class="line">                a[i]=a[i]+num;</span><br><span class="line">                now=now*ste;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(fs *a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>) step[i]=<span class="built_in">omega</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) wh[i]=(wh[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+((i&amp;<span class="number">1</span>)?n&gt;&gt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*a[i];</span><br><span class="line">    <span class="built_in">DFT</span>(a,n,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].y);</span><br><span class="line">    m+=n,n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)(a[i].y/n/<span class="number">2</span>+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/record/76489625">提交记录</a></p>
<p>可以看到，快了不少。</p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOI2019] 矩形区域</title>
    <url>/IOI2019%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>今天打模拟赛遇到的，不得不说有点神仙，所以来写一篇题解。</p>
<span id="more"></span>
<p>因为这题是 IOI 的，IOI 的很多题子任务都提示了做法，所以本题解中对大部分 Subtask 进行了分析。</p>
<p>我写这篇题解主要是想要分享一下我做这道题的过程，我认为一道题的思考过程才是最重要的。</p>
<p>注意：</p>
<ol>
<li><p>由于作者的叙述习惯不同，本文中<strong>所有矩阵的下标均从 $ 1 $ 开始计数</strong>。</p>
</li>
<li><p>如果时间复杂度中没有出现 $ m $ ,那么这个地方的时间复杂度默认 $ n,m $ 同阶。</p>
</li>
</ol>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5781">luoguP5781</a></p>
<h3 id="Subtask-5"><a href="#Subtask-5" class="headerlink" title="Subtask 5"></a>Subtask 5</h3><p>由于这个 Subtask 条件比较特殊，所以我们先来看它。</p>
<p>这个矩阵最多只有三行，根据题目中对子矩阵的要求，我们可以知道这些子矩阵的元素只能出现在第二行。</p>
<p>首先我们可以知道在这个限制下某个元素可以出现的必要条件是它严格大小于它上下的元素。</p>
<p>然后我们将所有第二行的元素从小到大进行排序，并依次加入这些格子，加入某个格子后我们可以查看这个格子所在的连通块是否合法，然后统计答案即可。</p>
<p>干说不明白，不如画几个图。</p>
<p>假如这是那个矩阵。</p>
<p><a href="https://imgtu.com/i/XaHQ2R"><img src="https://s1.ax1x.com/2022/06/04/XaHQ2R.png" alt="XaHQ2R.png"></a></p>
<p>首先我们看一下有哪些格子可能作为子矩阵中的元素，我们将他们标红</p>
<p><a href="https://imgtu.com/i/XaHn54"><img src="https://s1.ax1x.com/2022/06/04/XaHn54.png" alt="XaHn54.png"></a></p>
<p>然后我们将第二行中的元素排好序，逐个加入。</p>
<p>首先我们加入 $ 1 $ ，就可以得到一个子矩阵（左端点下标为 $ 2 $ ，右端点下标也为 $ 2 $ ）。</p>
<p><a href="https://imgtu.com/i/XaHlx1"><img src="https://s1.ax1x.com/2022/06/04/XaHlx1.png" alt="XaHlx1.png"></a></p>
<p>然后我们加入 $ 4 $ ，又可以得到一个子矩阵（左端点下标为 $ 4 $ ，右端点下标也为 $ 4 $ ）。</p>
<p><a href="https://imgtu.com/i/XaHMG9"><img src="https://s1.ax1x.com/2022/06/04/XaHMG9.png" alt="XaHMG9.png"></a></p>
<p>下来我们加入 $ 6 $ ，又可以得到一个子矩阵（左端点下标为 $ 1 $ ，右端点下标为 $ 6 $ ）。</p>
<p><a href="https://imgtu.com/i/XaHn54"><img src="https://s1.ax1x.com/2022/06/04/XaHn54.png" alt="XaHn54.png"></a></p>
<p>再然后我们加入 $ 9 $ ，可以发现，新形成的矩阵中没有一个满足要求(没有只包含红色方块)。</p>
<p><a href="https://imgtu.com/i/XaHKPJ"><img src="https://s1.ax1x.com/2022/06/04/XaHKPJ.png" alt="XaHKPJ.png"></a></p>
<p>最后我们加入 $ 10 $ ，新形成的矩阵还是没有一个满足要求(没有只包含红色方块)。</p>
<p><a href="https://imgtu.com/i/XaHYVO"><img src="https://s1.ax1x.com/2022/06/04/XaHYVO.png" alt="XaHYVO.png"></a></p>
<p>大概就是这样子的一个过程，我们就可以拿到 $ 10 $ 分的“高”分。</p>
<h3 id="Subtask1"><a href="#Subtask1" class="headerlink" title="Subtask1"></a>Subtask1</h3><p>我们可以枚举这个子矩阵的位置，然后对每个子矩阵看一下是否合法。</p>
<p>然后你就会发现这样子是 $ O(n^6) $ 的，虽然这题时限是 $ 5s $ ，<strong>可能</strong>能过。</p>
<p>我们可以来找一下性质。</p>
<p>不妨来看一眼，某个子矩阵的右边界从红色的这条线向右走到蓝色的这条线时，这个新矩阵什么情况下是合法的（假如只右移了一格）。</p>
<p><a href="https://imgtu.com/i/Xaqq29"><img src="https://s1.ax1x.com/2022/06/04/Xaqq29.png" alt="Xaqq29.png"></a></p>
<p>首先我们对于每一行，预处理出这一行第 $ l $ 个元素到第 $ r $ 个元素的最大值是多少，这样就可以用 $ O(1) $ 得知某一行是否合法，然后我们对于最右边的一列，暴力求出最大值，计算最右边那一列是否合法就可以了。</p>
<p>这样的时间复杂度是 $ O(n^5) $ 的。</p>
<p>这样我们就又可以拿到 $ 8 $ 分。</p>
<h3 id="Subtask2"><a href="#Subtask2" class="headerlink" title="Subtask2"></a>Subtask2</h3><p>这个部分做法感觉和 Subtask5 有点类似。</p>
<p>我们可以枚举这个子矩阵的上边界和下边界，这个时候我们看哪一列有可能在这个子矩阵之中出现。（由于我们枚举的是上边界和下边界，所以某一列一定是同时出现或同时不出现。）（出现的条件也差不多，这一列中最大的那个元素比上下的元素都小。）</p>
<p>然后我们就会发现这次我们每一次是加入整个列，那么我们该按什么顺序加入这些列呢？</p>
<p>我们不妨按照这个列的最大值进行排序，最大值越小的越先加入。</p>
<p>我们再处理一下相邻两列的关系，再来举一个例子。</p>
<p><a href="https://imgtu.com/i/XaXZ4S"><img src="https://s1.ax1x.com/2022/06/04/XaXZ4S.png" alt="XaXZ4S.png"></a></p>
<p>显然，这两列都是有可能成为某个子矩阵中的元素。</p>
<p>但是，如果第一列在子矩阵中出现，第二列也一定出现；如果第二列出现了，第一列也一定出现，这就形成了一些“连带关系”。</p>
<p>我们只要提前预处理这些“连带关系”，到时候具有连带关系的列一起加入就可以了。</p>
<p>这样子时间复杂度是 $ O(n^4) $ 的，我们又可以拿到 $ 7 $ 分。</p>
<h3 id="Subtask3"><a href="#Subtask3" class="headerlink" title="Subtask3"></a>Subtask3</h3><p>注意，这个地方的解法已经和满分有一定关系了（起码我的做法是这个样子）。</p>
<p>不妨这样想，我们要找的子矩阵，既需要满足行的条件，又需要满足列的条件。</p>
<p>那我们能不能找出所有满足行条件的子矩阵，再找出所有满足列条件的子矩阵呢，最后找出它们中相同的呢？</p>
<p>显然，不会算多，也不会算少，这个方法很可行。</p>
<p>我们来看一下所有满足行条件的子矩阵怎么找：</p>
<p>这个问题似乎不太好想，我们从简单的想起，假如说我们要找的子矩阵只有一行，怎么办。</p>
<p>这不就是上面提到的 Subtask5 吗？</p>
<p>假如说这个子矩阵有两行呢？它需要满足什么条件？</p>
<p>稍微想一下就会发现，只需要第一行的那些元素可行，第二行的那些元素可行，这个子矩阵就是可行的。</p>
<p>再进一步扩展，如果一个左上角坐标为 $ (u,l) $ ，右下角坐标为 $ (d,r) $ 的子矩阵可行，就只需要第 $ l $ 行到第 $ r $ 中每一行的对应子矩阵（该行的第 $ l $ 列到第 $ r $ 列）可行就可以了。</p>
<p>直接算就可以了，那么时间复杂度是多少呢？</p>
<p>首先我们知道，对于单行来说，可行的子矩阵最多只有 $ m $ 个。</p>
<p>矩阵一共有 $ n $ 行，对于该行的每一个子矩阵，我们都要向下找下面所有行中能和这一行共同组成的子矩阵数量，所以这里时间复杂度是 $ O(n^2m) $ 的。</p>
<p>接下来我们还要进行矩阵的匹配，显然还要使用 set。</p>
<p>最后时间复杂度是 $ O(n^2m\log{nm}) $ 的。</p>
<p>事实上可以过 Subtask1,2,3,5,6。</p>
<p>到这里，我们就可以拿到 $ 50 $ 分，还是挺香的。</p>
<h3 id="Subtask4"><a href="#Subtask4" class="headerlink" title="Subtask4"></a>Subtask4</h3><p>我们会发现，这个 Subtask 只需要 $ O(n^3) $ 的时间复杂度就可以了，不难发现，上面那个做法的瓶颈主要在于矩阵的匹配，有什么更好的做法呢？</p>
<p>我们在枚举行矩阵/列矩阵的时候不妨换一种方式，下面拿行矩阵举例。</p>
<p>不难发现，对于一组确认的左边界、上边界与右边界，一个合法的下边界必定是连续的一段区间。</p>
<p>列矩阵也是一样，对于一组确认的上边界、左边界和下边界，一个合法的有边界也是连续的一段区间。</p>
<p>再转化一下，对于一个固定的点，我们把它作为矩阵的左上角，那么一个合法行矩阵的右下角肯定是一堆竖着的线段，一个合法的列矩阵肯定是一堆横着的线段。任何一个横着的线段和任何一个竖着的线段的交点（如果它们有交点）一定是一个合法的右下角。</p>
<p>我们只需要枚举一个左上角的点，然后枚举横着的和竖着的线段，看他们有没有交点就好了。</p>
<p>时间复杂度看起来是 $ O(n^4) $ 的，但是对于每一行来说，与之对应的横线段最多有 $ n $ 个，竖线段最多有 $ m $ 个。</p>
<p>所以时间复杂度是 $ O(n^2m) $ 的。</p>
<p>可以过 Subtask1,2,3,4,5,6，拿到了 $ 72 $ 分。</p>
<p>可能说的有一点难懂，这部分代码我就放一下。</p>
<p><a href="https://www.luogu.com.cn/paste/6r24kgk7">代码</a></p>
<p>因为我们学校 OJ 比较快，比赛当时这份程序拿了 $ 72 $ 分，但是 luogu 上只拿了 $ 37 $ 分，卡一卡应该也差不多（雾</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>说了这么多终于说到了。</p>
<p>我们首先可以发现无论是上面寻找行矩阵/列矩阵，还是下面进行匹配的过程，都是 $ n^2m $ 的，无法通过本题，所以上述两部分都需要优化。</p>
<h4 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h4><p>先来优化寻找行矩阵/列矩阵的部分。</p>
<p>我们来看瓶颈在哪里，不难发现是在加入“线段”的过程，我们需要枚举一个点( $ O(nm) $ )，然后向下/右延申线段。</p>
<p>不难发现，其中一部分枚举是重复的。因为当我们找到一个行矩阵时候，这个矩阵去掉最上面/最下面一行，剩下的行矩阵必定合法，列矩阵也是一样。</p>
<p>这个样子，我们就可以将这部分优化到 $ O(nm\log m) $。</p>
<p>为啥有个 $ \log $ ？因为我们在每一行/列中都要对元素进行排序。</p>
<h4 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h4><p>不难发现，这个部分其实就是一个找线段有多少个交点的过程。</p>
<p>我们直接树状数组统计一下就可以了。</p>
<p>其实看起来简单，实际细节还是有亿点的，具体可以看代码。</p>
<p>最终时间复杂度是 $ O(n^2\log n) $。</p>
<p>代码：</p>
<p>这份代码 luogu 上可过，请放心<del>食用</del>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;T&gt;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> i&amp;(-i);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> pqueue=priority_queue&lt;A,vector&lt;A&gt;,greater&lt;A&gt; &gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> wh;</span><br><span class="line">    <span class="built_in">line</span>(<span class="type">int</span> l=<span class="number">0</span>,<span class="type">int</span> r=<span class="number">0</span>,<span class="type">int</span> wh=<span class="number">0</span>) :<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">wh</span>(wh)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> wh;</span><br><span class="line">&#125;b[<span class="number">2501</span>];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (line a,line b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">r</span>&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt; (line a,line b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line">vc&lt;line&gt;ans1[<span class="number">2502</span>][<span class="number">2502</span>];</span><br><span class="line">vc&lt;line&gt;ans2[<span class="number">2502</span>][<span class="number">2502</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;vis[<span class="number">2502</span>][<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">2502</span>][<span class="number">2502</span>];</span><br><span class="line">line num1[<span class="number">2502</span>];</span><br><span class="line">line num2[<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">2502</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> fa[num]=<span class="built_in">find</span>(fa[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> wh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[wh]=l[wh]=r[wh]=wh;</span><br><span class="line">    <span class="keyword">if</span>(fa[wh<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="built_in">find</span>(wh<span class="number">-1</span>);</span><br><span class="line">        fa[num]=wh,l[wh]=l[num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa[wh+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="built_in">find</span>(wh+<span class="number">1</span>);</span><br><span class="line">        fa[num]=wh,r[wh]=r[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> wh,<span class="type">int</span> ma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">find</span>(wh);</span><br><span class="line">    <span class="keyword">if</span>(num!=wh) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l[wh]==<span class="number">1</span>||r[wh]==ma) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d\n&quot;,i,l[wh],r[wh]);</span></span><br><span class="line">    vis[l[wh]][r[wh]].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=y;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gett</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) b[j].num=a[i][j],b[j].wh=j;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,[](node a,node b)&#123; <span class="keyword">return</span> a.num&lt;b.num;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,k;j&lt;=m;j=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=j;k&lt;=m&amp;&amp;b[j].num==b[k].num;k++);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=j;y&lt;k;y++) <span class="built_in">add</span>(b[y].wh);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=j;y&lt;k;y++) <span class="built_in">push</span>(i,b[y].wh,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) fa[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=m;s++) <span class="keyword">for</span>(<span class="type">int</span> e=s;e&lt;=m;e++) <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>,j;i&lt;vis[s][e].<span class="built_in">size</span>();i=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;vis[s][e].<span class="built_in">size</span>()&amp;&amp;vis[s][e][j]-j==vis[s][e][i]-i;j++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> k=i;k&lt;j;k++) ans1[vis[s][e][k]][s].<span class="built_in">push_back</span>(<span class="built_in">line</span>(vis[s][e][k],vis[s][e][j<span class="number">-1</span>],e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) vis[i][j].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i].num=a[i][j],b[i].wh=i;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,[](node a,node b)&#123; <span class="keyword">return</span> a.num&lt;b.num;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k;i&lt;=n;i=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=i;k&lt;=n&amp;&amp;b[i].num==b[k].num;k++);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=i;x&lt;k;x++) <span class="built_in">add</span>(b[x].wh);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=i;x&lt;k;x++) <span class="built_in">push</span>(j,b[x].wh,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=n;s++) <span class="keyword">for</span>(<span class="type">int</span> e=s;e&lt;=n;e++) <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>,j;i&lt;vis[s][e].<span class="built_in">size</span>();i=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;vis[s][e].<span class="built_in">size</span>()&amp;&amp;vis[s][e][j]-j==vis[s][e][i]-i;j++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> k=i;k&lt;j;k++) ans2[s][vis[s][e][k]].<span class="built_in">push_back</span>(<span class="built_in">line</span>(vis[s][e][k],vis[s][e][j<span class="number">-1</span>],e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tot1=<span class="number">0</span>,tot2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(line k:ans1[i][j]) num1[++tot1]=k;</span><br><span class="line">        <span class="keyword">for</span>(line k:ans2[i][j]) num2[++tot2]=k;</span><br><span class="line">        <span class="built_in">sort</span>(num1+<span class="number">1</span>,num1+tot1+<span class="number">1</span>,[](line a,line b)&#123; <span class="keyword">return</span> a.wh&lt;b.wh;&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(num2+<span class="number">1</span>,num2+tot2+<span class="number">1</span>,[](line a,line b)&#123; <span class="keyword">return</span> a.l&lt;b.l;&#125;);</span><br><span class="line">        pqueue&lt;line&gt;que;<span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=tot1;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(now&lt;=tot2&amp;&amp;num2[now].l&lt;=num1[k].wh) <span class="built_in">addt</span>(num2[now].wh,<span class="number">1</span>),que.<span class="built_in">push</span>(num2[now]),now++;</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">size</span>()&amp;&amp;que.<span class="built_in">top</span>().r&lt;num1[k].wh) <span class="built_in">addt</span>(que.<span class="built_in">top</span>().wh,<span class="number">-1</span>),que.<span class="built_in">pop</span>();</span><br><span class="line">            ans+=<span class="built_in">gett</span>(num1[k].r)-<span class="built_in">gett</span>(num1[k].l<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) <span class="built_in">addt</span>(que.<span class="built_in">top</span>().wh,<span class="number">-1</span>),que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>IOI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucas定理</title>
    <url>/Lucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>已知质数 $ p $ 与自然数 $ n,m $ 。</p>
<p>求证 $ \dbinom{n}{m}\bmod p=\dbinom{\left\lfloor n/p\right\rfloor}{\left\lfloor m/p\right\rfloor}\times\dbinom{n\bmod p}{m\bmod p}\bmod p $</p>
<span id="more"></span>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>首先先来看一个式子的取值：$ \dbinom{p}{n}\bmod p $ 。</p>
<p>首先我们可以将式子展开：$ \dbinom{p}{n}=\dfrac{p!}{n!(p-n)!} $ 。</p>
<p>由于 $ p $ 是一个质数，所以我们知道 $ p! $ 中恰好只含有一个 $ p $ 。</p>
<p>$ n!(p-n)! $ 只有当 $ n=p $ 或 $ n=0 $ 时才会含有一个 $ p $ 。</p>
<p>所以在 $ n=0\vee n=p $ 时 $ \dbinom{p}{n}\bmod p=1 $ ，其他时候 $ \dbinom{p}{n}\bmod p=0 $ 。</p>
<p>再来看一个式子的取值：$ (a+b)^p $。</p>
<p>不妨暴力展开。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(a+b)^p&\equiv\sum_{n=0}^p\dbinom{p}{n}a^nb^{p-n}\\
&\equiv\dbinom{p}{0}a^0b^p+\dbinom{p}{p}a^pb^0\\
&\equiv a^p+b^p
\end{aligned}</script><p>然后我们还知道：$ \dbinom{n}{m} $ 其实是多项式 $ (1+x)^n $ 中，$ x^m $ 的系数。</p>
<p>所以再来推一推：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1+x)^n\\
=&(1+x)^{p\left\lfloor n/p\right\rfloor}(1+x)^{n\bmod p}\\
=&(1+x^p)^{\left\lfloor n/p\right\rfloor}(1+x)^{n\bmod p}
\end{aligned}</script><p>显然，前面的一个括号中，只有 $ x^{p\times a}(a\in\mathbb{N}) $  的项才有系数，后面的括号中，只有 $ x^{&lt;p} $ 的项中才有系数。</p>
<p>所以若 $ m=ap+b(0\leqslant b&lt;p) $ ，则 $ x^m $ 中的 $ m $ 个 $ x $ ，必然有 $ ap $ 个来自前面， $ b $ 个来自后面。</p>
<p>所以 $ \dbinom{n}{m}\bmod p=\dbinom{\left\lfloor n/p\right\rfloor}{\left\lfloor m/p\right\rfloor}\times\dbinom{n\bmod p}{m\bmod p}\bmod p $ 。</p>
]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title>ISIJ2022游记</title>
    <url>/ISIJ2022%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>今年ISIJ是 $ 7 $ 月 $ 1 $ 号到 $ 10 $ 号，就把 $ 7 $ 月 $ 1 $ 号当Day$ 1 $ 吧。</p>
<span id="more"></span>
<h2 id="Day-11"><a href="#Day-11" class="headerlink" title="Day -11"></a>Day -11</h2><p>陕西省的地理、生物学考。</p>
<p>两科满分都是 $ 60 $ ，之前学校的考试我基本就没有上过 $ 50 $ ，老师说想要稳一点拿A需要 $ 55 $ 分，我还想着直接不复习了，摆大烂。<del>然而考试前还是复习了一早上。</del></p>
<p>到了考场之后人感觉还行，基本没有压力，因为感觉拿A不可能，拿C更不可能，所以直接随便考。</p>
<p>考的时候一看：这都是什么题啊？确认跟我平时做的是一个难度嘛？</p>
<p>考完出来感觉非常良好。</p>
<p>$ 7 $ 月查分的时候发现两科加起来 $ 118 $ ，应该都是 $ 59 $ 分，被老师骗了啊，陕西的学考要多水还是多水……</p>
<h2 id="Day-10-0"><a href="#Day-10-0" class="headerlink" title="Day -10~0"></a>Day -10~0</h2><p>whk 那边没什么事，直接停课搞 OI。</p>
<p>似乎没啥大事。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>试机赛。</p>
<p>感觉没啥卵用</p>
<p>因为之前我们的模拟赛已经试过几次环境了，所以今天直接就放假了。</p>
<p>颓了一个上午加一个下午，吃完晚饭想起来有试机赛就去看了一眼题。</p>
<p>T1:$ a+b $ problem</p>
<p>T2:$ a^ 2+b^2 $ problem</p>
<p>欸，我怎么觉得在哪个大佬前几年的游记里见过这个配置？</p>
<p>T3打了打，被卡常了，当场被气到去颓圮。</p>
<p>有可能是我人傻常数大吧。</p>
<p>后来才知道同校大佬lrs就没打…</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>训练赛。</p>
<p>这一场就是在我们的比赛环境打了。</p>
<p>这一场是下午三点开始的。</p>
<p>一开场，这不对吧？</p>
<p>看了一眼题目上的几个数字，$ 123,111,888999 $ 。</p>
<p>蛤？</p>
<p>再一看样例，$ 1 $ 组数据，输入是 $ 100 $ ，输出是 $ 54 $ 。</p>
<p>蛤？</p>
<p>2019年ISIJ的训练赛原题？</p>
<p>而且还给我们做过？</p>
<p>我飞快地码了一个数位dp，$ 4 $ 分钟的时候过了这题，苟了一个第一。</p>
<p>第二题，一看，这不是一眼数位dp。</p>
<p>大概就是给你一个最多 $ 100000 $ 位的数字 $ C $ ，求 $ A,B $ 的数量，使得 $ A+B=C $ 且 $ A $ 和 $ B $ 中都没有相邻的相同的数字。</p>
<p>打了一会，又调了一会。</p>
<p>交上去一看，没过？</p>
<p>错误类型是 PE？？？</p>
<p>点开详细信息，全称是Presentation error，而且全挂？</p>
<p>调了半天，突然想起了什么东西，题目往上一翻，文件读写。</p>
<p>我真的是<strong><strong>**</strong></strong>。</p>
<p>翻到T1一看，既可以标准输入输出又可以文件读写，我真的屑屑主办方。</p>
<p>看一眼T3，嗯，文件读写（真·唯一重点信息）。</p>
<p>发现就是一个混合了哈希的大模拟。</p>
<p>打了一会，又调了半天。</p>
<p>最后在 $ 1 $ 时 $ 20 $ 分的时候AK了。</p>
<p>lrs就略有点惨，T2的文件读写在 $56 $ 分钟的时候才看出来，T3还被卡常了。</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>数学赛。</p>
<p>具体感觉没啥。</p>
<p>一共 $ 15 $ 道题，全是小学奥数。</p>
<p>没有AK的原因完全是因为题面写的就是一坨*。</p>
<p>英文题面真的是肾么东西都没有翻译出来。</p>
<p>早知道就应该去看俄文题面。</p>
<p>屑主办方甚至在比赛结束后改了某题的英文题面。</p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>代码赛。</p>
<p>说是有调代码，补全代码等试题。</p>
<p>实际上就是给你两道题让你做……</p>
<p>T1大家都会，啥难度没有。</p>
<p>T2的 $ 50 $ 分大家都会，啥难度没有。</p>
<p>两个人AK了，剩下的中国选手（A队）全是 $ 150 $ 分，无语住了。</p>
<h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>杯赛。</p>
<p>这一场就是发奖牌的那一场，也是我们主要备战的一场。</p>
<p>这一场时间挺长，一共 $ 4 $ 个小时，所以被叫成马拉松。</p>
<p>T1是简单题，开场 $ 5 $ 分钟我发现我少看一个条件，然后直接一个拓扑排序过了T1。</p>
<p>看完了T2,T3,T4，感觉都不是特别有思路。</p>
<p>但是我注意到了T4的题面上并没有给任何的部分分。</p>
<p>我当时就觉得T4可能比较简单，因为T1的题面上也没有部分分，T2和T3倒是都给了部分分。</p>
<p>仔细想想，发现好像没啥事干，然后就去先打了C的暴力。</p>
<p>打了一会， $ 30 $ 分就肝出来了，本来打的是 $ 40 $ 分，但是不知道哪里挂了。</p>
<p>这个时候差不多到下午 $ 4 $ 点了（比赛开始 $ 1 $ 小时）。</p>
<p>我看了一眼榜，这个时候已经有人把T4过了，说明T4应该比中间两题简单，所以我就又去想T4。</p>
<p>T4感觉挺有意思，说是让你选一些砝码，重量可重，重量加在一起恰好是 $ n $ 克。</p>
<p>这些砝码需要能够组成 $ 1\sim n $ 的所有重量（砝码只能放在天平一边），并且对于每一个重量，恰有一种方案。</p>
<p>输出所有砝码数量最少的方案，$ 100 $ 组询问，$ n\leqslant 10^5 $ 。</p>
<p>然而我当时傻了，没有看到“恰有一种方案”这个条件。</p>
<p>我一想，那不就是先构造一个 $ 1,2,4,8,\dots $ ，然后随便挑一些数字 $ -1 $ 嘛。</p>
<p>一交，挂了，一分没得。</p>
<p>大概到 $ 5 $ 点的时候，我还是没有看到那个条件，这个时候lrs已经把这道题过了。</p>
<p>然后我终于看到了那个条件，重新打了代码，还是挂，一直挂。</p>
<p>一直到 $ 5 $ 点 $ 40 $ 左右，我还是无法理解，为什么会挂。直到这个时候我还是 $ 0 $ 分。</p>
<p>实在无语了，我写了一个非常暴力的dfs上去，结果拿了 $ 15 $ 分，我直接蚌埠住了。</p>
<p>然后拍了拍，发现我有一个关键结论是错的，但是只需要改一下就可以了。</p>
<p>然后在 $ 6 $ 点过一点的时候过了T4，一共交了 $ 10 $ 发。</p>
<p>这个时候整个人都轻松下来了。</p>
<p>T2有 $ 45 $ 很简单，建一个SAM，然后随便dfs两下就行。</p>
<p>我打了 $ 20 $ 分钟左右，加上去就直接拿到了这 $ 45 $ 分。</p>
<p>然后就来看T3，发现了之前程序的bug，交了一发拿了 $ 40 $ 分。</p>
<p>这个时候离比赛结束还有半小时。</p>
<p>我看了一下剩下没有骗的两个部分分，还是觉得T3的 $ 20 $ 分可能更好骗（事实上确实是这样）。</p>
<p>打了好久，在最后一刻挂掉了，但是，我骗到了一半的部分分，$ 40\to 50 $ 。</p>
<p>最后 $ 100+45+50+100=295 $ ，A组第二，%%%AK的zhoukangyang大佬。</p>
<p>讲真的，如果不是最后一小时极限翻盘，游记可能就得写成游寄了。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>团队赛。</p>
<p>给我分配的最难的那道题，好像连部分分都没有。</p>
<p>最后一刻交了一个样例都过不去的代码，哭…</p>
<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>啥事没有。</p>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>临时通知机器人比赛我们也要参加。</p>
<p>学了一天Arduino。</p>
<h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><p>机器人比赛。</p>
<p>比赛时才发现只是需要Arduino的主板而已……</p>
<p>好像是个什么神奇的玩意，我连题都没读懂。</p>
<p>内存限制好像还是2个K。</p>
<p>摆了。</p>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>颁奖。</p>
<p>就是发了各个比赛的奖。</p>
<h2 id="Day-11-1"><a href="#Day-11-1" class="headerlink" title="Day 11"></a>Day 11</h2><p>拿到了电子版的获奖证书。</p>
<p>牌子不知道什么时候能拿到，估计得到半年以后？</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>[JOI2015]舞踏会</title>
    <url>/JOI2015_4/</url>
    <content><![CDATA[<p>打模拟赛遇到的，同学都是一眼秒，只有我在乱七八糟贪。</p>
<p>最近已经遇到好几个题是一眼dp，但我没看出来了。</p>
<p><a href="https://www.luogu.com.cn/problem/AT_joi2015ho_d">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ n $ 个人在一个队列里面，每一个人有一个能力值是 $ a_i $ ，保证 $ n $ 是奇数。</p>
<p>每一次取出队列中最前面的三个人，去掉能力最大的和最小的，把剩下的那个人（中位数）放到队尾。</p>
<p>最后剩下一个人的时候，留下的那个人就是这种排队方案的权值。</p>
<p>现在已经有 $ m $ 个人确定了自己初始时在队列中的位置，你需要给剩下的 $ n-m $ 个人拍好位置，使得权值最大。</p>
<p>$ 3\le n&lt;99999 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们看到中位数，就能很明显想到二分。</p>
<p>所以我们二分，现在问题变成了：每个人能力值为 $ 0 $ 或 $ 1 $ ，能否使最后的权值是 $ 1 $ 。</p>
<p>这个问题似乎不太好做，我们来模拟一下，假如当前队列中人的编号为 $ 1\sim 9 $ ，我们来模拟这个过程。</p>
<p>初始时，队列为：$ [1,2,3,4,5,6,7,8,9] $ 。</p>
<p>首先拿出前三个人，并将中位数插入队尾。我们并不知道哪个人是中位数。</p>
<p>所以我们可以稍微转化一下操作，把他变成这个样子：</p>
<p>把队列的前三个人一起拿走，并且加入一个新人，能力值为前三个人的中位数。</p>
<p>所以我们现在假设加入的人是 $ 10 $ 号。</p>
<p>队列为： $ [4,5,6,7,8,9,10] $ 。</p>
<p>依次执行这个过程，得到：</p>
<p>$ [7,8,9,10,11] $ </p>
<p>$ [10,11,12] $ </p>
<p>$ [13] $ </p>
<p>所以我们的问题就是 $ 13 $ 号人能力是否能为 $ 1 $ 。</p>
<p>通过这个模拟的过程，我们完全可以知道每一个人的能力值是由哪三个人决定的，我们把图画出来。</p>
<p><img src="/pic/JOI2015_1.jpg" alt=""></p>
<p>我们发现，这种关系一定会是一个树状的结构。</p>
<p>同时，我们考虑到权值只有 $ 0 $ 和 $ 1 $ ，发现实际就是在问，能否合理地分配 $ 1 $ 的位置，使得根的权值为 $ 1 $ 。</p>
<p>那么我们考虑对其进行树形dp。</p>
<p>设 $ dp_i $ 表示，如果要让 $ i $ 的权值为 $ 1 $ ，至少需要在子树内额外放置多少个 $ 1 $ 。</p>
<p>当 $ i $ 为叶节点，且上面已经有一个 $ 1 $ 时，不需要多余填，这里的值就是 $ 1 $ ，所以 $ dp_i=0 $ ；</p>
<p>当 $ i $ 为叶节点，且上面已经有一个 $ 0 $ 时，这个位置不可能是 $ 1 $ ，那么 $ dp_i=+\infty $ ；</p>
<p>当 $ i $ 为叶节点，且上面时还没有填数字时，$ dp_i=1 $ ；</p>
<p>否则假设 $ i $ 的三个儿子为 $ a,b,c $ ，那么 $ dp_i=\min(dp_a+dp_b,dp_a+dp_c,dp_b+dp_c)=dp_a+dp_b+dp_c-\max(dp_a,dp_b,dp_c) $ 。</p>
<p>假如我们有 $ x $ 个 $ 1 $ 暂未放置，那么在 $ dp_r\le x $ 时有解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>实际上在写的时候，不需要建树。</p>
<p>直接使用队列进行模拟即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> c0,c1;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c0=c1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=num) c1++;</span><br><span class="line">        <span class="keyword">else</span> c0++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">-1</span>) dp[cnt]=<span class="number">1</span>,que.<span class="built_in">push</span>(cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;=num) dp[cnt]=<span class="number">0</span>,que.<span class="built_in">push</span>(cnt);</span><br><span class="line">        <span class="keyword">else</span> dp[cnt]=<span class="number">0x3f3f3f3f</span>,que.<span class="built_in">push</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a1=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a2=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a3=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++,dp[cnt]=dp[a1]+dp[a2]+dp[a3]-<span class="built_in">max</span>(dp[a1],<span class="built_in">max</span>(dp[a2],dp[a3]));</span><br><span class="line">        que.<span class="built_in">push</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[que.<span class="built_in">front</span>()]&lt;=c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">-1</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        a[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m;i++) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;i;i&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(<span class="built_in">cal</span>(ans+i)) ans+=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>JOI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2018] 你的名字</title>
    <url>/NOI2018%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<p><del>苍天啊，大地啊，模拟赛里怎么全是毒瘤题啊！</del></p>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4770">luoguP4770</a>。</p>
<p>这道题让我们求的是 $ t $ 所有本质不同子串中不为 $ S[l,r] $ 的子串的个数。</p>
<span id="more"></span>
<p>首先我们可以利用 SAM 非常简单的求出 $ t $ 的本质不同子串个数。</p>
<p>什么？你不知道怎么求，建议先做<a href="https://www.luogu.com.cn/problem/P3804">luoguP3804 【模板】后缀自动机 (SAM)</a></p>
<p>下面我们只需要对每一个询问求出包含在 $ S[l,r] $ 中的 $ t $ 的所有本质不同子串个数就可以了。</p>
<h4 id="68分做法"><a href="#68分做法" class="headerlink" title="68分做法"></a>68分做法</h4><p>我们可以看到，整道题前面 $ 68 $ 分都有 $ l=1,r=|S| $ ，我们不妨先来思考这些测试点怎么做。</p>
<p>如果我们想要知道 $ t $ 的哪些子串同时也是 $ S $ 的子串，最好的方法肯定就是对 $ |S| $ 建立一个 SAM，然后用 $ t $ 在上面匹配。</p>
<p>因为SAM的fail的含义于AC自动机的差不多，指向的都是该节点代表字符串的后缀。</p>
<p>并且SAM中包含一个字符串的所有子串，就相当于是把一个字符串的所有子串抽出来建了一个AC自动机。</p>
<p>所以实际上是可以进行匹配的（可能还挺常用？）。</p>
<p>这样子我们就可以知道对于 $ t $ 的每一个前缀 $ t[1,i] $ ，它的最长后缀的长度使得这个后缀是 $ S $ 的子串。</p>
<p>但是这样找出的子串并不能保证本质不同。</p>
<p>那么我们把这个过程搬到 SAM 上面。</p>
<p>我们再对 $ t $ 建一个 SAM，并且对于每一个点 $ i $ 再新维护一个信息 $ val_i $ ，表示第 $ i $ 个点表示的所有字符串中，长度小于等于 $ val_i $ 的都是 $ S $ 的子串。</p>
<p>我们只需要把 $ t $ 在 $ S $ 的 SAM 上面跑一遍，然后顺着 parent 边更新答案就可以了（拓扑排序或者dfs都行）。</p>
<p>其实上面找 $ val_i $ 的过程事实上就是<a href="https://www.luogu.com.cn/problem/SP1811">这道题</a>，可以做一下加深理解。</p>
<p>然后我们就可以拿到 $ 68 $ 分了！</p>
<h4 id="满分做法"><a href="#满分做法" class="headerlink" title="满分做法"></a>满分做法</h4><p>我们发现，上面的做法不能AC主要原因在于每一次询问的是 $ S $ 的一个子串，我们使用 $ t $ 进行匹配的时候很有可能“越界”，而我们又不能快速得到 $ S $ 的某个子串的SAM。</p>
<p>我们无法快速得到一个子串的SAM，那我们能否快速查询某一个节点代表的某个子串是否在 $ [l,r] $ 范围内呢？</p>
<p>我们知道，SAM上某一个节点代表字符串的位置实际上是和它的 endpos 有关的，那么我们能不能快速得到某个节点的 endpos 集合呢？</p>
<p>答案是可以的，我们需要在SAM的parent上面跑线段树合并。</p>
<p>所以我们只需要在沿边转移的时候加上一个endpos的条件即可。</p>
<p>停停，线段树合并不是离线的吗？</p>
<p>所以我们需要进行可持久化线段树合并。</p>
<p>和普通线段树合并不同的一点是，我们每次合并两个节点时新建一个节点，这样就不会破坏原来的节点，并且在所有查询之前进行合并，这样时间复杂度不会变，算法也变成了在线。</p>
<p>然后快乐提交，拿到 $ 97 $ 分，挂了一个点。</p>
<p><a href="https://www.luogu.com.cn/paste/7n9acgi8">代码</a></p>
<p><a href="https://www.luogu.com.cn/record/77774847">提交记录</a></p>
<p>哪里挂了呢？</p>
<p>你会发现假如某一个节点因为endpos而不能转移时，你直接跳了fail，但是有可能在匹配长度减小一些以后它又可以转移了。</p>
<p>稍微转移一下就可以过。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root[<span class="number">1000001</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;g[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> ls[<span class="number">30000001</span>];</span><br><span class="line"><span class="type">int</span> rs[<span class="number">30000001</span>];</span><br><span class="line"><span class="type">int</span> son[<span class="number">2000001</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> fail[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> len[<span class="number">2000001</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;t[<span class="number">100001</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;w[<span class="number">100001</span>];</span><br><span class="line"><span class="type">char</span> in[<span class="number">1000002</span>];</span><br><span class="line"><span class="type">int</span> mo[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> ma[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">500002</span>];</span><br><span class="line">ll ans[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> lst=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fail[i]=len[i]=ma[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) son[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=lst=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=++cnt,p=lst;lst=cur,len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!son[p][a];p=fail[p]) son[p][a]=cur;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123; fail[cur]=<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="type">int</span> q=son[p][a];</span><br><span class="line">    <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)&#123; fail[cur]=q;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="type">int</span> nq=++cnt;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">    fail[nq]=fail[q],fail[q]=fail[cur]=nq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) son[nq][i]=son[q][i];</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;son[p][a]==q;p=fail[p]) son[p][a]=nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d : len=%d fail=%d &quot;,i,len[i],fail[i]);</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;26;j++) if(son[i][j]) printf(&quot;(%c,%d) &quot;,j+&#x27;a&#x27;,son[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++tot;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ls[p],pl,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(rs[p],mid+<span class="number">1</span>,pr,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> pl,<span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> u|v;</span><br><span class="line">    <span class="type">int</span> ans=++tot;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls[ans]=<span class="built_in">merge</span>(ls[u],ls[v],pl,mid);</span><br><span class="line">    rs[ans]=<span class="built_in">merge</span>(rs[u],rs[v],mid+<span class="number">1</span>,pr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p:g[num]) <span class="built_in">dfs</span>(p),root[num]=<span class="built_in">merge</span>(root[num],root[p],<span class="number">1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++) mo[fail[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!mo[i]) que.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        ma[fail[p]]=<span class="built_in">max</span>(ma[fail[p]],ma[p]),mo[fail[p]]--;</span><br><span class="line">        <span class="keyword">if</span>(!mo[fail[p]]) que.<span class="built_in">push</span>(fail[p]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;get %d %d %d %d %d\n&quot;,p,pl,pr,l,r);</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid&amp;&amp;<span class="built_in">get</span>(ls[p],pl,mid,l,r)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r&amp;&amp;<span class="built_in">get</span>(rs[p],mid+<span class="number">1</span>,pr,l,r)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;name.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;name.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),n=<span class="built_in">read</span>(),m=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;s[i];i++) <span class="built_in">add</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,now=<span class="number">1</span>;s[i];i++) now=son[now][s[i]-<span class="string">&#x27;a&#x27;</span>],<span class="built_in">add</span>(root[now],<span class="number">1</span>,m,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++) g[fail[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>),<span class="built_in">debug</span>();</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,root[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in+<span class="number">1</span>);<span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),now=<span class="number">1</span>,le=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;in[j];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].<span class="built_in">push_back</span>(in[j]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(son[now][in[j]-<span class="string">&#x27;a&#x27;</span>]&amp;&amp;le&lt;=r-l&amp;&amp;<span class="built_in">get</span>(root[son[now][in[j]-<span class="string">&#x27;a&#x27;</span>]],<span class="number">1</span>,m,l+le,r))</span><br><span class="line">                &#123;</span><br><span class="line">                    now=son[now][in[j]-<span class="string">&#x27;a&#x27;</span>],le++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!le) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;le : %d -&gt; %d\n&quot;,le,le-1);</span></span><br><span class="line">                le--;</span><br><span class="line">                <span class="keyword">if</span>(len[fail[now]]==le) now=fail[now];</span><br><span class="line">            &#125;</span><br><span class="line">            w[i].<span class="built_in">push_back</span>(le);</span><br><span class="line">            <span class="comment">// printf(&quot;j=%d : now=%d le=%d\n&quot;,j,now,le);</span></span><br><span class="line">            <span class="comment">// printf(&quot;%d &quot;,le);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;t[i].<span class="built_in">size</span>();j++) <span class="built_in">add</span>(t[i][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,now=<span class="number">1</span>;j&lt;(<span class="type">int</span>)t[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            now=son[now][t[i][j]];</span><br><span class="line">            ma[now]=<span class="built_in">max</span>(ma[now],w[i][j]);</span><br><span class="line">            <span class="comment">// printf(&quot;%d : %d\n&quot;,now,w[i][j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topo</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=cnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i]-=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(len[j],ma[j])-len[fail[j]]);</span><br><span class="line">            ans[i]+=len[j]-len[fail[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>[MtOI2019] 幽灵乐团/莫比乌斯反演基础练习题</title>
    <url>/MtOI2019%E5%B9%BD%E7%81%B5%E4%B9%90%E5%9B%A2/</url>
    <content><![CDATA[<p>一道毒瘤题目，题目链接：<a href="https://www.luogu.com.cn/problem/P5518">luoguP5518</a>。</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目大意：求 $ \prod\limits_{i=1} ^A\prod\limits_{j=1} ^B\prod\limits_{k=1} ^C\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right) ^{f(type)} $ 。</p>
<p>其中 $ type\in $  $\{0,1,2\}$ ， $ f(0)=1,f(1)=ijk,f(2)=\gcd(i,j,k) $ 。</p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>让我们先来颓一下柿子。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}\\
=&\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\dfrac{ij}{\gcd(i,j)\gcd(i,k)}\right)^{f(type)}\\
=&\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\dfrac{i^{f(type)}j^{f(type)}}{\gcd(i,j)^{f(type)}\gcd(i,k)^{f(type)}}\\
=&\dfrac{\left(\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{f(type)}\right)\times\left(\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Cj^{f(type)}\right)}{\left(\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)^{f(type)}\right)\times\left(\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,k)^{f(type)}\right)}
\end{aligned}</script><p>实际上只需要知道 $ \prod\limits_{i=1}^ A\prod\limits_{j=1}^ B\prod\limits_{k=1}^ Ci^{f(type)} $ 和 $ \prod\limits_{i=1}^ A\prod\limits_{j=1}^ B\prod\limits_{k=1}^ C\gcd(i,j)^{f(type)} $ 的求法就可以了。</p>
<p>所以我们一共要推 $ 6 $ 个式子。</p>
<h4 id="type-0"><a href="#type-0" class="headerlink" title="type=0"></a>type=0</h4><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci\\
=&\prod\limits_{i=1}^Ai^{BC}&直接看 i 被乘了多少次\\
=&(A!)^{BC}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)\\
=&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\gcd(i,j)^C\\
=&\prod\limits_{p\in prime,m\ge0}\prod\limits_{i=1}^A\prod\limits_{j=1}^Bp^{C[p^m|\gcd(i,j)]}&枚举质数找\gcd,注意有的\gcd有多个相同质数\\
=&\prod\limits_{p\in prime,m\ge0}p^{\left\lfloor\frac{A}{p^m}\right\rfloor\left\lfloor\frac{B}{p^m}\right\rfloor C}
\end{aligned}</script><p>第一个式子直接预处理阶乘，然后算 $ BC $ 次方。</p>
<p>第二个式子可以通过预处理筛出 $ p^m $ ，然后快速幂。</p>
<p>如果想要更快可以筛出所有 $ p^m $ 的前缀积，然后数论分块。</p>
<h4 id="type-1"><a href="#type-1" class="headerlink" title="type=1"></a>type=1</h4><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{ijk}\\
=&\prod\limits_{i=1}^Ai^{i\sum\limits_{j=1}^B\kern{4pt}\sum\limits_{k=1}^C\kern{2pt}jk}\\
=&\prod\limits_{i=1}^Ai^{i(\sum\limits_{j=1}^Bj)(\sum\limits_{k=1}^Ck)}\\
=&\prod\limits_{i=1}^Ai^{if(B)f(C)}&f(n)=\dfrac{n(n+1)}{2}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)^{ijk}\\
=&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\gcd(i,j)^{ij\sum\limits_{k=1}^Ck}\\
=&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\gcd(i,j)^{ijf(C)}\\
=&\prod_{p\in prime,m\ge0}\prod\limits_{i=1}^A\prod\limits_{j=1}^Bp^{[p^m|\gcd(i,j)]ijf(C)}&和上面一样的方法\\
=&\prod_{p\in prime,m\ge0}p^{p^{2m}\kern{3pt}f\left(\left\lfloor\frac{A}{p^m}\right\rfloor\right)f\left(\left\lfloor\frac{B}{p^m}\right\rfloor\right) f(C)}
\end{aligned}</script><p>第二个式子计算方式和type=0差不多，第一个式子只需要预处理 $ i^i $ 的前缀积即可。</p>
<h4 id="type-2"><a href="#type-2" class="headerlink" title="type=2"></a>type=2</h4><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{\gcd(i,j,k)}\\
=&\prod\limits_{d=1}^D\prod\limits_{i=1}^Ai^{\sum\limits_{j=1}^B\sum\limits_{k=1}^Cd[\gcd(i,j,k=d)]}&令D=\min(A,B,C),然后枚举\gcd\\
=&\prod\limits_{d=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}i^{\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{C}{d}\right\rfloor}d[\gcd(i,j,k=1)]}\\
=&\prod\limits_{d=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}(id)^{\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{C}{d}\right\rfloor}d\sum\limits_{t|\gcd(i,j,k)}\mu(t)}&莫比乌斯反演\\
=&\prod\limits_{d=1}^D\prod\limits_{t=1}^{\left\lfloor\frac{D}{d}\right\rfloor}\prod\limits_{i=1}^{\left\lfloor\frac{A}{dt}\right\rfloor}(idt)^{d\mu(t)\left\lfloor\frac{B}{dt}\right\rfloor\left\lfloor\frac{C}{dt}\right\rfloor}&将t提前\\
=&\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T
}\right\rfloor}(iT)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor\sum\limits_{d|T}d\mu\left(\frac{T}{d}\right)}&枚举T=dt\\
=&\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T
}\right\rfloor}(iT)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor\varphi(T)}&id*\mu=\varphi\\
=&\left(\prod\limits_{T=1}^D\left(\left\lfloor\frac{A}{T}\right\rfloor!\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor\varphi(T)}\right)\times\left(\prod\limits_{T=1}^DT^{\varphi(T)\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}\right)
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)^{\gcd(i,j,k)}\\
=&\prod\limits_{d=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}(\gcd(i,j)d)^{d\sum\limits_{k=1}^C[\gcd(i,j,k)=1]}&枚举\gcd(i,j,k)\\
=&\prod\limits_{d=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}(\gcd(i,j)d)^{d\sum\limits_{k=1}^C\sum\limits_{t|\gcd(i,j,k)}\mu(t)}\\
=&\prod\limits_{d=1}^D\prod\limits_{t=1}^{\left\lfloor\frac{D}{d}\right\rfloor}\prod\limits_{i=1}^{\left\lfloor\frac{A}{td}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{td}\right\rfloor}(\gcd(i,j)td)^{d\mu(t)\left\lfloor\frac{C}{td}\right\rfloor}\\
=&\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{T}\right\rfloor}(\gcd(i,j)T)^{\left\lfloor\frac{C}{T}\right\rfloor\sum\limits_{d|T}d\mu\left(\frac{T}{d}\right)}\\
=&\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{T}\right\rfloor}(\gcd(i,j)T)^{\left\lfloor\frac{C}{T}\right\rfloor\varphi(T)}&id*\mu=\varphi\\
=&\left(\prod\limits_{T=1}^DT^{\varphi(T)\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}\right)\times\left(\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{T}\right\rfloor}\gcd(i,j)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}\right)
\end{aligned}</script><p>然后你就会发现分子的右边的式子和分母的左边的式子约掉了。</p>
<p>于是我们现在只需要求 $ \prod\limits_{T=1}^ D\left(\left\lfloor\frac{A}{T}\right\rfloor!\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor\varphi(T)} $ 和 $ \prod\limits_{T=1}^ D\prod\limits_{i=1}^ {\left\lfloor\frac{A}{T}\right\rfloor}\prod\limits_{j=1}^ {\left\lfloor\frac{B}{T}\right\rfloor}\gcd(i,j)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor} $ 。</p>
<p>第一个式子只需要预处理阶乘、 $ \varphi $ 的前缀和，然后就可以分块。</p>
<p>第二个式子还需要推一推。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod\limits_{T=1}^D\prod\limits_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{B}{T}\right\rfloor}\gcd(i,j)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}\\
=&\prod\limits_{T=1}^D\left(\prod\limits_{d=1}^{\left\lfloor\frac{E}{T}\right\rfloor}d^{\sum\limits_{i=1}^{\left\lfloor\frac{A}{Td}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{Td}\right\rfloor}\sum\limits_{t|\gcd(i,j)}\mu(t)}\right)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}&E=\min(A,B),枚举\gcd\\
=&\prod\limits_{T=1}^D\left(\prod\limits_{d=1}^{\left\lfloor\frac{E}{T}\right\rfloor}\prod\limits_{t=1}^{\left\lfloor\frac{E}{Td}\right\rfloor}d^{\mu(t)\left\lfloor\frac{A}{Ttd}\right\rfloor\left\lfloor\frac{B}{Ttd}\right\rfloor}\right)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}\\
&\prod\limits_{T=1}^D\left(\prod\limits_{T'=1}^{\left\lfloor\frac{E}{T}\right\rfloor}\left(\prod\limits_{d|T'}d^{\mu\left(\frac{T'}{d}\right)}\right)^{\left\lfloor\frac{A}{TT'}\right\rfloor\left\lfloor\frac{B}{TT'}\right\rfloor}\right)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}
\end{aligned}</script><p>然后你会发现 $ \prod\limits_{T’=1}^ n\left(\prod\limits_{d|T’}d^{\mu\left(\frac{T’}{d}\right)}\right) $ 是可以预处理的。</p>
<p>于是乎，两遍整除分块就可以了。</p>
<p>最终时间复杂度是 $ O(n\log n+Tn^{\frac{3}{4}}\log n) $ 的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b=(b%(mod<span class="number">-1</span>)+mod<span class="number">-1</span>)%(mod<span class="number">-1</span>);</span><br><span class="line">    a%=mod;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;jyh[<span class="number">100001</span>];</span><br><span class="line">ll prephi[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> pri[<span class="number">100001</span>];</span><br><span class="line"><span class="type">bool</span> is[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> phi[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> pm[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> mu[<span class="number">100001</span>];</span><br><span class="line">ll jc1[<span class="number">100001</span>];</span><br><span class="line">ll jc2[<span class="number">100001</span>];</span><br><span class="line">ll d1[<span class="number">100001</span>];</span><br><span class="line">ll d2[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> A,B,C;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*i*(i+<span class="number">1</span>)/<span class="number">2</span>%(mod<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get2</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=jyh[A][B];</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="keyword">return</span> ans;</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> E=<span class="built_in">min</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> lTp=<span class="number">1</span>,rTp;lTp&lt;=E;lTp=rTp+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rTp=<span class="built_in">min</span>(A/(A/lTp),B/(B/lTp));</span><br><span class="line">        ll val=d1[rTp]*d2[lTp<span class="number">-1</span>]%mod;</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(val,(ll)(A/lTp)*(B/rTp)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jyh[A][B]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get1</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> D=<span class="built_in">min</span>(<span class="built_in">min</span>(A,B),C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> lT=<span class="number">1</span>,rT;lT&lt;=D;lT=rT+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rT=<span class="built_in">min</span>(<span class="built_in">min</span>(A/(A/lT),B/(B/lT)),C/(C/lT));</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(<span class="built_in">get2</span>(A/lT,B/lT),(prephi[rT]-prephi[lT<span class="number">-1</span>])%(mod<span class="number">-1</span>)*(C/lT)%(mod<span class="number">-1</span>))%mod</span><br><span class="line">               *<span class="built_in">qow</span>(<span class="built_in">get2</span>(A/lT,C/lT),(prephi[rT]-prephi[lT<span class="number">-1</span>])%(mod<span class="number">-1</span>)*(B/lT)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get3</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> lT=<span class="number">1</span>,rT;lT&lt;=A&amp;&amp;lT&lt;=B&amp;&amp;lT&lt;=C;lT=rT+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rT=<span class="built_in">min</span>(<span class="built_in">min</span>(A/(A/lT),B/(B/lT)),C/(C/lT));</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(jc1[A/lT],(prephi[rT]-prephi[lT<span class="number">-1</span>])%(mod<span class="number">-1</span>)*(B/lT)*(C/lT)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">read</span>(),n=<span class="number">100000</span>;mod=<span class="built_in">read</span>();</span><br><span class="line">    mu[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) pri[++pri[<span class="number">0</span>]]=i,mu[i]=<span class="number">-1</span>,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">            phi[i*pri[j]]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=pri[<span class="number">0</span>];i++) <span class="keyword">for</span>(ll j=pri[i];j&lt;=n;j*=pri[i]) pm[j]=pri[i];</span><br><span class="line">    jc1[<span class="number">0</span>]=jc2[<span class="number">0</span>]=d1[<span class="number">0</span>]=d2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d1[i]=<span class="number">1</span>;</span><br><span class="line">        prephi[i]=prephi[i<span class="number">-1</span>]+phi[i];</span><br><span class="line">        jc1[i]=jc1[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        jc2[i]=jc2[i<span class="number">-1</span>]*<span class="built_in">qow</span>(i,i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">        d1[j]=d1[j]*<span class="built_in">qow</span>(i,mu[j/i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) d1[i]=(d1[i]*d1[i<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d2[i]=<span class="built_in">qow</span>(d1[i],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        A=<span class="built_in">read</span>(),B=<span class="built_in">read</span>(),C=<span class="built_in">read</span>();</span><br><span class="line">        ll ans=<span class="number">1</span>,val=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(jc1[A],<span class="number">1ll</span>*B*C%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(jc1[B],<span class="number">1ll</span>*A*C%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A&amp;&amp;i&lt;=B;i++) <span class="keyword">if</span>(pm[i])</span><br><span class="line">            val=val*<span class="built_in">qow</span>(pm[i],<span class="number">1ll</span>*(A/i)*(B/i)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        val=<span class="built_in">qow</span>(val,C);</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(val,mod<span class="number">-2</span>)%mod,val=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A&amp;&amp;i&lt;=C;i++) <span class="keyword">if</span>(pm[i])</span><br><span class="line">            val=val*<span class="built_in">qow</span>(pm[i],<span class="number">1ll</span>*(A/i)*(C/i)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        val=<span class="built_in">qow</span>(val,B);</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(val,mod<span class="number">-2</span>)%mod,val=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans),ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(jc2[A],<span class="built_in">f</span>(B)*<span class="built_in">f</span>(C)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(jc2[B],<span class="built_in">f</span>(A)*<span class="built_in">f</span>(C)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A&amp;&amp;i&lt;=B;i++) <span class="keyword">if</span>(pm[i])</span><br><span class="line">            val=val*<span class="built_in">qow</span>(pm[i],<span class="built_in">f</span>(A/i)*<span class="built_in">f</span>(B/i)%(mod<span class="number">-1</span>)*i%(mod<span class="number">-1</span>)*i%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        val=<span class="built_in">qow</span>(val,<span class="built_in">f</span>(C));</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(val,mod<span class="number">-2</span>)%mod,val=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A&amp;&amp;i&lt;=C;i++) <span class="keyword">if</span>(pm[i])</span><br><span class="line">            val=val*<span class="built_in">qow</span>(pm[i],<span class="built_in">f</span>(A/i)*<span class="built_in">f</span>(C/i)%(mod<span class="number">-1</span>)*i%(mod<span class="number">-1</span>)*i%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        val=<span class="built_in">qow</span>(val,<span class="built_in">f</span>(B));</span><br><span class="line">        ans=ans*<span class="built_in">qow</span>(val,mod<span class="number">-2</span>)%mod,val=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans),ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ans=<span class="built_in">qow</span>(<span class="built_in">get1</span>(A,B,C),mod<span class="number">-2</span>);</span><br><span class="line">        ans=ans*<span class="built_in">get3</span>(A,B,C)%mod*<span class="built_in">get3</span>(B,A,C)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数论分块</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2022] 众数</title>
    <url>/NOI2022%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<p>vp NOI的时候做的，场上想了一会，打了一会，就切了。</p>
<p>然后挂了 $ 25 $ 分。</p>
<p><a href="https://www.luogu.com.cn/problem/P8496">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个序列的众数是序列中出现次数严格大于一半的数字，没有这样的数字则为 $ -1 $ 。</p>
<p>现在有很多个队列，其中编号为 $ 1\sim n $ 的队列初始是”存在的”，剩余的队列初始是”不存在”的。</p>
<p>初始时这些队列中的元素已知，元素总数为 $ C_l=\sum l_i $ 。现在还有 $ q $ 个操作，操作有一下几种：</p>
<ol>
<li>在队列 $ x $ 末尾插入一个 $ y $ ，保证 $ x $ 号队列此时”存在”，$ 1\le x,y\le n+q $ 。</li>
<li>删除队列 $ x $ 末尾的数字，保证 $ x $ 号队列此时”存在”且非空，$ 1\le x\le n+q $ 。</li>
<li>给出 $ m $ 个队列编号 $ x_1,x_2,\dots,x_m $ ，求出这些队列拼接起来后元素的众数，不保证 $ x $ 互不相同。</li>
<li>新建一个编号为 $ x_3 $ 的队列，由 $ x_1 $ 和 $ x_2 $ 首尾拼接构成，并将 $ x_3 $ 设为存在，$ x_1,x_2 $ 设为不存在。保证 $ x_1,x_2 $ 初始存在，$ x_3 $ 不存在。</li>
</ol>
<p>设 $ C_m=\sum m $ 为操作 $ 3 $ 中 $ m $ 的和。</p>
<p>$ n,q,C_m,C_l\le 5\times 10^5 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们来考虑如何维护这些队列。</p>
<p>首先deque启发式合并不行，会MLE（宝贵经验。</p>
<p>我们发现，所有有关队列的操作，都只和队列的首尾有关。</p>
<p>那么我们可以直接使用双向链表存下这些队列。</p>
<p>操作 $ 1 $ 和操作 $ 2 $ 直接更改结尾，操作 $ 4 $ 直接把两个链表首尾拼起来。</p>
<p>接下来就只剩操作 $ 3 $ 。</p>
<p>首先我们可以很容易地知道最后队列的长度，只需要把这 $ m $ 个链表的元素数量加一起就好了。</p>
<p>假设总长度为 $ len $ ，那么我们其实就是要找到出现次数 $ \ge\left\lfloor\dfrac{len}{2}\right\rfloor+1  $ 的数字。</p>
<p>维护一个链表中每一个数字的出现次数很简单，只需要一个map或set就够了。</p>
<p>但是我们需要合并信息，map和set显然不可以。</p>
<p>我们可以比较容易想到，使用动态开点线段树维护每一个数字的出现次数，操作 $ 4 $ 只需要线段树合并就可以了。</p>
<p>对于操作 $ 3 $ ，我们直接用一个数组存储来所有线段树的根，然后查询的过程中一起往下跳，每一次跳到数字总数更多的一遍，最后特判就好了。</p>
<p>链表合并不要写挂！</p>
<p>链表合并不要写挂！！</p>
<p>链表合并不要写挂！！！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ls[<span class="number">22000001</span>];</span><br><span class="line"><span class="type">int</span> rs[<span class="number">22000001</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">22000001</span>];</span><br><span class="line"><span class="type">int</span> root[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> tail[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nx[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> lt[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">ll siz;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[p]);</span><br><span class="line">    <span class="built_in">debug</span>(nx[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++tot;</span><br><span class="line">    c[p]+=y;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ls[p],pl,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(rs[p],mid+<span class="number">1</span>,pr,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> pl,<span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> u|v;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr)</span><br><span class="line">    &#123;</span><br><span class="line">        c[u]+=c[v];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls[u]=<span class="built_in">merge</span>(ls[u],ls[v],pl,mid);</span><br><span class="line">    rs[u]=<span class="built_in">merge</span>(rs[u],rs[v],mid+<span class="number">1</span>,pr);</span><br><span class="line">    c[u]=c[ls[u]]+c[rs[u]];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) num+=c[p[i]];</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=siz) <span class="keyword">return</span> pl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;ll num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) num+=c[ls[p[i]]];</span><br><span class="line">    <span class="keyword">if</span>(num&gt;=siz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) p[i]=ls[p[i]];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(pl,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) p[i]=rs[p[i]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(mid+<span class="number">1</span>,pr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),cnt=n+m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lst=i;k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[++cnt]=<span class="built_in">read</span>();</span><br><span class="line">            nx[lst]=cnt,lt[cnt]=lst;</span><br><span class="line">            <span class="built_in">add</span>(root[i],<span class="number">0</span>,n+m,v[cnt],<span class="number">1</span>);</span><br><span class="line">            lst=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        tail[i]=lst;</span><br><span class="line">        <span class="comment">// debug(nx[i]);</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>(),p=tail[x];</span><br><span class="line">            v[++cnt]=<span class="built_in">read</span>();</span><br><span class="line">            nx[p]=cnt,lt[cnt]=p;</span><br><span class="line">            tail[x]=cnt;</span><br><span class="line">            <span class="built_in">add</span>(root[x],<span class="number">0</span>,n+m,v[cnt],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(root[x],<span class="number">0</span>,n+m,v[tail[x]],<span class="number">-1</span>);</span><br><span class="line">            tail[x]=lt[tail[x]];</span><br><span class="line">            nx[tail[x]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k=<span class="built_in">read</span>(),siz=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u=<span class="built_in">read</span>();</span><br><span class="line">                p[j]=root[u];</span><br><span class="line">                siz+=c[root[u]];</span><br><span class="line">                <span class="keyword">if</span>(nx[u]) <span class="built_in">assert</span>(lt[nx[u]]==u);</span><br><span class="line">            &#125;</span><br><span class="line">            siz=siz/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="number">0</span>,n+m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1=<span class="built_in">read</span>(),x2=<span class="built_in">read</span>(),x3=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(!nx[x1]&amp;&amp;!nx[x2]) tail[x3]=x3;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!nx[x1]) nx[x3]=nx[x2],tail[x3]=tail[x2],lt[nx[x3]]=x3;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!nx[x2]) nx[x3]=nx[x1],tail[x3]=tail[x1],lt[nx[x3]]=x3;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nx[x3]=nx[x1],tail[x3]=tail[x2];</span><br><span class="line">                nx[tail[x1]]=nx[x2];</span><br><span class="line">                lt[nx[x2]]=tail[x1];</span><br><span class="line">                lt[nx[x3]]=x3;</span><br><span class="line">            &#125;</span><br><span class="line">            root[x3]=<span class="built_in">merge</span>(root[x1],root[x2],<span class="number">0</span>,n+m);</span><br><span class="line">            <span class="comment">// debug(nx[x3]);</span></span><br><span class="line">            <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2021] 密码箱</title>
    <url>/NOI2021%E5%AF%86%E7%A0%81%E7%AE%B1/</url>
    <content><![CDATA[<p>老师留的几道题里第一个做了的，写篇题解纪念一下。</p>
<p>这道题主要想要写一下我做题的思路。</p>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P7739">luoguP7739</a> 。</p>
<span id="more"></span>
<p>首先我们可以注意到这道题不同寻常的地方：别的题目都是让我们维护序列，但是这道题却让我们维护操作序列。</p>
<p>似乎非常麻烦啊。</p>
<p>但是什么东西可以维护呢？矩阵！</p>
<p>再看一下题目中的操作：翻转、反转。</p>
<p>一眼就可以看出正解是平衡树维护矩阵。</p>
<p>这些思路大概是我读完题之后就知道的，比较明显。</p>
<p>知道了算法，其实我们只需要推出这些矩阵就可以了，这才是这道题的重点。</p>
<p>我们现在再来想一个问题：假如我们现在通过矩阵，维护了某一个序列的答案。</p>
<p>我们现在给这个序列后面添加一个数字，我们可以算出答案吗？</p>
<p>似乎不行，或者说起码没有特别简单的方法。</p>
<p>但是如果这个数字添加在了整个序列的前面，我们却很好维护。</p>
<p>假如说 $ f(a_0,a_1,\dots,a_k) $ 的答案为 $ \dfrac{x}{y} $ ，这个时候序列变成 $ (c,a_0,a_1,\dots,a_k) $ ，答案显然会变成 $ c+\dfrac{y}{x}=\dfrac{cx+y}{x} $ 。</p>
<p>那也就是：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 x&y 
\end{bmatrix}
\times 
\begin{bmatrix}
 c&1 \\
 1&0
\end{bmatrix}
=
\begin{bmatrix}
 cx+y&x
\end{bmatrix}</script><p>所以我们得到了一些启发：序列倒着会比较好维护。</p>
<p>其实正着可能也差不多，但是我还是觉得倒着比较方便。</p>
<p>然后我们再来看题目中给的操作。</p>
<p>首先我们来看 W 操作。</p>
<p>将序列中最后一个值加一，因为我们倒着维护序列，所以就是整个序列第一个位置加一。</p>
<p>假设说这个地方原来的值是 $ c $ ，那么这个地方对应的矩阵就是 $ \begin{bmatrix} c&amp;1 \ 1&amp;0\end{bmatrix} $ 。</p>
<p>我们现在要将这个地方的矩阵要变成 $ \begin{bmatrix} c+1&amp;1 \ 1&amp;0\end{bmatrix} $ 。</p>
<p>因为对于任何 $ c $ ，这个变换都要成立，所以稍微手推一下，就可以发现：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&1 \\ 0&1\end{bmatrix}
\times 
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
=
\begin{bmatrix} c+1&1 \\ 1&0\end{bmatrix}</script><p>接下来我们来推 E，你会发现似乎有点麻烦。不慌，我们直接推。</p>
<p>对于第一个数字不是 $ 1 $ 的情况，就是先把这个数字减一，然后在序列前面添上两个 $ 1 $ 。</p>
<p>所以我们先推一下如何给一个数字减一，感觉和上面差不多。</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}
\times 
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
=
\begin{bmatrix} c-1&1 \\ 1&0\end{bmatrix}</script><p>那么这个矩阵推出来就是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}\\
=&\begin{bmatrix} 2&1 \\ 1&1\end{bmatrix}
\times
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}\\
=&\begin{bmatrix} 2&-1 \\ 1&0\end{bmatrix}
\end{aligned}</script><p> 然后再来推一下第一个数字是 $ 1 $ 的情况。不妨写一下原来的矩阵和变化后的矩阵。</p>
<p>假设原来第二个数是 $ c $ （第一个数是 $ 1 $ ）。</p>
<p>那么开头的两个矩阵长这个样子：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}</script><p>我们将第二个数字加上一：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 0&1\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}</script><p>前两项都是常数项，我们把它们乘起来。</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1&2 \\ 1&1\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}</script><p>我们肯定尽量想将他表示成对第一个数字的操作，所以我们把第一项拆开：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} ?&? \\ ?&?\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}</script><p>可以带进去的数字有点多，不好算。</p>
<p>就这么卡住了嘛？</p>
<p>看看上面？</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 2&-1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}</script><p>没错，E 操作直接用这一个矩阵就可以解决。</p>
<p>矩阵就这样推完了。</p>
<p>我们再来看题目中的这些操作。</p>
<p>操作一，直接在所有矩阵前添加一个数字。</p>
<p>操作三，直接整个区间翻转。</p>
<p>操作二，看起来不好搞，实际上和操作三一样，直接暴力维护没有转和转了之后这个区间长什么样子就行。</p>
<p>$ 4 $ 倍常数，建议实现的时候尽量常数写小一点。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">mt19937 _rand(<span class="built_in">time</span>(<span class="number">0</span>)^<span class="built_in">clock</span>());</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> n,<span class="type">const</span> <span class="type">int</span> m&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span></span><br><span class="line">&#123;</span><br><span class="line">    ll a[n][m];</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> q&gt;</span><br><span class="line">    mat&lt;n,q&gt; <span class="keyword">operator</span> * (mat&lt;m,q&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        mat&lt;n,q&gt;ans;</span><br><span class="line">        <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;q;j++)</span><br><span class="line">                    (ans.a[i][j]+=a[i][k]*b.a[k][j])%=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;num0[<span class="number">200001</span>];</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;num1[<span class="number">200001</span>];</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;num2[<span class="number">200001</span>];</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;num3[<span class="number">200001</span>];</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;val0[<span class="number">200001</span>];</span><br><span class="line">mat&lt;<span class="number">2</span>,<span class="number">2</span>&gt;val2[<span class="number">200001</span>];</span><br><span class="line"><span class="type">bool</span> rev[<span class="number">200001</span>];</span><br><span class="line"><span class="type">bool</span> fli[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> pri[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> siz[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> ls[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> rs[<span class="number">200001</span>];</span><br><span class="line"><span class="type">char</span> in[<span class="number">100002</span>];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Neww</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    pri[tot]=_rand(),siz[tot]=<span class="number">1</span>;</span><br><span class="line">    num0[tot].a[<span class="number">0</span>][<span class="number">0</span>]=num0[tot].a[<span class="number">0</span>][<span class="number">1</span>]=num0[tot].a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    num2[tot].a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">2</span>,num2[tot].a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">-1</span>,num2[tot].a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    val0[tot]=num1[tot]=num0[tot],val2[tot]=num3[tot]=num2[tot];</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Newe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    pri[tot]=_rand(),siz[tot]=<span class="number">1</span>;</span><br><span class="line">    num0[tot].a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">2</span>,num0[tot].a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">-1</span>,num0[tot].a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    num2[tot].a[<span class="number">0</span>][<span class="number">0</span>]=num2[tot].a[<span class="number">0</span>][<span class="number">1</span>]=num2[tot].a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    val0[tot]=num1[tot]=num0[tot],val2[tot]=num3[tot]=num2[tot];</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[p])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[p]^=<span class="number">1</span>;</span><br><span class="line">        rev[ls[p]]^=<span class="number">1</span>,rev[rs[p]]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(ls[p],rs[p]);</span><br><span class="line">        <span class="built_in">swap</span>(num0[p],num1[p]),<span class="built_in">swap</span>(num2[p],num3[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fli[p])</span><br><span class="line">    &#123;</span><br><span class="line">        fli[p]^=<span class="number">1</span>;</span><br><span class="line">        fli[ls[p]]^=<span class="number">1</span>,fli[rs[p]]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(num0[p],num2[p]),<span class="built_in">swap</span>(num1[p],num3[p]),<span class="built_in">swap</span>(val0[p],val2[p]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[p]) <span class="built_in">push_down</span>(ls[p]);</span><br><span class="line">    <span class="keyword">if</span>(rs[p]) <span class="built_in">push_down</span>(rs[p]);</span><br><span class="line">    num0[p]=num0[ls[p]]*val0[p]*num0[rs[p]];</span><br><span class="line">    num2[p]=num2[ls[p]]*val2[p]*num2[rs[p]];</span><br><span class="line">    num1[p]=num1[rs[p]]*val0[p]*num1[ls[p]];</span><br><span class="line">    num3[p]=num3[rs[p]]*val2[p]*num3[ls[p]];</span><br><span class="line">    siz[p]=siz[ls[p]]+siz[rs[p]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;merge %d %d\n&quot;,u,v);</span></span><br><span class="line">    <span class="keyword">if</span>(!u||!v) <span class="keyword">return</span> u|v;</span><br><span class="line">    <span class="keyword">if</span>(pri[u]&gt;=pri[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(u);</span><br><span class="line">        rs[u]=<span class="built_in">merge</span>(rs[u],v);</span><br><span class="line">        <span class="built_in">push_up</span>(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(v);</span><br><span class="line">        ls[v]=<span class="built_in">merge</span>(u,ls[v]);</span><br><span class="line">        <span class="built_in">push_up</span>(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> s,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123; x=y=<span class="number">0</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(siz[ls[p]]&gt;=s)</span><br><span class="line">    &#123;</span><br><span class="line">        y=p;</span><br><span class="line">        <span class="built_in">split</span>(ls[p],s,x,ls[y]);</span><br><span class="line">        <span class="built_in">push_up</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=p;</span><br><span class="line">        <span class="built_in">split</span>(rs[p],s-siz[ls[p]]<span class="number">-1</span>,rs[x],y);</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">push_down</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,(num0[root].a[<span class="number">0</span>][<span class="number">0</span>]+mod)%mod,(num0[root].a[<span class="number">0</span>][<span class="number">0</span>]+num0[root].a[<span class="number">0</span>][<span class="number">1</span>]+<span class="number">2</span>*mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;root=%d\n&quot;,root);</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=tot;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d : ls=%d rs=%d rev=%d fli=%d siz=%d &quot;,i,ls[i],rs[i],rev[i],fli[i],siz[i]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld\n&quot;,val0[i].a[0][0],val0[i].a[0][1],val2[i].a[0][0],val2[i].a[0][1],num0[i].a[0][0],num0[i].a[0][1],num1[i].a[0][0],num1[i].a[0][1],num2[i].a[0][0],num2[i].a[0][1],num3[i].a[0][0],num3[i].a[0][1]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;                                &quot;);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld\n&quot;,val0[i].a[1][0],val0[i].a[1][1],val2[i].a[1][0],val2[i].a[1][1],num0[i].a[1][0],num0[i].a[1][1],num1[i].a[1][0],num1[i].a[1][1],num2[i].a[1][0],num2[i].a[1][1],num3[i].a[1][0],num3[i].a[1][1]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in+<span class="number">1</span>);</span><br><span class="line">    num0[<span class="number">0</span>].a[<span class="number">0</span>][<span class="number">0</span>]=num0[<span class="number">0</span>].a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    num1[<span class="number">0</span>]=num2[<span class="number">0</span>]=num3[<span class="number">0</span>]=num0[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="string">&#x27;W&#x27;</span>) root=<span class="built_in">merge</span>(<span class="built_in">Neww</span>(),root);</span><br><span class="line">        <span class="keyword">else</span> root=<span class="built_in">merge</span>(<span class="built_in">Newe</span>(),root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">debug</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">1</span>]==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(in[<span class="number">1</span>]==<span class="string">&#x27;E&#x27;</span>) root=<span class="built_in">merge</span>(<span class="built_in">Newe</span>(),root);</span><br><span class="line">            <span class="keyword">else</span> root=<span class="built_in">merge</span>(<span class="built_in">Neww</span>(),root);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in[<span class="number">1</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=n-<span class="built_in">read</span>()+<span class="number">1</span>,l=n-<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">split</span>(root,r,y,z);</span><br><span class="line">            <span class="built_in">split</span>(y,l<span class="number">-1</span>,x,y);</span><br><span class="line">            rev[y]^=<span class="number">1</span>;</span><br><span class="line">            root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=n-<span class="built_in">read</span>()+<span class="number">1</span>,l=n-<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">split</span>(root,r,y,z);</span><br><span class="line">            <span class="built_in">split</span>(y,l<span class="number">-1</span>,x,y);</span><br><span class="line">            <span class="comment">// printf(&quot;l=%d r=%d x=%d y=%d z=%d\n&quot;,l,r,x,y,z);</span></span><br><span class="line">            <span class="built_in">debug</span>();</span><br><span class="line">            fli[y]^=<span class="number">1</span>;</span><br><span class="line">            root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">debug</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">WE</span></span><br><span class="line"><span class="comment">APPEND E</span></span><br><span class="line"><span class="comment">FLIP 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP2005 提高组] 过河</title>
    <url>/NOIP2005%E8%BF%87%E6%B2%B3/</url>
    <content><![CDATA[<p>我觉得这题在luogu上难度评级不正常，它应该不只是一个绿题…</p>
<p>做题的时候遇到的，感觉可以算是一种新的dp优化方式。</p>
<p><a href="https://www.luogu.com.cn/problem/P1052">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个独木桥，起点为 $ 0 $ ，终点为 $ L $ ，这个独木桥上一共有 $ M $ 个石头。</p>
<p>现在有一只青蛙在 $ 0 $ 的位置，它每一次跳跃可以使自己的位置增加 $ [S,T] $ 中的一个整数。</p>
<p>现在这只青蛙想要跳到 $ \geqslant L $ 的位置，请问它最少需要猜到多少块石头。</p>
<p>$ 1\leqslant L\leqslant 10^9 $</p>
<p>$ 1\leqslant S\leqslant T\leqslant 10 $</p>
<p>$ 1\leqslant M\leqslant 100 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们会发现，如果本题的 $ L $ 比较小，那么我们可以直接通过dp来解决。</p>
<p>方程为：$ dp_i=[i\text{上有石头}]+\min\limits_{j=S}^Tdp_{i-j} $ 。</p>
<p>这样我们能拿到 $ 30 $ 分。</p>
<p>再次观察数据范围，我们发现 $ S,T,M $ 三个量都很小。</p>
<p>尤其是 $ S,T $ 这两个量，格外突出。</p>
<p>首先我们可以特判  $ S=T $ 的情况，这种情况我们可以直接算出答案。</p>
<p>对于剩下的情况，我们会发现，对于一个<strong>很大的</strong>距离 $ a $ ，即使我们每一次只向前跳 $ S $ 或 $ S+1 $ 的距离，我们也可以恰好“凑出”一个 $ a $ 。</p>
<p>这就告诉我们，假如两块石头之间的距离比较大，我们可以手动把它们之间的距离缩小。</p>
<p>那么具体缩小多少呢？</p>
<p>一种可行的思路每一次缩短 $ 2520 $ ，它是 $ \operatorname{lcm}(1,2,3,4,5,6,7,8,9,10) $ 。</p>
<p>还有一种思路就是 $ 71 $ ，因为所有 $ \geqslant 71 $ 的数字都可以使用任意相邻两个数“凑”出来。</p>
<p>时间复杂度是 $ O(71M) $  。</p>
<p>我的代码中取的是 $ 72 $ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">30001</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">30001</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">102</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">102</span>];</span><br><span class="line"><span class="type">int</span> l,s,t,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l=<span class="built_in">read</span>(),s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>(),n=<span class="built_in">read</span>(),a[n+<span class="number">1</span>]=l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(s==t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i]%s==<span class="number">0</span>) ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pre[i]&gt;=<span class="number">72</span>) pre[i]=pre[i]%<span class="number">72</span>+<span class="number">72</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="number">-1</span>]+pre[i],vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">    l=a[n]+pre[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp)),dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++) <span class="keyword">for</span>(<span class="type">int</span> j=s;j&lt;=t&amp;&amp;j&lt;=i;j++) dp[i]=<span class="built_in">min</span>(dp[i],dp[i-j]+vis[i]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a[n];i&lt;=l;i++) ans=<span class="built_in">min</span>(ans,dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2023游记</title>
    <url>/NOI2023%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>感觉时间跨度比较大，直接写日期了。</p>
<span id="more"></span>
<h2 id="6-17-6-19"><a href="#6-17-6-19" class="headerlink" title="6.17-6.19"></a>6.17-6.19</h2><p>陕西中考。</p>
<p>在考点附近订的酒店，考试几天一直住在旁边。</p>
<p>老师和去年一样，说是考点没有时钟，但是考点还是有时钟的（手表白买了</p>
<p>估分的时候感觉还是有点拉。</p>
<p>后面颓了两天就开始训练了。</p>
<h2 id="7-1-7-7"><a href="#7-1-7-7" class="headerlink" title="7.1-7.7"></a>7.1-7.7</h2><p>ISIJ 2023。</p>
<p>前面两天的数学赛和代码赛都特别烂，考了 $ 20 $ 多名。</p>
<p>杯赛的中午睡了个午觉，感觉直接原地起飞，最后杯赛考了第 $ 3 $ ，没有被钉在耻辱柱上。</p>
<p>毕竟去年拿金，今年拿银可就太尴尬了。</p>
<p>还是得%wmh，small &amp; strong。</p>
<h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><p>补不动题，开始慢慢写游记（</p>
<h2 id="7-14-7-16"><a href="#7-14-7-16" class="headerlink" title="7.14~7.16"></a>7.14~7.16</h2><p>中考出分，实际分数比估分高了 $ 8 $ 分。</p>
<p><del>好欸，考上我们学校了</del></p>
<p>UOJ NOI Round</p>
<p>感觉题好难，打得好扯</p>
<p>成功打铜</p>
<h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><p>vp NOI2022 Day1</p>
<p>四个人一起vp，每个人都是只会 $ 115 $ 。</p>
<p>下来一看，好，T1全挂了。</p>
<p>调了半天，发现自己链表合并写错+数组开小。</p>
<p>好多人挂的ll，还有deque的MLE，我全都没挂。</p>
<p>成功走出了一条让教练无比震惊的挂分路线。</p>
<p>最后拿了 $ 75+15+0=90 $ 。</p>
<h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><p>vp NOI2022 Day2</p>
<p>感觉第二天的题很好拿部分分。</p>
<p>最后发现自己想了好久，没时间打了。</p>
<p>理论上是会 $ 100+76+26=202 $ 的。</p>
<p>最后只拿了 $ 100+40+0=140 $ 。</p>
<p>噫，我要是昨天不挂+今天暴力打满就金了！</p>
<p>好，两个一个都达不到呢！</p>
<p>不管了，翻盘银牌了。</p>
<p>对自己的定位一直是中上位银牌。</p>
<h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><p>出发，到了之后就正常报到。</p>
<p>感觉成七好大，比我们学校大多了。</p>
<p>果然是别人家的学校（</p>
<p>哪里都比我们好，就是厕所，额，不好评价。</p>
<h2 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h2><p>上午开幕式，感觉节目挺不错的。</p>
<p>领导致辞之类的没仔细听，反正不关我事（</p>
<p>笔试的时候，别的题都做的很快，只有 $ 47 $ 题犹豫不决。</p>
<p>成绩不到半个小时应该就出来了，果然错了，不好评价。</p>
<p>我的内心：笔试 $ 99 $ ，完蛋，完大蛋。</p>
<p>回去发现我们学校来了 $ 9 $ 个人，好像只有 $ 4 $ 个人满了，那问题不大。</p>
<p>晚上教练把手机收了。</p>
<h2 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h2><p>Day 1</p>
<p>比赛开始以后和往常一样，把所有题看了一遍。</p>
<p>T1想了一会，发现如果没有斜线的话，似乎两个扫描线就可以解决。</p>
<p>然后发现斜线和直线可以暴力判相交。</p>
<p>写了一会小样例就过了，然而大样例只过了没有斜线的两个。</p>
<p>肉眼调试调不出来，只能写了个拍。</p>
<p>拍了半天，发现斜线和直线交点算错了，也是很无语。</p>
<p>改了一下大样例就全过了，这个时候正好一个半小时。</p>
<p>然后看T2，先写了指数暴力。</p>
<p>仔细看看数据范围，盲猜 $ m\le 2 $ 是式子。</p>
<p>$ m\le 1 $ 猜完之后，看大样例发现是对的。</p>
<p>$ m=2 $ 发现稍微有点问题，根据大样例改了改感觉也没啥问题。</p>
<p>然后发现还有 $ 35 $ 分的 $ k=0 $ 应该可以dp，不过还是打算先看T3。</p>
<p>仔细想了一会T3，发现 $ 36 $ 分应该可以简单容斥，直接就写了。</p>
<p>然后发现特殊性质A(链)感觉很可做，就稍微想了想。</p>
<p>开打的时候还有一个半小时，原计划是半个小时打完这个，然后剩下一个小时去肝T2的dp。</p>
<p>然后嘛，写了挂，挂了拍，拍了假，假了改，改了挂，挂了拍，拍了假。。。</p>
<p>最后剩半个小时的时候我急了，直接改了 $ n^2 $ ，应该是有 $ 5 $ 分还是 $ 10 $ 分，写完还是一直挂，直到还有 $ 15min $ 。</p>
<p>最后实在憋不住了，打了个暴力，拿了T2 $ n=1,k=0 $ 的前 $ 10 $ 分，发现没有合适的大样例，遂摆烂，然后遗憾离场。</p>
<p>预计得分 $ 100+45+36=181 $ ，实际得分 $ 100+45+36=181 $ 。</p>
<h2 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h2><p>颓一天。</p>
<p>还是一样，晚上睡觉前教练收了手机。</p>
<h2 id="7-26"><a href="#7-26" class="headerlink" title="7.26"></a>7.26</h2><p>Day2</p>
<p>还是一样，先把所有题看一遍。</p>
<p>看完以后的几个直觉：T1不是很难，T2可能是正串拼反串然后一个SA，T3可能有隐藏的神秘结论。</p>
<p>然后开始推T1，推了半天发现确实不是很难，只需要子树内跑跑最短路然后和上面祖先min一min。</p>
<p>写到一半发现还有取模，然后改了改，写了写，小样例就过了。</p>
<p>一测，发现除了最后一个大样例，都过了。</p>
<p>懒得肉眼检查，直接拍，没拍出来，无语。</p>
<p>改了一个神奇地方，然后发现大样例过了，检查半天发现是不该取模的地方取模了。</p>
<p>这个时候正好也是一个半小时。</p>
<p>T2就按照我的直觉去想，然后发现 $ O(nq) $ 很简单，直接 $ 36 $ 分拿下。</p>
<p>然后我发现，所有满足条件的串，后缀数组上的顺序一定在那个起点的后面，但是可能会有相等的情况。</p>
<p>这个时候我已经在草稿纸上发现，相等的时候一定会有一个回文串了！！！</p>
<p>然后我就把推正解的工作留到了下场以后，就剩下一个傻逼找回文串和二维数点了，我没想到？？？</p>
<p>草稿纸上推完回文串发现没有卵用(?，然后看特殊性质B，发现没有相等的情况，一个线段树直接拿下。</p>
<p>然后看特殊性质A，这个条件很熟悉，直接就可以想到，两个串长度在 $ O(\log n) $ 以上时，不会相等。</p>
<p>那么先跑一个性质B，然后哈希一下，暴力枚举一下，也拿下了。</p>
<p>然后成功搞到 $ 72 $ 分。</p>
<p>这个时候去看T3，发现 $ w_i=1 $ 应该是送的。</p>
<p>随便写了一个 $ O(n^3) $ dp，发现和某些大样例是吻合的，就没管。</p>
<p>然后口胡了一个状压dp，发现时间复杂度是 $ O(3^nn^2) $ 的，觉得能过，就先写了。</p>
<p>写完之后试了一下 $ w_i=1 $ 的情况，发现 $ n=13 $ 的时候跑的很极限，多测肯定过不了。</p>
<p>然后自作聪明猜了一个结论，改了一个 $ O(3^nn) $ 的dp。</p>
<p>改完之后大概还有一个小时，然后我就在我猜的结论上继续打表猜结论。</p>
<p>猜着猜着发现不对劲，然后发现自己打挂了。</p>
<p>修完之后大概还剩半个小时，觉得不太稳，就和之前写的dp去拍。</p>
<p>然后，发现，结论错了，做法假了/fn</p>
<p>临时改改改改，又改了一个出来，拍拍拍拍拍，发现应该没挂，这个时候就剩不到 $ 5min $ 了，肉眼检查了一下，然后离场。</p>
<p>预计得分 $ 100+72+30=202 $ ，实际得分 $ 100+72+30=202 $ 。</p>
<p>下来两个小时之后抽空想了一下T2，发现我是傻逼，就差两分钟的思维量了，而我硬是没想出来？</p>
<h2 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h2><p>看了一下陕西的成绩，当时我以为是 $ 8 $ 个银 $ 8 $ 个铜的。</p>
<p>颁奖一出来，好家伙，$ 5 $ 个银 $ 11 $ 个铜，很震撼。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉这次noi还行，我的发挥也符合我的定位（银牌中上）。</p>
<p>因为我是回族，有忌口，之前一直在担心饭菜能不能吃，到学校之后发现是自助餐，觉得挺不错。</p>
<p>考试的缺点的话，就是笔试寄了 $ 1 $ 分。</p>
<p>优点的话，两天机试总共挂 $ 0 $ 分，完成了一个赛季挂分 $ \le 5 $ 的目标，分数也不算太低，可以忍受。</p>
<p>不过和省选一样，一坨暴力没调出来，少了一堆分，很难受。</p>
<p>最后总分是 $ 99+100+45+36+100+72+30=482 $ 。</p>
<p>学校环境感觉挺好，听说不如去年，但我去年不在，不好评价。</p>
<p>后面发现自己D1T2纯傻逼，我 $ m=2,k=0 $ 都直接猜对了，后面的 $ k=0 $ 却不会做？</p>
<p>不过幸好不会做，要不然 $ 507 $ 拿个银牌，气死我自己算了。</p>
<p>教练：明年你要是这样就金了（A队加分</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>NTT学习笔记</title>
    <url>/NTT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>NTT 的中文名称为快速数论变换，英文全称为 Number-theoretic transform，是 FFT 在数论基础上的实现，可以避免FFT的复数运算中的精度损失。</p>
<p>NTT 实际上是将 FFT 中的复数运算巧妙的替换为了整数运算。</p>
<span id="more"></span>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>若一个正整数 $ g $ 和一个质数 $ p $ 满足对于所有 $ 1\le i&lt;p $ ， $ g ^i\pmod p $ 的值互不相同。</p>
<h2 id="NTT原理"><a href="#NTT原理" class="headerlink" title="NTT原理"></a>NTT原理</h2><p>实际上，NTT就是选取了适当的模数以及任何一个这个质数的原根，并用一些整数代替了复数（被代替的就是上面的 $ \omega_n^i $）。</p>
<p>直接这样说估计没人懂，举个例子。</p>
<p>就以最常见的 NTT 模数 $ 998244353 $ 和它的原根（之一）$ 3 $ 来举例。</p>
<p>首先一个比较重要的地方，就是 $ 998244352=2^{23} \times 119 $，这是 NTT 模数的关键之一，这个模数减一必须是 $ 2 $ 的较大次幂的倍数。</p>
<p>假设现在要进行 NTT 的多项式共有 $ n $ 项（和 FFT 一样，$ n $ 是 $ 2 $ 的整数次幂），那么用哪个数字代替 $ \omega_n^1 $ 比较合适呢？</p>
<p>不难想到，用 $ 3^\frac{998244352}{n}\pmod{998244353} $ 代替 $ \omega_n^1 $，同理对于其他 $ i $ ，用 $ \left(3 ^\frac{998244352}{n}\right) ^i\pmod{998244353} $ 代替 $ \omega _n ^i$，这样就大功告成。</p>
<p>此外将 FFT 的其他操作（加法，乘法，减法等）改成模意义下的运算，所有的复数都改成整数，就可以了。</p>
<p>同理，假如使用一个质数 $ p $ 与它的原根 $ g $ 进行 NTT 时，使用 $ \left(g ^{\frac{p-1}{n}}\right) ^i\pmod p $ 代替 $ \omega_n^i $ 即可。</p>
<h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>不难发现，FFT 能够快速运算的运算在于复数的那三个性质。</p>
<p>同时，这也是 NTT 可以快速计算的关键，因为我们刚刚对于 $ \omega_n^i $ 的取值也满足这些性质！</p>
<p>下面我们来一条一条看。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_n^n&=1&(1)
\end{aligned}</script><p>证明：</p>
<script type="math/tex; mode=display">
\left(g^{\frac{p-1}{n}}\right)^n\equiv g^{p-1}\equiv 1\pmod p</script><p>注意，对于所有质数 $ p $ 都有 $ g^{p-1}\equiv 1\pmod p $。</p>
<hr>
<script type="math/tex; mode=display">
\begin{aligned}
\omega^k_n&=\omega_{2n}^{2k}&(2)
\end{aligned}</script><p>证明：</p>
<script type="math/tex; mode=display">
\left(g^{\frac{p-1}{2n}}\right)^{2k}\equiv g^{\frac{k(p-1)}{n}}\equiv \left(g^{\frac{p-1}{n}}\right)^k\pmod p</script><hr>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_n^{k+\frac{n}{2}}&=-\omega_n^k&(3)
\end{aligned}</script><p>证明：</p>
<script type="math/tex; mode=display">
\text{就是要证}\left(g^{\frac{p-1}{n}}\right)^{k+\frac{n}{2}}+\left(g^{\frac{p-1}{n}}\right)^k\equiv 0\pmod p</script><script type="math/tex; mode=display">
\left(g^{\frac{p-1}{n}}\right)^{k+\frac{n}{2}}+\left(g^{\frac{p-1}{n}}\right)^k\equiv g^{\frac{k(p-1)}{n}}\times g^{\frac{p-1}{2}}+g^{\frac{k(p-1)}{n}}\equiv g^{\frac{k(p-1)}{n}}\times\left(g^{\frac{p-1}{2}}+1\right)\pmod p</script><p>注意到一定会有 $ g^{\frac{p-1}{2}}\equiv-1\pmod p $ </p>
<p>所以这个式子的值为 $ 0 $ 。</p>
<p>额，$ g^{\frac{p-1}{2}}\equiv-1\pmod p $ 似乎不算很显然，我们来证一下。</p>
<p>首先，根据原根的性质，我们知道对于 $ 0\leqslant i &lt;p $ ，肯定恰好存在一个 $ i $ 使得 $ g^i \equiv -1\pmod p $ 。</p>
<p>那么我们就知道，一定会有 $ g^{2i}=1\pmod p $ 。</p>
<p>同时，我们知道，一定恰好存在一个 $ j $ 使得 $ g^j\equiv 1\pmod p $ （还是原根的性质），而我们知道 $ j=0 $。</p>
<p>所以就会有 $ 2i\equiv 0\pmod {p-1} $ 。</p>
<p>这个方程一共有两个解，$ i=0 $ 或 $ i=\dfrac{p-1}{2} $ 。</p>
<p>显然，$ i=0 $ 不满足条件，因为 $ g^0=1 $。</p>
<p>所以一定会有 $ g^{\frac{p-1}{2}}\equiv -1\pmod p $ 。</p>
<p>NTT 就说完了。</p>
<p><a href="https://www.luogu.com.cn/record/80789729">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/kumgzeb0">代码</a></p>
<p>加上快读和快些还能<a href="https://www.luogu.com.cn/record/80790614">快一点</a>。</p>
<hr>
<p>下面是几个模板呀。</p>
<h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><p><a href="https://www.luogu.com.cn/problem/P4238">P4238 【模板】多项式乘法逆</a></p>
<p>设原多项式为 $ f $ ，它的逆为 $ f^{-1} $。</p>
<p>设 $ f_0=f\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}} $ ，它的逆为 $ f^{-1}_0 $。</p>
<p>则一定会有以下几个性质：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f\times f^{-1}&\equiv 1\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}&(1)\\
f_0\times f^{-1}_0&\equiv 1\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}&(2)\\
f^{-1}-f^{-1}_0&\equiv 0\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}&(3)
\end{aligned}</script><p>则由 $ (3) $ 可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f^{-1}-f^{-1}_0)^2&\equiv0&\pmod{x^n}\\
f^{-2}+f_0^{-2}-2f^{-1}f^{-1}_0&\equiv0&\pmod{x^n}
\end{aligned}</script><p>两边同时乘上 $ f $ 。（<del>其实只有一边</del>）</p>
<script type="math/tex; mode=display">
\begin{aligned}
f^{-1}+f_0^{-2}f-2f^{-1}_0&\equiv0&\pmod{x^n}\\
f^{-1}&\equiv 2f^{-1}_0-f_0^{-2}f&\pmod{x^n}\\
f^{-1}&\equiv f_0^{-1}(2-f_0^{-1}f)&\pmod{x^n}
\end{aligned}</script><p>也就是说，只要我们知道了 $ f_0^{-1} $ ，就可以在 $ O(n\log n) $ 的时间内把 $ f^{-1} $ 算出来（NTT 把上面的式子卷一下）。</p>
<p>时间复杂度 $ T(n)=T\left(\dfrac{n}{2}\right)+O(n\log n)=O(n\log n) $ 。</p>
<p><a href="https://www.luogu.com.cn/record/80795192">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/51ybpywh">代码</a></p>
<h2 id="任意模数多项式乘法"><a href="#任意模数多项式乘法" class="headerlink" title="任意模数多项式乘法"></a>任意模数多项式乘法</h2><p><a href="https://www.luogu.com.cn/problem/P4245">P4245 【模板】任意模数多项式乘法</a></p>
<p>我们可以发现，这道题里面的模数可能不能满足之前我们对模数的要求，甚至不是一个质数，所以我们不能直接进行 NTT。</p>
<p>这里我使用的是三模数 NTT。</p>
<p>具体做法就是我们找三个可以进行的 NTT 的模数，然后做三遍 NTT，最后使用 CRT 求出答案。</p>
<p>这里我使用的三个模数分别为 $ 998244353=2^{23}\times 119+1$ , $985661441=2^{22}\times 235+1$ , $1004535809=2^{21}\times 479+1 $ 。</p>
<p>直接做就可以了。</p>
<p>然而最后的 CRT 还是有一些细节的($ p_1\times p_2\times p_3&gt;10^{19}$)，因为模数个数比较少，所以我们可以手颓柿子：</p>
<p>首先我们知道这些：</p>
<script type="math/tex; mode=display">
\begin{cases}
x\equiv a_1\pmod{p_1}\\
x\equiv a_2\pmod{p_2}\\
x\equiv a_3\pmod{p_3}\\
\end{cases}</script><p>所以一定存在三个自然数 $ k_1,k_2,k_3 $ 使得 $ x=k_1p_1+a_1=k_2p_2+a_2=k_3p_3+a_3 $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
k_1p_1+a_1&=k_2p_2+a_2\\
k_1p_1+a_1&\equiv a_2&\pmod{p_2}\\
k_1&\equiv\dfrac{a_2-a_1}{p_1}&\pmod{p_2}\\
\end{aligned}</script><p>这样我们就可以求出 $ k_1\bmod p_2 $ 的值了，不妨记作 $ k_1’ $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&=k_1p_1+a_1\\
x&\equiv k_1'p_1+a_1\pmod{p_2}\\
x&\equiv k_1'p_1+a_1\pmod{p_1p_2}\\
\end{aligned}</script><p>令 $ a_4=k_1’p_1+a_1 $ ，则存在 $ k_4 $ 使得 $ x=k_4p_1p_2+a_4 $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
k_4p_1p_2+a_4&=k_3p_3+a_3\\
k_4p_1p_2+a_4&\equiv a_3&\pmod{p_3}\\
k_4&\equiv\dfrac{a_3-a_4}{p_1p_2}&\pmod{p_3}
\end{aligned}</script><p>$ a_4 $ 和 $ k_4 $ 都知道了，我们就可以求出 $ x $ 了。</p>
<p>当然，你也可以使用 <code>__int128</code>来做。</p>
<p>中间的取模还是有很多细节的，具体可以看代码。</p>
<p><a href="https://www.luogu.com.cn/record/80809644">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/304d8neq">代码</a></p>
<p>把三个数字写成一个结构体，一起 NTT 还能更快亿点，真的是亿点。</p>
<p><a href="https://www.luogu.com.cn/record/80809817">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/18m7pda3">代码</a></p>
<h2 id="分治NTT"><a href="#分治NTT" class="headerlink" title="分治NTT"></a>分治NTT</h2><p><a href="https://www.luogu.com.cn/problem/P4721">P4721 【模板】分治 FFT</a></p>
<p>虽然写的是FFT，但实际上是分治NTT…</p>
<p>我们要求出一个满足条件的多项式 $ f $ ，但是 $ f $ 的值和 $ f,g $ 有关。</p>
<p>考虑进行分治。</p>
<p>假设我们现在分治到了一个区间 $ [l,r] $ ，下一步肯定是分治 $ [l,mid] $ 这个区间。</p>
<p>然后呢？我们需要快速处理区间 $ [l,mid] $ 向 $ [mid+1,r] $ 的贡献。</p>
<p>实际上 NTT 卷一下就可以了。</p>
<p>时间复杂度 $ T(n)=2T\left(\dfrac{n}{2}\right)+O(n\log n)=O(n\log^2 n) $ 。</p>
<p><a href="https://www.luogu.com.cn/record/80858343">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/tyghl292">代码</a></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=7162">hdu7162</a> 和 <a href="https://shijiuwan.github.io/hdu7162题解/">题解</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>[SNOI2017] 礼物</title>
    <url>/SNOI2017%E7%A4%BC%E7%89%A9/</url>
    <content><![CDATA[<p>这道题是一道十分标准的矩阵快速幂题目。</p>
<p><a href="https://www.luogu.com.cn/problem/P5364">题目链接</a></p>
<span id="more"></span>
<p>我们来看这道题数据范围 $ N\leqslant 10^{18} $ ，我们很容易可以得到这道题算法为矩阵快速幂。</p>
<p>那么我们先来看一下两个矩阵是怎么相乘的。</p>
<p>首先，两个矩阵 $ A $ 与 $ B $ 相乘的必要条件为 $ A $ 的列等于 $ B $ 的行数，相乘的结果矩阵 $ C $ 的行数等于 $ A $ 的行数，$ C $ 的列数等于 $ B $ 的列数。</p>
<p>既然这道题需要矩阵，为了方便起见，我们可以把矩阵结构体进行封装，代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m,n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a[<span class="number">30</span>][<span class="number">30</span>]; </span><br><span class="line">    mat <span class="keyword">operator</span> * (mat&amp; b)  <span class="comment">//重构乘法运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        <span class="built_in">memset</span>(c.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(c.a));</span><br><span class="line">        c.m=m;</span><br><span class="line">        c.n=b.n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.a[i][j]+=(a[i][p]*b.a[p][j])%<span class="number">1000000007</span>;</span><br><span class="line">                    c.a[i][j]%=<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但是我们会有一个问题：矩阵里面应该放什么变量呢？</p>
<p>首先我们会想到放入第 $ i $ 个人的礼物数量，</p>
<p>其次我们会用到之前所有人的礼物数量之和，因为计算第 $ i $ 个人礼物数量会用到。</p>
<p>我们在计算第 $ i $ 个人的礼物数量需要用到 $ i^{k} $,所以在矩阵中还要有 $ i^{k} $ 。</p>
<p>同时需要计算 $ i^{k} $ 还需要 $ i^{k-1} $ ，而 $ i^{k-1} $ 还需要 $ i^{k-2} $。</p>
<p>所以我们找到了矩阵中需要放入的变量：当前朋友的礼物、$ i^{k} $、$ i^{k-1} \cdots i $、$ 1 $ 。</p>
<p>我构造的矩阵是这样的：</p>
<p>$\begin{vmatrix}<br>num_{i}  &amp;i^{k}  &amp;i^{k-1}  &amp;\cdots  &amp;i  &amp;1   &amp;S_{i}<br>\end{vmatrix}$</p>
<p>那么接下来的一步就变成矩阵快速幂了，</p>
<p>那么这种矩阵应该乘一个怎样的矩阵才能变化到下一步呢？</p>
<p>这个矩阵的下一步是这样的：</p>
<p>$\begin{vmatrix}<br>num_{i+1}  &amp;\left(i+1\right)^{k}  &amp;\left(i+1\right)^{k-1}  &amp;\cdots  &amp;\left(i+1\right)  &amp;1   &amp;S_{i+1}<br>\end{vmatrix}$</p>
<p>我们来一步一步地看：</p>
<p>$ num_{i+1}=S_{i}+\left(i+1\right)^{k} $,</p>
<p>$ S_{i+1}=S_{i}+num_{i} $</p>
<p>那么 $ \left(i+1\right)^{k} $、$ \left(i+1\right)^{k-1} $ 等又应该如何构造呢？</p>
<p>$ \because $ 二项式定理，所以这个地方应该是一个杨辉三角，我们可以写一个函数来求。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> yh[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">yhsj</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!yh[x][y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span>||y==x)</span><br><span class="line">            yh[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            yh[x][y]=yh[x<span class="number">-1</span>][y<span class="number">-1</span>]+yh[x<span class="number">-1</span>][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> yh[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nb</span><span class="params">(mat&amp; a,<span class="type">long</span> <span class="type">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.m=a.n=k+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a.a));</span><br><span class="line">    a.a[k+<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    a.a[k+<span class="number">3</span>][k+<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">             a.a[k+<span class="number">3</span>-j][k+<span class="number">3</span>-i]=<span class="built_in">yhsj</span>(i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">2</span>;i++)</span><br><span class="line">        a.a[i][<span class="number">1</span>]=a.a[i][k+<span class="number">3</span>]=a.a[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 $ \operatorname{yhsj} $ 函数用于计算杨辉三角，数组 $ yh $ 用于记忆化搜索杨辉三角的某一项。</p>
<p>接下来就是快速幂的部分了。</p>
<p>实际上这个部分很简单，这要把整数的快速幂稍微修修改可以了。</p>
<p>递归形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">mat <span class="title">mut</span><span class="params">(mat a,<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mat b;</span><br><span class="line">        b.m=b.n=k+<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(b.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">3</span>;i++)</span><br><span class="line">            b.a[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    mat ans;</span><br><span class="line">    ans.m=ans.n=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">    ans=<span class="built_in">mut</span>(a,t/<span class="number">2</span>);</span><br><span class="line">    ans=ans*ans;</span><br><span class="line">    <span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        ans=ans*a;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>$ while $ 循环形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">mat <span class="title">mut</span><span class="params">(mat a,<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">    ans.m=ans.n=k+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">3</span>;i++)</span><br><span class="line">        ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        t=t/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面给出最终代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> yh[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m,n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    mat <span class="keyword">operator</span> * (mat&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        <span class="built_in">memset</span>(c.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(c.a));</span><br><span class="line">        c.m=m;</span><br><span class="line">        c.n=b.n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.a[i][j]+=(a[i][p]*b.a[p][j])%<span class="number">1000000007</span>;</span><br><span class="line">                    c.a[i][j]%=<span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span> + (mat&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        c.n=b.n;</span><br><span class="line">        c.m=b.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                c.a[i][j]=a[i][j]+b.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">yhsj</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!yh[x][y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span>||y==x)</span><br><span class="line">            yh[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            yh[x][y]=yh[x<span class="number">-1</span>][y<span class="number">-1</span>]+yh[x<span class="number">-1</span>][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> yh[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nb</span><span class="params">(mat&amp; a,<span class="type">long</span> <span class="type">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.m=a.n=k+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a.a));</span><br><span class="line">    a.a[k+<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    a.a[k+<span class="number">3</span>][k+<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            a.a[k+<span class="number">3</span>-j][k+<span class="number">3</span>-i]=<span class="built_in">yhsj</span>(i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">2</span>;i++)</span><br><span class="line">        a.a[i][<span class="number">1</span>]=a.a[i][k+<span class="number">3</span>]=a.a[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nbnb</span><span class="params">(mat&amp; a,<span class="type">long</span> <span class="type">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a.a));</span><br><span class="line">    a.m=<span class="number">1</span>;</span><br><span class="line">    a.n=k+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">3</span>;i++)</span><br><span class="line">        a.a[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mat <span class="title">mut</span><span class="params">(mat a,<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mat b;</span><br><span class="line">        b.m=b.n=k+<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(b.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">3</span>;i++)</span><br><span class="line">            b.a[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    mat ans;</span><br><span class="line">    ans.m=ans.n=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">    ans=<span class="built_in">mut</span>(a,t/<span class="number">2</span>);</span><br><span class="line">    ans=ans*ans;</span><br><span class="line">    <span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        ans=ans*a;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="built_in">nb</span>(ans,k);</span><br><span class="line">    mat op;</span><br><span class="line">    <span class="built_in">nbnb</span>(op,k);</span><br><span class="line">    mat num=<span class="built_in">mut</span>(ans,n<span class="number">-1</span>);</span><br><span class="line">    num=op*num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,num.a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><del>不愧是我，最终代码正好打了100行。</del></p>
<p>本人第一次写题解，欢迎各位大佬指出我的错误。</p>
<p>这真的是一篇早期题解，我 $ 2021 $ 年寒假写的。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>[SNOI2017]遗失的答案</title>
    <url>/SNOI2017%E9%81%97%E5%A4%B1%E7%9A%84%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>模拟赛里的题，但是没有做出来…有点菜啊。</p>
<p><a href="https://www.luogu.com.cn/problem/P5366">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个人买了 $ 1\sim N $ 中的若干个皮肤，皮肤编号的最大公倍数为 $ G $ ，最小公约数为 $ L $ 。</p>
<p>现在给出 $ Q $ 组询问，每次询问有多少种方案买了皮肤 $ X $ 。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们可以做一步非常简单的转化，让我们之后的步骤更顺手。</p>
<p>显然，所有可能买的皮肤肯定都是 $ G $ 的倍数，询问的 $ X $ 肯定只在为 $ G $ 的倍数时才有答案。</p>
<p>所以我们可以先把 $ N,L $ 和所有询问都先除以 $ G $ ，这样我们就可以把 $ G $ 当作 $ 1 $ 来处理。</p>
<p>当然，一个小坑点，要特判一下 $ L $ 是不是 $ G $ 的倍数。</p>
<p>然后我们在来想一下有什么皮肤<strong>可能会在方案中</strong>，显然只有 $ L $ 的因数。</p>
<p>容易注意到一个点，$ L $ 最大范围是 $ 10^8 $ ，而 $ 10^8 $ 以内因数最多数字，因数只有 $ 768 $ 个。</p>
<p>这提示我们可以先预处理出 $ L $ 因数的答案，然后询问时直接输出即可。</p>
<p>现在我们可以来想一想，有多少种方案包含皮肤 $ X $ ，并且皮肤编号的最大公约数是 $ 1 $ ，最小公倍数是 $ L $ 。</p>
<p>我在模拟赛时想到的思路就是容斥。</p>
<h3 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h3><p>不难看出，这道题有两个条件需要满足。</p>
<p>条件一为皮肤的最大公约数是 $ 1 $ ，转化一下，可以得到若干个条件，形如：</p>
<blockquote>
<p>至少有一个皮肤的编号不是 $ m $ 的倍数，其中 $ m=p^c,p\in primes,m|X $ 。</p>
</blockquote>
<p>条件二为皮肤的最小公倍数是 $ L $ ，转化一下，可以得到若干个条件，形如：</p>
<blockquote>
<p>至少有一个皮肤的编号是 $ m $ 的倍数，其中 $ m=p^c,p\in primes,m|L $ 。</p>
</blockquote>
<p>其中 $ X $ 已经满足的条件可以去掉。</p>
<p>这样子，我们就可以暴力枚举哪些条件不满足，进行容斥。</p>
<p>如果条件一不满足，那么他就会长这个样子：</p>
<blockquote>
<p>没有皮肤的编号不是 $ m $ 的倍数，也就是说所有皮肤编号都是 $ m $ 的倍数，$ m $ 的定义如上。</p>
</blockquote>
<p>如果条件二不满足，那么他就会长这个样子：</p>
<blockquote>
<p>没有皮肤的编号是 $ m $ 的倍数， $ m $ 的定义如上。</p>
</blockquote>
<p>然后我们暴力枚举每一个条件是否不满足，然后暴力枚举每一个可能的皮肤，直接容斥。</p>
<p>看一个皮肤满不满足一个条件可以通过提前预处理，然后 $ O(1) $ 使用位运算回答。</p>
<p>时间复杂度为 $ O(\textbf{约数个数}^2\times 2^\textbf{条件个数}) $ 。</p>
<p>打表可得，在 $ L $ 取 $ 91891800 $ 时这个数字最大，可以达到 $ 603979776\approx6\times 10^8 $ 。 </p>
<p>时限是 $ 2s $ ，可过。</p>
<p>打表程序核心代码放上，我本机差不多跑了半分钟。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,pri[0]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*j&lt;=n;j++) num[i*j]++;</span><br><span class="line">    <span class="comment">// printf(&quot;%lld\n&quot;,num[n]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i]*=num[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=pri[<span class="number">0</span>];i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;pri[i]*j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[pri[i]*j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j%pri[i]==<span class="number">0</span>) num[pri[i]*j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;%lld\n&quot;,num[n]);</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if(i%100000==0) printf(&quot;%d : %d %lld\n&quot;,i,ans,num[ans]);</span></span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;num[ans]) ans=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d : %lld\n&quot;</span>,ans,num[ans]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算条件个数的地方可能不太好理解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;ans;</span><br><span class="line">ll p[<span class="number">1048576</span>];</span><br><span class="line"><span class="type">int</span> pop[<span class="number">1048576</span>];</span><br><span class="line"><span class="type">bool</span> is[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> pri[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> visx[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> visy[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> x[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> y[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n,G,L,Q;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val=num/G;x[<span class="number">0</span>]=y[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;pri[i]*pri[i]&lt;=val&amp;&amp;i&lt;=pri[<span class="number">0</span>];i++) <span class="keyword">if</span>(val%pri[i]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x[++x[<span class="number">0</span>]]=pri[i];</span><br><span class="line">        <span class="keyword">while</span>(val%pri[i]==<span class="number">0</span>) val/=pri[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val!=<span class="number">1</span>) x[++x[<span class="number">0</span>]]=val;</span><br><span class="line">    val=L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;pri[i]*pri[i]&lt;=val&amp;&amp;i&lt;=pri[<span class="number">0</span>];i++) <span class="keyword">if</span>(val%pri[i]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(val%pri[i]==<span class="number">0</span>) val/=pri[i],v*=pri[i];</span><br><span class="line">        <span class="keyword">if</span>(num%v) y[++y[<span class="number">0</span>]]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val!=<span class="number">1</span>&amp;&amp;num%val) y[++y[<span class="number">0</span>]]=val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visx[i]=visy[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x[<span class="number">0</span>];j++) <span class="keyword">if</span>(a[i]%x[j]) visx[i]|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=y[<span class="number">0</span>];j++) <span class="keyword">if</span>(a[i]%y[j]==<span class="number">0</span>) visy[i]|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ll va=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;x[<span class="number">0</span>]);i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;y[<span class="number">0</span>]);j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=tot;k++) <span class="keyword">if</span>(a[k]!=num) sum+=(!(visx[k]&amp;i)&amp;&amp;!(visy[k]&amp;j));</span><br><span class="line">        <span class="comment">// printf(&quot;i=%d j=%d sum=%d\n&quot;,i,j,sum);</span></span><br><span class="line">        <span class="type">int</span> flag=(pop[i]+pop[j])&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        va+=flag*p[sum];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[num]=(va%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1048576</span>;i++) pop[i]=pop[i-(i&amp;(-i))]+<span class="number">1</span>,p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) pri[++pri[<span class="number">0</span>]]=i,is[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=<span class="number">10000</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=<span class="built_in">read</span>(),G=<span class="built_in">read</span>(),L=<span class="built_in">read</span>(),Q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(L%G)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> memG=G;L/=G,n/=G,G=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;i*i&lt;=L;i++) <span class="keyword">if</span>(L%i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++tot]=i;</span><br><span class="line">        <span class="keyword">if</span>(i!=L/i&amp;&amp;L/i&lt;=n) a[++tot]=L/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">run</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(x%memG||!ans.<span class="built_in">count</span>(x/memG)) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[x/memG]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你谷上开O2最大点跑了 $ 269ms $ 。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[SNOI2019] 数论</title>
    <url>/SNOI2019%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>前几天我们NOIP模拟赛的最后一题，然后一不小心挂了 $ 10 $ 分，痛失ak。</p>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5330">luoguP5330</a> 。</p>
<p>题目大意：给定两个数 $ P,Q $ 和两个集合 $ A,B $ 求 $ \sum\limits_{i=0}^{T-1}[(i\bmod P\in A)\wedge(i\bmod Q\in B)] $ 。</p>
<span id="more"></span>
<p>首先我们来看一个显而易见的规律：</p>
<p>假如说 $ P=4,Q=6 $。</p>
<p>$ 0\bmod P=0,0\bmod Q=0 $</p>
<p>$ 1\bmod P=1,1\bmod Q=1 $</p>
<p>$ \dots $</p>
<p>$ 11\bmod P=3,11\bmod Q=5 $</p>
<p>$ 12\bmod P=0,12\bmod Q=0 $</p>
<p>$ 13\bmod P=1,13\bmod Q=1 $</p>
<p>我们会发现，数字对于 $ P,Q $ 取模的值构成了“循环”，并且所有这些循环，对答案的贡献是相同的。</p>
<p>这些循环的答案非常容易计算，并且我们还可以知道一个循环的大小为 $ \dfrac{PQ}{\gcd(P,Q)} $ 。</p>
<p>这就是当 $ T $ 为 $ P,Q $ 公倍数时的解法。</p>
<p>配合暴力，我们可以拿到 $ 40 $ 分。</p>
<p>现在我们可以快速处理一个完整的循环，但是如果最后数字的个数不足以构成循环，我们就只能暴力。</p>
<p>显然，这样时间复杂度是 $ O(PQ) $ 的。</p>
<p>我们再来找规律，把数字 $ \bmod P,Q $ 的值做成表格。</p>
<p>$ P=4,Q=6: $</p>
<p><a href="https://imgtu.com/i/vik4Mj"><img src="https://s1.ax1x.com/2022/07/30/vik4Mj.png" alt="vik4Mj.png"></a></p>
<p>$ P=5,Q=7: $</p>
<p><a href="https://imgtu.com/i/vik5ss"><img src="https://s1.ax1x.com/2022/07/30/vik5ss.png" alt="vik5ss.png"></a></p>
<p>发现什么了吗？</p>
<p>对于第一个表格，$ \bmod P=0 $ 的数字分别是 $ 0,4,8,12,16,20 $ ，这些数字 $ \bmod Q $ 的值分别是 $ 0,4,2,0,4,2 $ 。</p>
<p>$ \bmod P=1 $ 的数字分别是 $ 1,5,9,13,17,21 $ ，这些数字 $ \bmod Q $ 的值分别是 $ 1,5,3,1,5,3 $ 。</p>
<p>有没有发现什么？</p>
<p>再看一眼第二个表格。</p>
<p>$ \bmod P=0 $ 的数字分别是 $ 0,5,10,15,20,25,30,35,40,45,50,55,60,65 $ </p>
<p>$ \bmod Q $ 的值分别是 $ 0,5,3,1,6,4,2,0,5,3,1,6,4,2 $ 。</p>
<p>$ \bmod P=1 $ 的数字分别是 $ 1,6,11,16,21,26,31,36,41,46,51,56,61,66 $ </p>
<p>$ \bmod Q $ 的值分别是 $ 1,6,4,2,0,5,3,1,6,4,2,0,5,3 $ 。</p>
<p>发现了什么呢？</p>
<p>假如说上一个出现的数字 $ \bmod Q $ 的值是 $ x $ ，那么下一个值就是 $ (x+P)\bmod Q $ 。</p>
<p>好，现在让我们把这个序列写出来，但是这个序列中可能不包含 $ 0\sim Q-1 $ 中的所有数，所以我们把若干个这样的序列“拼”在一起。</p>
<p>举个例子，对于第二个表格，对应的序列就是 $ 0,5,3,1,6,4,2 $ ，对于第一个表格，对应的序列就是 $ 0,4,2,1,5,3 $ 。</p>
<p>然后呢？不难发现，对于某一个 $ \bmod P $ 的值，他对答案的贡献在这个序列中是完整的一段。</p>
<p>然后前缀和就可以了。</p>
<p>前缀和维护的是 $ 0~Q-1 $ 的这个排列中，前 $ i $ 个数字里面，有多少个属于集合 $ B $。</p>
<p>所以可以直接枚举 $ A $ 中的元素，计算它的贡献。</p>
<p>我考场上傻了，写了个线段树。</p>
<p>时间复杂度 $ O(P+Q) $ 。</p>
<p>我写的是 $ O(Q+P\log Q) $ 。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DABC ABCD ABCA DBAA</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pl=pair&lt;ll,ll&gt;;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="keyword">using</span> vi=vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=a%b;</span><br><span class="line">    <span class="keyword">while</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">        r=a%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> pp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">bool</span> qq[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> t1[<span class="number">4000001</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> wh[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> visa[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> visb[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> n,m,p,q;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">ll ans;</span><br><span class="line">ll t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t1[p]++;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(p*<span class="number">2</span>,pl,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r) <span class="keyword">return</span> t1[p];</span><br><span class="line">    <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">get</span>(p*<span class="number">2</span>,pl,mid,l,r);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;r) ans+=<span class="built_in">get</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">read</span>(),q=<span class="built_in">read</span>(),n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),t=<span class="built_in">lread</span>();</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">gcd</span>(p,q);ll round=(ll)p*q/num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>(),visa[a[i]%num]++,pp[a[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) b[i]=<span class="built_in">read</span>(),visb[b[i]%num]++,qq[b[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++) ans+=(ll)visa[i]*visb[i]*(t/round);</span><br><span class="line">    ll rest=t-(t/round)*round;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;;)</span><br><span class="line">        &#123;</span><br><span class="line">            val[++tot]=j;</span><br><span class="line">            wh[j]=tot;</span><br><span class="line">            j=(j+p)%q;</span><br><span class="line">            <span class="keyword">if</span>(j==i) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=q;i++) printf(&quot;%d &quot;,val[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,q,wh[b[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=a[i];<span class="comment">//第v行</span></span><br><span class="line">        <span class="keyword">if</span>(rest&lt;i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> step=rest/p;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;rest%p) step++;</span><br><span class="line">        <span class="keyword">if</span>(!step) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=wh[v%q],r=wh[v%q]+step<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d : %d %d &quot;,a[i],l,r);</span></span><br><span class="line">        l--,r--;</span><br><span class="line">        <span class="comment">// ll mem=ans;</span></span><br><span class="line">        <span class="keyword">if</span>(l/(q/num)==r/(q/num)) ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,q,l+<span class="number">1</span>,r+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l2=l/(q/num)*(q/num);</span><br><span class="line">            <span class="type">int</span> r2=l2+q/num<span class="number">-1</span>;</span><br><span class="line">            ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,q,l2+<span class="number">1</span>,r-(q/num)+<span class="number">1</span>);</span><br><span class="line">            ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,q,l+<span class="number">1</span>,r2+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d %d &quot;,l2+1,r-(q/num)+1,l,r2);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\n&quot;,ans-mem);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2023] 字符串</title>
    <url>/NOI2023%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>现场选手，拿了 $ 72 $ 分。</p>
<p>感觉差点就切了啊，那应该还是我菜了</p>
<p>切了就金了，气死了。</p>
<p><a href="https://www.luogu.com.cn/problem/P9482">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个长度为 $ n $ 的字符串 $ s $ ，和 $ q $ 次询问。</p>
<p>定义 $ s[l:r] $ 为 $ s $ 的第 $ l $ 到 $ r $ 位构成的子串，$ R(t) $ 为翻转字符串 $ t $ 得到的字符串。</p>
<p>对于每一组询问，给出 $ i,r $ ，求出有多少个 $ l $ ，满足 $ 1\le l\le r $ 且 $ s[i:i+l-1]&lt;R(s[i+l:i+2l-1]) $</p>
<p>多组数据，$ 1\le t\le 5 $ 且单组数据 $ 1\le n,q\le 10^5 $ 。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先来讲一下我考场上的思路。</p>
<p>首先题目涉及了两个字符串字典序的比较，而且只涉及了原串的子串（及其翻转），我在考场上的直觉，就是正解的第一步，大概率是先把原串和它的反串拼在一起，跑一个后缀数组。</p>
<p>所以我们先令 $ s’=s+R(s) $ ，并对 $ s’ $ 建立后缀数组。</p>
<p>题目要求的是有多少个 $ l $ 满足条件，我们发现这个 $ l $ 给的是参与比较的两个串的分界线。</p>
<p>那我们考虑换一个元，我们不求有多少个 $ l $ 满足条件，我们求有多少个 $ x $ 满足条件，其中 $ x=i+2l-1 $ ，即我们对第二个串的末尾计数。</p>
<p>那么经过推导，我们可以知道，合法的 $ x $ 需要满足以下条件：</p>
<ol>
<li>$ i\le x \le i+2r-1 $ 且 $ x $ 与 $ i $ 不同奇偶，并且 $ rk_{i}\le rk_{2n-x+1} $；</li>
<li>$ lcp(s’[i:2n],s’[2n-x+1:2n])&lt;\dfrac{x-i+1}{2} $ 。</li>
</ol>
<p>条件可能写的很迷，来详细解释一下。</p>
<p>题目中要求 $ s[i:i+l-1]&lt;R(s[i+l:i+2l-1]) $ ，即 $ s’[i:i+l-1]&lt;s’[2n-(i+2l-1)+1:2n-(i+l)+1] $ 。</p>
<p>那么首先存在一个必要条件，就是 $ i $ 这个后缀一定要小于 $ 2n-(i+2l-1)+1=2n-x+1 $ 这个后缀。</p>
<p>这就是 $ rk_i\le rk_{2n-x+1} $ 的原因 。</p>
<p>但是我们发现，这个条件是必要的，但是不是充要的，为什么呢？</p>
<p>因为即使满足了上述的条件，也有可能出现两个串相等的情况，所以我们还要排除掉两个串相等的情况。</p>
<p>我们知道串的长度是 $ \dfrac{x-i+1}{2} $ ，所以还需要满足条件 $ lcp(s’[i:2n],s’[2n-x+1:2n])&lt;\dfrac{x-i+1}{2} $ 。</p>
<p>这两个条件都不是我一眼能看出来的，好难啊（</p>
<p>所以考虑一个条件一个条件的看。</p>
<h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>题目中有一个特殊性质 $ B $ ，是所有相邻的字符都不相等，可以推出第二个条件永远成立，所以在这个部分分中只需要考虑第一个条件。</p>
<p>还是一样，为了方便，换个元，令 $ x’=2n-x+1,L=2n-(i+2r-1)+1,R=2n-i+1 $ ，那么就是要求 $ L\le x’\le R $ ，$ rk_i\le rk_{x’} $ 且 $ i $  与 $ x’ $ 同奇偶的 $ x’ $ 数量。</p>
<p>首先将所有询问离线，并按照 $ i $ 的奇偶进行分类，这样我们只需要考虑与 $ i $ 奇偶性相同的 $ x’ $ 。</p>
<p>对于一组询问，我们将其中的询问按照 $ rk_i $ 从大到小的顺序进行排序。</p>
<p>这样，我们按照这个顺序进行处理，对于每一组询问，就可以将所有当前 $ rk_i&lt;rk_{x’} $ 的 $ x’ $ 插入一个线段树中。</p>
<p>然后查询区间 $ [L,R] $ 中有多少个 $ x’ $ ，这样三个条件我们就同时满足了。</p>
<p>直接这样做，和暴力拼一起可以拿到 $ 52 $ 分，时间复杂度为 $ O(t(n\log n+q\log n+q\log q)) $ 。</p>
<p>然后特殊性质A意思就是两个串相等的话，长度一定不会超过 $ O(\log n) $ ，经典结论了属于是。</p>
<p>然后想到这里就可以拿到 $ 72 $ 分乐。</p>
<h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>现在来看第二个条件。</p>
<p>我们首先发现 $ lcp $ 其实是SA上的RMQ问题，但是这样子显然太麻烦了，基本没有办法优化到 $ O(nq) $ 以下。</p>
<p>这个时候特殊性质B可以给我们启发。</p>
<p>特殊性质B意思是没有两个串相等，但是并没有直接说出来，而是采用了一种不那么显然的方式——相邻两个字符不相等。</p>
<p>仔细想想，我们会发现，第二个条件如果不满足，那么 $ s[i:x] $ 一定是一个回文串。</p>
<p>所以我们考虑先算出满足条件 $ 1 $ 的 $ x’ $ 的数量，在用它减去，满足条件 $ 1 $ 却不满足条件 $ 2 $ 的数量。</p>
<p>什么情况下，会出现满足条件 $ 1 $ 但不满足条件 $ 2 $ 呢？</p>
<ol>
<li>$ s[i:x] $ 为回文串；</li>
<li>$ rk_i&lt;rk_{2n-x+1} $ 。</li>
</ol>
<p>首先回文串数量很多，我们不可能每一个回文串都单独拿出来，所以我们先用 Manacher 找出所有满足条件的，极长回文串（只需要找出长度为偶数的就好）。 </p>
<p>假设一个合法回文串范围为 $ [L,R] $ ，那么我们定义它的中点 $ mid=\left\lfloor\dfrac{R-L+1}{2}\right\rfloor $ （即靠左的中心点），长度 $ len=mid-L+1 $ ，我们考虑使用中点与长度表示一个合法的回文串。</p>
<p>那么我们对于每一个询问，实际上要求的就是满足以下条件的回文串数量：</p>
<ol>
<li>$ mid-len+1\le i\le mid $ （回文串包含 $ i $ 这个位置，且 $ i $ 在中点以左）；</li>
<li>$ mid\le r+i-1 $ （满足题目中 $ l\le r $ 的限制）。</li>
</ol>
<p>我们发现，假如将一个回文串看作一个二维平面上的点 $ (X=mid,Y=mid-len+1) $ ，那么条件就是：</p>
<ol>
<li>$ i\le X\le r-i+1 $ ；</li>
<li>$ Y\le i $。</li>
</ol>
<p>这是一个标准的二维数点问题，差分后做二维偏序即可。</p>
<p>最后总时间复杂度还是 $ O(t(n\log n+q\log n+q\log q)) $ 。</p>
<p>记得清空，不然会挂很多。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我写了一坨，很长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,r;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> qans[<span class="number">100001</span>];</span><br><span class="line"><span class="type">char</span> in[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> S</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1[<span class="number">800001</span>];</span><br><span class="line">    <span class="type">int</span> num2[<span class="number">800001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num1,<span class="number">0</span>,<span class="built_in">sizeof</span>(num1));</span><br><span class="line">        <span class="built_in">memset</span>(num2,<span class="number">0</span>,<span class="built_in">sizeof</span>(num2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) num1[p]++;</span><br><span class="line">        <span class="keyword">else</span> num2[p]++;</span><br><span class="line">        <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(p*<span class="number">2</span>,pl,mid,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get1</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r) <span class="keyword">return</span> num1[p];</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">get1</span>(p*<span class="number">2</span>,pl,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;r) ans+=<span class="built_in">get1</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r) <span class="keyword">return</span> num2[p];</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">get2</span>(p*<span class="number">2</span>,pl,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;r) ans+=<span class="built_in">get2</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> part1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">200005</span>];</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">200005</span>];</span><br><span class="line">    <span class="type">int</span> num1[<span class="number">200001</span>];</span><br><span class="line">    <span class="type">int</span> num2[<span class="number">200001</span>];</span><br><span class="line">    <span class="type">int</span> sa[<span class="number">200001</span>];</span><br><span class="line">    <span class="type">int</span> rk[<span class="number">400001</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SA_sort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> ma)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(ma+<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[num2[i]+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ma+<span class="number">1</span>;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) tmp[++cnt[num2[i]]]=i;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(ma+<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[num1[i]+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ma+<span class="number">1</span>;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sa[++cnt[num1[tmp[i]]]]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SA</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,sa[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                num1[j]=rk[j];</span><br><span class="line">                num2[j]=rk[i+j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">SA_sort</span>(n,<span class="built_in">max</span>(<span class="number">26</span>,n));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> now=sa[j],lst=sa[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(num1[now]==num1[lst]&amp;&amp;num2[now]==num2[lst]) rk[now]=rk[lst];</span><br><span class="line">                <span class="keyword">else</span> rk[now]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;,s+1);</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,sa[i],&quot; \n&quot;[i==n]);</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,rk[i],&quot; \n&quot;[i==n]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[<span class="number">2</span>*n-i+<span class="number">1</span>]=in[i];</span><br><span class="line">        <span class="built_in">SA</span>(<span class="number">2</span>*n);<span class="type">int</span> now=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,[](node a,node b)&#123; <span class="keyword">return</span> rk[a.x]&gt;rk[b.x];&#125;);</span><br><span class="line">        S::<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(now&gt;rk[a[i].x])</span><br><span class="line">            &#123;</span><br><span class="line">                now--;</span><br><span class="line">                S::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>*n,sa[now]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l=a[i].x,r=l+<span class="number">2</span>*a[i].r<span class="number">-1</span>;</span><br><span class="line">            l=<span class="number">2</span>*n-l+<span class="number">1</span>,r=<span class="number">2</span>*n-r+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r&amp;<span class="number">1</span>) qans[a[i].id]=S::<span class="built_in">get1</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>*n,r,l);</span><br><span class="line">            <span class="keyword">else</span> qans[a[i].id]=S::<span class="built_in">get2</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>*n,r,l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> C</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,mid;</span><br><span class="line">    &#125;b[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> tag[<span class="number">400001</span>];</span><br><span class="line">    <span class="type">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tot++;</span><br><span class="line">        b[tot].l=l;</span><br><span class="line">        b[tot].mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=pl&amp;&amp;pr&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            tag[p]++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(p*<span class="number">2</span>,pl,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;r) <span class="built_in">add</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> tag[p];</span><br><span class="line">        <span class="type">int</span> mid=(pl+pr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> tag[p]+<span class="built_in">get</span>(p*<span class="number">2</span>,pl,mid,x);</span><br><span class="line">        <span class="keyword">return</span> tag[p]+<span class="built_in">get</span>(p*<span class="number">2</span>|<span class="number">1</span>,mid+<span class="number">1</span>,pr,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,[](node a,node b)&#123; <span class="keyword">return</span> a.v&lt;b.v;&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+tot+<span class="number">1</span>,[](pal a,pal b)&#123; <span class="keyword">return</span> a.mid&lt;b.mid;&#125;);</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;<span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="built_in">sizeof</span>(tag));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(now&lt;tot&amp;&amp;a[i].v&gt;=b[now+<span class="number">1</span>].mid)</span><br><span class="line">            &#123;</span><br><span class="line">                now++;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,b[now].l,b[now].mid);</span><br><span class="line">            &#125;</span><br><span class="line">            qans[a[i].id]-=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,a[i].x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> part2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">200005</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">200005</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gol</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=y) <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s[x-y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+y&gt;len) <span class="keyword">return</span> <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s[x+y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[len+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;r) num[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> num[i]=<span class="built_in">min</span>(num[l+r-i],r-i);</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">gol</span>(i,num[i]+<span class="number">1</span>)==<span class="built_in">gor</span>(i,num[i]+<span class="number">1</span>)) num[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i+num[i]&gt;r) l=i-num[i],r=i+num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        C::tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>) <span class="keyword">if</span>(num[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=(i-num[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> r=(i+num[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> wl=part1::rk[l],wr=part1::rk[<span class="number">2</span>*n-r+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d : %d %d\n&quot;,l,r,wl,wr);</span></span><br><span class="line">            <span class="keyword">if</span>(wl&gt;wr) <span class="keyword">continue</span>;</span><br><span class="line">            C::<span class="built_in">Add</span>(l,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[++cnt]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            s[++cnt]=in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[++cnt]=<span class="string">&#x27;#&#x27;</span>,len=cnt;</span><br><span class="line">        <span class="built_in">manacher</span>();</span><br><span class="line">        C::<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x=<span class="built_in">read</span>(),a[i].r=<span class="built_in">read</span>();</span><br><span class="line">        a[i].v=a[i].x+a[i].r<span class="number">-1</span>;</span><br><span class="line">        a[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    part1::<span class="built_in">mian</span>(),part2::<span class="built_in">mian</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();<span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SA</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>[UER#11]企鹅游戏</title>
    <url>/UER11%E4%BC%81%E9%B9%85%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>模拟赛遇到的</p>
<p>代码难度并不大，但是是有思维难度的。</p>
<p><a href="https://uoj.ac/contest/79/problem/772">题目链接</a> 。</p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $ n $ 个单词 $ s_1,s_2,\dots,s_n  $ 与 $ m $ 个文本串 $ t_1,t_2,\dots,t_m $ 。</p>
<p>设 $ c_{x,i} $ 为 $ s_i $ 在 $ t_x $ 中的出现次数，对于每一个 $ 1\le x\le m $ ：输出 $ \sum\limits_{i=1}^n3^{ic_i} \bmod 2^{32} $ 。</p>
<p>设 $ L=\max{\sum s,\sum t} $ 。</p>
<p>$ 1\le n,m\le 2\times 10^5 $</p>
<p>$ 1\le |s_i|,|t_i|\le 2\times 10^5 $</p>
<p>$ 1\le L\le 2\times 10^6 $</p>
<p>$ s_i $ 互不相同。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>首先来讲 $ L\le 3\times 10^5 $ 怎么做。</p>
<p>第一步是一个经典结论，$ |s_i| $ 的取值最多有 $ O(\sqrt{L}) $ 种。</p>
<p>也就是说，对于一个文本串 $ t_j $ ，最多会被匹配 $ |t_j|\sqrt{L} $ 次。</p>
<p>那么我们首先把 $ s $ 的AC自动机建出来，并记 $ nx_i $ 表示，节点 $ i $ 的所有祖先(不包括自己)中，深度最深的，至少对应了一个单词的节点。</p>
<p>那么对于每一个询问串 $ t_i $ ，我们还是先在自动机上匹配一遍。</p>
<p>正常计算匹配次数时，我们是暴力对ac自动机上所有节点做拓扑排序。</p>
<p>现在我们换一个思路，利用 $ nx $ 数组。</p>
<p>在上面匹配的时候，每到一个节点，就在nx树上dfs，并直接统计答案。</p>
<p>在dfs的过程中，若我们遍历了 $ x $ 次节点 $ i $，说明这个字符串被匹配了 $ x $ 遍。</p>
<p>这样的话，我们的时间复杂度就是 $ O(\text{匹配次数})=O(L^\frac{3}{2}) $ 的。</p>
<p>可以过 $ 50 $ 分，好耶。</p>
<p><del>我场上写的根号分治这部分半分钟都跑不出来</del></p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>首先正解有一个结论：对于所有问串，能匹配上至少一次的单词，的个数和不超过 $ O(L^{\frac{4}{3}}) $ 。</p>
<p>形式化地：$ \sum\limits_{i=1}^n\sum\limits_{j=1}^m[c_{j,i}\ne 0]=O(L^{\frac{4}{3}}) $ 。</p>
<p>好，我们来证一下。</p>
<p>对于 $ |s_i|\ge L^{\frac{1}{3}} $ 的单词 $ s_i $ ，这样的单词最多只有 $ L^{\frac{2}{3}} $ 个。</p>
<p>若 $ s_i $ 在文本串 $ t_j $ 中出现过，则 $ |t_j|\ge |s_i|\ge L^{\frac{1}{3}} $ ，这样的文本串也最多只有 $ O(L^{\frac{2}{3}}) $ 个。</p>
<p>所以这部分单词贡献的次数为 $ L^{\frac{2}{3}}\times L^{\frac{2}{3}}=O(L^{\frac{4}{3}}) $ </p>
<p>对于 $ |s_i|&lt; L^{\frac{1}{3}} $ 的单词 $ s_i $ ，在每一个文本串 $ t_j $ 中，一定最多只会匹配 $ |t_j|L^{\frac{1}{3}} $ 次，因为 $ t_j $ 只有 $ |t_j|L^{\frac{1}{3}} $ 个长度 $ &lt;L^{\frac{1}{3}} $ 的子串。</p>
<p>所以对于这种单词，贡献的次数最多也为 $ O(L^{\frac{4}{3}}) $ 。</p>
<p>这意味这什么呢？</p>
<p>对于我们上面的暴力做法，只要对于每一次询问，不经过重复的节点，那么时间复杂度就是 $ O(L^\frac{4}{3}) $ 的！</p>
<p>这个很简单，我们dfs的时候标一个vis，dfs的过程中直接遇到遍历过的节点，直接return掉。</p>
<p>可能有一个细节，就是这里要统计答案必须要拓扑排序，那么拓扑序如何确定呢？</p>
<p>比较简单，每一次dfs的时候，把这一条dfs的链，按照从深到浅的顺序，拼到当前拓扑序的<strong>前面</strong>，就是一个新的合法拓扑序</p>
<p>时间复杂度 $ O(L^{\frac{4}{3}}) $，官方题解说可以做到 $ O(L\sqrt{\log L}) $ ，但我折磨菜，显然不会。</p>
<p>这里统计答案需要快速计算 $ 3^x $ ，可以使用光速幂解决。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> uint=<span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">200001</span>;</span><br><span class="line">uint p1[<span class="number">200005</span>];</span><br><span class="line">uint p2[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> son[<span class="number">2000001</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> fail[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> nx[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> T[<span class="number">2000001</span>],top;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="type">int</span> tim;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">char</span> *s,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(!(*s))</span><br><span class="line">    &#123;</span><br><span class="line">        id[p]=i;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ins</span>(son[p][(*s)-<span class="string">&#x27;a&#x27;</span>],s+<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;fail[root]=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!son[root][i]) son[root][i]=root;</span><br><span class="line">        <span class="keyword">else</span> fail[son[root][i]]=root,que.<span class="built_in">push</span>(son[root][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(id[fail[u]]) nx[u]=fail[u];</span><br><span class="line">        <span class="keyword">else</span> nx[u]=nx[fail[u]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!son[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                son[u][i]=son[fail[u]][i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[son[u][i]]=son[fail[u]][i];</span><br><span class="line">            que.<span class="built_in">push</span>(son[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!num||vis[num]==tim) <span class="keyword">return</span> ;</span><br><span class="line">    vis[num]=tim;</span><br><span class="line">    <span class="built_in">dfs</span>(nx[num]);</span><br><span class="line">    T[++top]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">get</span><span class="params">(ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p2[v/L]*p1[v%L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>,ok=<span class="number">0</span>;tim++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now=son[now][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        v[now]++,<span class="built_in">dfs</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    uint ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> &amp;p=T[top--];</span><br><span class="line">        v[nx[p]]+=v[p];</span><br><span class="line">        <span class="keyword">if</span>(id[p]) ans+=<span class="built_in">get</span>((ll)id[p]*v[p]),ok++;</span><br><span class="line">        v[p]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+n-ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">ins</span>(root,s,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    p1[<span class="number">0</span>]=p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++) p1[i]=p1[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;i++) p2[i]=p2[i<span class="number">-1</span>]*p1[L];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>UOJ</category>
      </categories>
      <tags>
        <tag>ACAM</tag>
      </tags>
  </entry>
  <entry>
    <title>[省选联考2023]填数游戏</title>
    <url>/SXLK2023%E5%A1%AB%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>场上 $ 5min $ 秒掉所有特殊性质，然后在不知道正解是什么的情况下去冲了正解（？</p>
<p>我也不知道自己冲了个啥。</p>
<p>最后差点暴力打挂，不过幸好拿了 $ 40 $ 分。</p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Alice和Bob在玩填数游戏，每一个人需要填 $ n $ 个范围在 $ [1,m] $ 的整数。</p>
<p>Alice先填数，Alice的第 $ i $ 个数 $ a_i $只能是集合 $ S_i $ 中的一个。</p>
<p>Bob在看到Alice写完之后开始填数，Bob的第 $ i $ 个数 $ b_i　$ 只能是集合 $ T_i $ 的一个。</p>
<p>设 $ X=\sum\limits_{i=1}^n[a_i=b_i] $ 。</p>
<p>Alice希望最大化 $ X $ 。</p>
<p>Bob希望在 $ b_1,b_2,\dots,b_n $ 两两不同情况下最小化 $ X $ 。</p>
<p>若两个人都以最优操作填数，Bob是否有合法方案，有的话，最终的 $ X $ 是多少。</p>
<p>$ n,m\le 10^6 $</p>
<p>$ \sum n,\sum m\le 1.5\times 10^6 $  </p>
<p>$ 1\le |S_i|,|T_i|\le 2 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们看到集合大小最多是 $ 2 $ ，很容易能想到 2-SAT 。</p>
<p>但是可惜，这个算法显然是错的，2-SAT算法不能求最值（起码我没有遇到过。</p>
<p>但是我们会发现一个关键的地方，Bob填的数字互相不同，这是一个比较强的限制。</p>
<p>这个时候其实要用到一个（可能经典的）套路。</p>
<p>我们把一个值看作”点”，一个位置的(Bob的)填数方式看作”边”，建一个无向图出来。</p>
<p>特别地，对于 $ |T_i|=1 $ 的位置，我们给这一个元素建自环。</p>
<p>例如样例 $ 1 $ 的图就是一个 $ 1-2-3-4 $ 的链。</p>
<p>现在我们就可以发现，这个无向图被分成了若干个连通块，不同连通块之间显然没有影响。</p>
<p>Bob的一种方案实际上就是为每一条边定向，使得每一个点的入度不超过 $ 1 $ 。</p>
<p>所以我们对这些连通块进行分类讨论。</p>
<p>第一种情况是连通块的边数<strong>严格大于</strong>点数。</p>
<p>若这个连通块内有 $ x $ 条边，那么给边定向后，所有的点的入度之和必然为 $ x $ 。</p>
<p>但是点的数量不足 $ x $ ，一定有点的度数大于 $ 1 $ 。</p>
<p>所以一旦出现这种情况，Bob不存在合法方案。</p>
<h3 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h3><p>若一个连通块中，点数与边数相等，那么这个连通块是一棵基环树。</p>
<p>显然可以发现，每一个点的入度一定是 $ 1 $ 。</p>
<p>首先我们可以将所有边分成两类，环上的和树上的。</p>
<p>我们会发现，所有树上的边一定是从上往下连的（否则叶子入度为 $ 0 $）。</p>
<p>所以Alice知道Bob这些位置填了哪些数字，可以直接贪心。</p>
<p>所以只剩下环上的部分。</p>
<p>不难发现，环上的所有边，要么一起被定向为顺时针，要么一起被定向为逆时针，Bob只有这两种填数方式。</p>
<p>所以Bob会根据Alice的方案，选择两种中较小的哪个。</p>
<p>而Alice的目标是最大化 $ X $ ，所以她需要使这两种方案的最小值最大。</p>
<p>Alice的填数方案也可以看作是一种给边定向的方式。</p>
<p>所以我们枚举环上的所有边，计算出：Alice只能选择顺时针的边，只能选择逆时针的边，和顺时针逆时针都可以定向的边。</p>
<p>（显然，都不能定向的边p用没有）</p>
<p>那么Alice的方案其实是用第三种“万能边”优先填补前两种中较少的，再进行“平均分配”。</p>
<p>特别要注意一种情况，就是基环树的环是一个点的自环。</p>
<p>在这种情况下，Bob的方案只有一种，可能需要特判。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>若一个连通块中，点数恰好比边数多 $ 1 $，那么这个连通块是一棵树。</p>
<p>这就是本题中最复杂的情况。</p>
<p>还是一样，我们会发现恰好只有一个点度数为 $ 0 $ ，其余所有点度数都是 $ 1 $ 。</p>
<p>那么Bob的方案肯定只有”连通块大小”这么多种，我们不妨称这个度数为 $ 0 $ 的点为”中心”。</p>
<p>再来考虑Alice的方案。</p>
<p>假设Alice有两条”万能边” $ a-b $ 与 $ c-d $ ，这两条边被定向为 $ a\to b $ 与 $ c\to d $，并且 $ b,d $ 在 $ a\to c $ 的最短路上。</p>
<p>简单来说，就是有如下两条的”对冲”的边：</p>
<p><img src="/pic/SXLK2023_1.jpg" alt=""></p>
<p>我们会发现，若Bob的”中心”在A或C区域，则这两条边对答案有 $ 1 $ 的贡献，若”中心”在B区域，则有 $ 0 $ 的贡献。</p>
<p>但是如果我们将这两条边的方向都调换一下呢？</p>
<p><img src="/pic/SXLK2023_2.jpg" alt=""></p>
<p>我们会发现，若Bob的”中心”在A或C区域，则这两条边对答案有 $ 1 $ 的贡献，若”中心”在B区域，却有 $ 2 $ 的贡献。</p>
<p>显然，第二种方案是更优的。</p>
<p>也就是说，对于所有Alice的”万能边”，一定不会出现”对冲”的情况。</p>
<p>也就是说，Alice的方案也存在一个”中心”，使得所有“万能边”方向向外。</p>
<p>下来我们来考虑一个 $ O(n^2) $ 的做法。</p>
<p>首先我们枚举Alice的”中心”，以它为整棵树的根，来看Bob的”中心”选在哪个位置。</p>
<p>不难发现，当Bob的”中心”移动 $ 1 $ 的距离时，一定恰好使一条边变向，我们可以直接统计答案。</p>
<p>这个做法可以直接拿到 $ 52 $ 分。</p>
<p>设Alice的中心为 $ a $ ，Bob的”中心”在 $ b $ 时的答案为 $ ans_b $ 。</p>
<p>那我们可以直接维护 $ val_b=ans_b-ans_a $ 。</p>
<p>当 $ a $ 变化时，显然可以使用一个线段树维护 $ val $ ，这样的时间复杂度是 $ O(n\log n) $ 的。</p>
<p>但是我们还有一种时间复杂度更小的做法。</p>
<p>我们使用 $ mx_i $ 表示 $ b $ 在 $ i $ 子树内时，子树内的合法边数量比 $ a=b $ 时最大多多少，使用 $ se_i $ 表示次大值。</p>
<p>然后进行换根dp，以dfs的方式枚举 $ a $ 的位置，并统计答案。</p>
<p>最后时间复杂度是 $ O(\sum n+\sum m) $ 的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>换根的地方细节很多。</p>
<p>此外，我使用了并查集，时间复杂度并不是严格线性的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> head[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> nx[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> to[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> memu[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> memv[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> memw[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">bool</span> h[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> fad[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> S[<span class="number">1500001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> T[<span class="number">1500001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> mx[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> se[<span class="number">1500001</span>];</span><br><span class="line"><span class="type">int</span> cntm;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cntm=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>)*(m+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(m+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(m+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(memu,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(m+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(memv,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(m+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(memw,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(m+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ad</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cntm++;</span><br><span class="line">    to[cntm]=v;</span><br><span class="line">    nx[cntm]=head[u];</span><br><span class="line">    ::w[cntm]=w;</span><br><span class="line">    head[u]=cntm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ad</span>(u,v,w);</span><br><span class="line">    <span class="built_in">ad</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[num]==num) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">return</span> f[num]=<span class="built_in">find</span>(f[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[num];i;i=nx[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=to[i];</span><br><span class="line">        <span class="keyword">if</span>(p==fa[num]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[p]=num,fad[p]=w[i];</span><br><span class="line">        <span class="built_in">dfs1</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[w][<span class="number">0</span>]==u||S[w][<span class="number">1</span>]==u) ans|=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[w][<span class="number">0</span>]==v||S[w][<span class="number">1</span>]==v) ans|=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[num];i;i=nx[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=to[i];</span><br><span class="line">        <span class="keyword">if</span>(p==fa[num]||h[p]) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=(<span class="built_in">check</span>(p,num,fad[p])&amp;<span class="number">1</span>)+<span class="built_in">dfs2</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">run1</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;huan %d\n&quot;,s);</span></span><br><span class="line">    <span class="built_in">dfs1</span>(memu[s]);vc&lt;<span class="type">int</span>&gt;nod,wn;<span class="type">int</span> ed=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=memv[s];i;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        nod.<span class="built_in">push_back</span>(i);</span><br><span class="line">        wn.<span class="built_in">push_back</span>(fad[i]);</span><br><span class="line">        h[i]=<span class="number">1</span>;</span><br><span class="line">        ed++;</span><br><span class="line">    &#125;</span><br><span class="line">    wn[ed]=memw[s];</span><br><span class="line">    <span class="type">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>,num3=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:nod) ans+=<span class="built_in">dfs2</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(ed==<span class="number">0</span>) <span class="keyword">return</span> ans+(<span class="built_in">check</span>(nod[<span class="number">0</span>],nod[<span class="number">0</span>],wn[<span class="number">0</span>])&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ed;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="built_in">check</span>(nod[i],nod[i+<span class="number">1</span>],wn[i]);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>) num1++;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">2</span>) num2++;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">3</span>) num3++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="built_in">check</span>(nod[ed],nod[<span class="number">0</span>],wn[ed]);</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>) num1++;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span>) num2++;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">3</span>) num3++;</span><br><span class="line">    <span class="keyword">if</span>(num1&gt;num2) <span class="built_in">swap</span>(num1,num2);</span><br><span class="line">    <span class="keyword">if</span>(num3+num1&lt;num2) <span class="keyword">return</span> ans+num1+num3;</span><br><span class="line">    <span class="keyword">return</span> ans+num2+(num3-num2+num1)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> p,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,val=<span class="built_in">check</span>(num,p,w);</span><br><span class="line">    <span class="keyword">if</span>(val&gt;&gt;<span class="number">1</span>) ans++;</span><br><span class="line">    <span class="keyword">if</span>(val==<span class="number">1</span>) ans--;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> &amp;cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mx[num]=se[num]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[num];i;i=nx[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=to[i];</span><br><span class="line">        <span class="keyword">if</span>(p==fa[num]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[p]=num,fad[p]=w[i];</span><br><span class="line">        <span class="built_in">dfs3</span>(p,cnt);</span><br><span class="line">        cnt+=<span class="built_in">check</span>(p,num,fad[p])&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> val=<span class="built_in">get</span>(num,p,fad[p])+mx[p];</span><br><span class="line">        <span class="keyword">if</span>(val&gt;mx[num]) <span class="built_in">swap</span>(mx[num],val);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;se[num]) <span class="built_in">swap</span>(se[num],val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs4</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=mx[num];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[num];i;i=nx[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=to[i];</span><br><span class="line">        <span class="keyword">if</span>(p==fa[num]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mem1=mx[num],mem2=se[num],mem3=mx[p],mem4=se[p];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val=<span class="built_in">get</span>(num,p,fad[p])+mx[p];</span><br><span class="line">        <span class="keyword">if</span>(val==mx[num]) <span class="built_in">swap</span>(mx[num],se[num]);</span><br><span class="line"></span><br><span class="line">        val=<span class="built_in">get</span>(p,num,fad[p])+mx[num];</span><br><span class="line">        <span class="keyword">if</span>(val&gt;mx[p]) <span class="built_in">swap</span>(mx[p],val);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;se[p]) <span class="built_in">swap</span>(se[p],val);</span><br><span class="line"></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs4</span>(p)+(<span class="built_in">check</span>(p,num,fad[p])&amp;<span class="number">1</span>)-(<span class="built_in">check</span>(num,p,fad[p])&amp;<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        mx[num]=mem1,se[num]=mem2,mx[p]=mem3,se[p]=mem4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">run2</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> all=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs3</span>(s,all);</span><br><span class="line">    <span class="keyword">return</span> all-<span class="built_in">dfs4</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> TT=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(TT--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">read</span>();</span><br><span class="line">            S[i][<span class="number">0</span>]=<span class="built_in">read</span>();</span><br><span class="line">            S[i][<span class="number">1</span>]=k==<span class="number">2</span>?<span class="built_in">read</span>():S[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">read</span>();</span><br><span class="line">            T[i][<span class="number">0</span>]=<span class="built_in">read</span>();</span><br><span class="line">            T[i][<span class="number">1</span>]=k==<span class="number">2</span>?<span class="built_in">read</span>():T[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">find</span>(T[i][<span class="number">0</span>]),v=<span class="built_in">find</span>(T[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(u!=v)</span><br><span class="line">            &#123;</span><br><span class="line">                f[v]=u;</span><br><span class="line">                <span class="keyword">if</span>(memu[u]&amp;&amp;memu[v]) flag=<span class="number">0</span>;</span><br><span class="line">                memu[u]|=memu[v];</span><br><span class="line">                memv[u]|=memv[v];</span><br><span class="line">                memw[u]|=memw[v];</span><br><span class="line">                <span class="built_in">add</span>(T[i][<span class="number">0</span>],T[i][<span class="number">1</span>],i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(memu[u]) flag=<span class="number">0</span>;</span><br><span class="line">                memu[u]=T[i][<span class="number">0</span>];</span><br><span class="line">                memv[u]=T[i][<span class="number">1</span>];</span><br><span class="line">                memw[u]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(<span class="built_in">find</span>(i)==i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(memu[i]) ans+=<span class="built_in">run1</span>(i);</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="built_in">run2</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title>[USACO23JAN] Mana Collection P</title>
    <url>/USACO23JP2/</url>
    <content><![CDATA[<p>模拟赛里遇到的，差一点做出来</p>
<p>感觉是好题</p>
<p><a href="https://www.luogu.com.cn/problem/P9020">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个 $ n $ 个点 $ m $ 条边的有向图，边有边权。</p>
<p>每一个点都是一个井，第 $ i $ 个井每秒会出现 $ m_i $ 的法力，并积攒在这个井里。</p>
<p>wyr每一时刻可以选择站在原地不动或者沿着一条边走动（所用的时间为这条边的边权）。</p>
<p>当wyr到达一个井的时候，他就可以把这个井目前的所有法力收集起来。</p>
<p>进行 $ q $ 次询问，每一次询问给出 $ s,e $ ，wyr想知道如果他从任何一个节点出发，经过 $ s $ 秒后到达点 $ e $ ，最多能够收集多少法力。</p>
<p>$ 1\le n\le 18 $</p>
<p>$ 1\le q\le 2\times 10^5 $</p>
<p>$ 1\le s\le 10^9 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>感觉是小结论题，但是结论都不算难想。</p>
<p>首先我们发现，假如一个节点被经过多次，那么显然只有最后一次经过是有用的，因为在这个节点收集的法力数量之和最后一次在这个节点的时间有关。</p>
<p>所以我们可以强制规定每一个节点只被经过一次，预处理的时候跑一个Floyd就好了。</p>
<p>然后继续找结论，我们会发现，wyr只会选择在起点停留。</p>
<p>如果wyr在中途的某个点停留了，我们完全可以把停留的时间放到起点，这样显然更优。</p>
<p>考虑进行dp，设 $ dp_{sta,e,t} $ 表示目前经过了 $ sta $ 这些点，最后一个经过的点为 $ e $ 且总时间为 $ t $ ，最多能收集多少法力。</p>
<p>$ t $ 这一维范围为 $ 10^9 $ ，所以想要dp的话，一定要把时间这一个维度压掉。</p>
<p>想要压掉时间这一个维度，首先会面临一个问题，那就是我们现在往路径后面新加入一个点，我们无法计算新得到的法力。</p>
<p>那么我们换一下状态，设 $ dp_{sta,e} $ 表示会有多少法力浪费掉，$ tim_{sta,e} $ 表示这样走总时间是多少。</p>
<p>那么现在对于每一组询问，我们便得到答案 $ \max_{sta}\{tS_{sta}-dp_{sta,e}\} $ 。</p>
<p>其中 $ S_{sta}=\sum\limits_{j\in sta}m_j $ ，即 $ sta $ 中所有点，一秒内产生的法力和。</p>
<p>这里可能会有一点小问题，在dp的过程中，法力浪费最少的方案，并不一定是最短路。</p>
<p>那么假如存在一个状态 $ sta $ ，有 $ tim_{sta,e}&gt;t $ ，但是最短路 $ dis_{sta,e}\le t $ ，答案是不是就算大了呢？</p>
<p>其实答案并不会变大。</p>
<p>因为如果有 $ tim_{sta,e}&gt;t $ ，此时在起点收集到的法力数量是负数，那么一定就存在一个更优的方案，所以答案不会算大。</p>
<p>好，这个样子我们就得到了一个时间复杂度为 $ O(2^nn^2+q2^n) $ 的算法，原比赛应该可以拿到 $ \dfrac{7}{12} $ 的分数。</p>
<p>考虑优化后面查询答案的过程。</p>
<p>从上面的答案可以看出，对于一个状态 $ sta $ 和终点 $ e $ ，它的答案实际上是一个关于 $ t $ 的函数 $ f(t)=tS_{sta}-dp_{sta,e} $ ，其中斜率 $ k=S_{sta} $ 和截距 $ b=-dp_{sta,e} $ 均为定值。</p>
<p>所以对于一组询问，我们实际上在查所有 $ sta $ 构成的凸包上，对应横坐标的点。</p>
<p>使用李超线段树或者单调栈维护凸包即可。</p>
<p>我是用的是单调栈，时间复杂度为 $ O(2^nn^2) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sta[<span class="number">262144</span>],top;</span><br><span class="line">ll P[<span class="number">262144</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> e[<span class="number">200001</span>];</span><br><span class="line">ll qans[<span class="number">200001</span>];</span><br><span class="line">ll dis[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">ll tim[<span class="number">262144</span>][<span class="number">18</span>];</span><br><span class="line">ll dp[<span class="number">262144</span>][<span class="number">18</span>];</span><br><span class="line">ll f[<span class="number">262144</span>];</span><br><span class="line">ll s[<span class="number">262144</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">262144</span>];</span><br><span class="line">ll a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">131072</span>;i;i&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(ans+i&lt;=top&amp;&amp;P[ans+i]&lt;=t) ans+=i;</span><br><span class="line">    <span class="keyword">return</span> sta[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>,a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++) <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) s[j]+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>()<span class="number">-1</span>,v=<span class="built_in">read</span>()<span class="number">-1</span>;</span><br><span class="line">        dis[u][v]=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        dis[i][k]=<span class="built_in">min</span>(dis[i][k],dis[i][j]+dis[j][k]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) <span class="keyword">if</span>(j!=k&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;k)))</span><br><span class="line">        &#123;</span><br><span class="line">            __int128 val=dp[i^(<span class="number">1</span>&lt;&lt;j)][k]+(__int128)dis[k][j]*s[i^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">            <span class="keyword">if</span>(val&lt;dp[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                tim[i][j]=tim[i^(<span class="number">1</span>&lt;&lt;j)][k]+dis[k][j];</span><br><span class="line">                dp[i][j]=val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) id[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(id,id+(<span class="number">1</span>&lt;&lt;n),[](<span class="type">int</span> a,<span class="type">int</span> b)&#123; <span class="keyword">return</span> s[a]&lt;s[b];&#125;);</span><br><span class="line"></span><br><span class="line">    q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) t[i]=<span class="built_in">read</span>(),e[i]=<span class="built_in">read</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//处理所有以i为结尾的询问</span></span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;(<span class="number">1</span>&lt;&lt;n);p++) <span class="keyword">if</span>(id[p]&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=id[p];<span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;%d : y=%lldx-%lld\n&quot;,j,s[j],dp[j][i]);</span></span><br><span class="line">            <span class="keyword">while</span>(top)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> &amp;q=sta[top];</span><br><span class="line">                <span class="keyword">if</span>(dp[q][i]&gt;=dp[j][i]) top--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j]==s[q])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ll x=(dp[j][i]-dp[q][i]+s[j]-s[q]<span class="number">-1</span>)/(s[j]-s[q]);</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;=P[top]) top--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;                    </span><br><span class="line">                <span class="keyword">if</span>(!top) P[top+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> q=sta[top];</span><br><span class="line">                    P[top+<span class="number">1</span>]=(dp[j][i]-dp[q][i]+s[j]-s[q]<span class="number">-1</span>)/(s[j]-s[q]);</span><br><span class="line">                &#125;</span><br><span class="line">                sta[++top]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++) <span class="keyword">if</span>(e[j]==i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=<span class="built_in">get</span>(t[j]);</span><br><span class="line">            <span class="comment">// printf(&quot;ques %d : from %d\n&quot;,j,v);</span></span><br><span class="line">            qans[j]=t[j]*s[v]-dp[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,qans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>dp</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>[USACO21FEB] Stone Game G</title>
    <url>/USACO21F_G1/</url>
    <content><![CDATA[<p>一道结论小博弈</p>
<p>感觉挺难想，但是luogu上是绿</p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://www.luogu.com.cn/problem/P7413">题目链接</a></p>
<p>现在有 $ n $ 堆石子和两个人 Alice、Bob，第 $ i $ 堆石子有 $ a_i $ 个。</p>
<p>Alice 与 Bob 轮流取石子，第一个人第一次可以任选一堆，取任意（显然不能取成负数）石子。后面每一次取石子的个数必须是前一次的正整数倍（仍然为人选一堆），谁不能取谁输。</p>
<p>问 Alice 开局有多少种方案使得自己胜利，选取不同的堆，或石子数量不同，都算不同的方案。</p>
<p>$ 1\le n\le 10^5 $</p>
<p>$ 1\le a_i \le 10^6 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><del>啊，结论题</del></p>
<p>这题看起来就不好 SG 函数，所以优先考虑什么情况有解。</p>
<p>首先发现，若在第 $ x $ 个堆里拿了 $ y $ 个石子，那么相当于先令所有 $ 1\le i \le n : a_i\gets \left\lfloor\dfrac{a_i}{y}\right\rfloor $ ，然后令 $ a_x\gets a_x-1 $</p>
<p>这样我们就可以忽略，每一次拿取数量必须是前一次倍数的限制。</p>
<p>为方便表示，我们设 $ c_x $ 表示，恰有 $ x $ 个石子的堆的数量。</p>
<p><del>不·</del>容易发现，若对于每一个数字 $ x $ ，都有 $ 2|c_x $ ，那么后手必胜。若先手在一个有 $ a $ 个石子的堆里拿走 $ b $ 个，那么后手一定能再找到一个恰有 $ a $ 个石子的堆，然后拿走 $ b $ 个石子。这样后手永远可以继续操作。</p>
<p>对于剩下的情况，一定为先手必胜。先手可以找到一个最大的 $ x $ ，使得 $ 2\nmid c_x $ ，然后先手拿空任何一个有 $ x $ 个石子的堆，就可以转成上面的情况。</p>
<p>知道了如何判断局面，那么考虑Alice如何进行操作。</p>
<p>发现题目实际上在问，Alice开局有多少种拿法，使得局面变为先手必败。</p>
<p>首先考虑枚举 $ s $ ，表示 Alice 第一次拿几个石子，这样我们就知道了 $ c’_x=\sum\limits_{\lfloor\frac{y}{s}\rfloor =x}c_y $ 。</p>
<p>现在我们的目标是：选取一个数 $ x $ ，令 $ c’_x\gets c’_x-1,c’_{x-1}\gets c’_{x-1}+1 $ ，使得对于所有 $ i\ge 1 $ ，有 $ 2|c’_i $ ，方案数为 $ c’_x $ 。</p>
<p>所以我们进行分类讨论：</p>
<ol>
<li><p>初始不存在 $ y $ 使得 $ 2\nmid c’_y $ ，那么显然无解。因为这样会导致 $ 2\nmid c’_{y} $ 。</p>
</li>
<li><p>初始恰存在一个 $ y $ 使得 $ 2\nmid c’_y $ </p>
<p>若 $ y=1 $ ，显然满足；</p>
<p>若 $ y&gt;1 $ ，则会导致 $ 2\nmid c’_{y-1} $ ，不满足。</p>
</li>
<li><p>初始恰存在两个数 $ y_1&lt;y_2 $ 满足 $ 2\nmid c’_y $ </p>
<p>若 $ y_2=y_1+1 $ ，显然满足；</p>
<p>若 $ y_2\ne y_1+1 $ ，则不满足。</p>
</li>
<li><p>若至少存在三个 $ y $ 使得 $ 2\nmid c’_y $ ，显然无解。</p>
</li>
</ol>
<p>如果存在 $ x $ ，那么将答案加上初始的 $ c’_x $ 即可。</p>
<p>时间复杂度 $ O(n+a\ln a) $ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> len,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[id*len+len<span class="number">-1</span>]-pre[id*len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>(),pre[a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000000</span>;i++) pre[i]+=pre[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> wh1=<span class="number">0</span>,wh2=<span class="number">0</span>;<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*j&lt;=<span class="number">1000000</span>;j++) <span class="keyword">if</span>(<span class="built_in">get</span>(i,j)&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!wh1) wh1=j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!wh2) wh2=j;</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wh2&amp;&amp;wh2==wh1+<span class="number">1</span>) ans+=<span class="built_in">get</span>(i,wh2);</span><br><span class="line">            <span class="keyword">if</span>(!wh2&amp;&amp;wh1==<span class="number">1</span>) ans+=<span class="built_in">get</span>(i,wh1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title>[UER#11]科考工作</title>
    <url>/UER11%E7%A7%91%E8%80%83%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>一个经典的modular subset背包，<del>但是我之前完全没听说过这个啊</del></p>
<p>但是不影响这是喵喵题。</p>
<p><a href="https://uoj.ac/contest/79/problem/771">题目链接</a></p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个<strong>质数</strong> $ n $ 和 $ 2n-1 $ 个在 $ [0,n] $ 间的整数。</p>
<p>要求从中挑出 $ n $ 个数，使得和为 $ n $ 的倍数。</p>
<p>构造方案或判断无解。</p>
<p>$ n\le 3\times 10^5 $</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="有解证明"><a href="#有解证明" class="headerlink" title="有解证明"></a>有解证明</h3><p>可以证明给定条件下一定有解，证明如下：</p>
<p>首先若某一种数字出现次数 $ \ge n $ ，则直接选 $ n $ 个这个数字即可。</p>
<p>否则的话，我们每一次将出现次数最大和次大的数字放在一起配一对。</p>
<p>这样所有数字会被配成 $ n-1 $ 对。</p>
<p>可以证明，配成的每一对中，同一对的两个数字不同。</p>
<p>现在设剩余的单点为 $ v $ ，配成的第 $ i $ 对为 $ (a_i,b_i) $ 。</p>
<p>考虑构造一个方案，使得每一对里面恰好选了一个数字，并且单点恰好被选了。</p>
<p>显然，这样选的所有方案一定恰好选了 $ n $ 个数字（废话</p>
<p>下面证明，$ [0,n) $ 间的所有整数，都存在至少一种这样的构造。</p>
<p>首先，显然存在一个方案，是 $ (v+\sum a_i)\bmod n $ ，我们定义集合 $ S_0=\{(v+\sum a)\bmod n\} $ 。</p>
<hr>
<p>好，我们发现这唯一的方案中，如果使用 $ b_1 $ 替换 $ a_1 $ ，那么会多出一个方案。</p>
<p>那么现在我们就有两个方案，$ S_1=S_0\cup\{\text{新方案}\} $，有 $ |S_1|\ge |S_0|+1 $</p>
<p>那再来看第二对数字 $ (a_2,b_2) $ ，我们发现 $ S_1 $ 中的方案都使用了 $ a_2 $ 而没有使用 $ b_2 $ 。</p>
<p>那么对于部分 $ S_1 $ 中的方案，使用 $ b_2 $ 替换 $ a_2 $，又会得到新方案，我们定义目前所有的方案为 $ S_2 $ 。</p>
<p>……</p>
<p>对于一个方案的集合 $ S_{i-1} $ 来说，我们发现他们在第 $ i $ 对中，都使用了 $ a_i $ 而不是 $ b_i $ 。</p>
<p>那么我们就可以将部分 $ S_{i-1} $ 中的方案拿出来，用 $ b_i $ 替换 $ a_i $ ，得到新的方案。</p>
<p>那么我们就可以令当前所有方案构成的集合为 $ S_i $ 。</p>
<p>那么，这一步会产生多少新方案呢？</p>
<p>假设，这一步不会产生新方案，令 $ v_i=(b_i-a_i+n)\bmod n $ 。</p>
<p>因为 $ |S_{i-1}|\ge |S_{i-2}|\ge\dots\ge|S_0| $ ，所以一定存在一个最小的 $ x $ 使得 $ x\in S_{i-1} $ 。</p>
<p>由于这一步不会产生新方案，那么也就是说 $ (x+v)\bmod n\in S_{i-1} $ 。</p>
<p>又因为 $ (x+v)\bmod n $ 也在原来的方案中，并且这种方案替换了后也不会产生新方案，说明 $ (x+2v)\bmod n\in S_{i-1} $ 。</p>
<p>同理，可以证明对于任意整数 $ i $ ，$ (x+iv)\bmod n\in S_{i-1} $ 。</p>
<p>因为 $ n $ 为一个质数，所以此时一定有 $ S_{i-1}=[0,n)\cap\mathbf{R} $ 。</p>
<p>换句话说，若此时 $ S_{i-1} $ 不是满集，则替换后，最少会多出一种方案。</p>
<p>即 $ |S_i|\ge\min\{|S_{i-1}|+1,n\}\ge i+1 $  </p>
<p>则 $ |S_{n-1}|\ge n $ 。</p>
<p>也就是说，我们仅用这种构造，可以构造出所有的数字！</p>
<p>所以一定有解。</p>
<h3 id="构造方案"><a href="#构造方案" class="headerlink" title="构造方案"></a>构造方案</h3><p>首先一个显然的解法，根据上面的分组完之后，使用bitset优化背包，并记录方案。</p>
<p>时间复杂度是 $ O(\dfrac{n^2}{w}) $ 的，期望得分 $ 90 $ 。</p>
<p>这样暴力转移太不优雅了，那么根据我们上面的过程，我们能不能每一次只转移一个值呢？</p>
<p>设 $ dp_{i,j} $ 表示选完了前 $ i $ 对数，使得所有数的和模 $ n $ 余 $ j $ 是否可行。</p>
<p>那么我们上面所说的，其实就是令所有 $ j $ ，$ dp_{i-1,j}\to dp_{i,(j+a_i)\bmod n} $。</p>
<p>并选出一个 $ j $ 进行 $ dp_{i-1,j}\to dp_{i,(j+b_i)\bmod n} $ 。</p>
<p>这里的主要问题，在于找到一个合法的 $ j $ 。</p>
<p>我们发现，在进行第二种转移前，一定有 $ dp_{i,(j+b_i)\bmod n}=0 $ ，即 $ dp_{i-1,(j+b_i-a_i)\bmod n}=0 $ 。</p>
<p>且必须要有 $ dp_{i-1,j}=1 $ 。</p>
<p>（从以下开始，我们使用 $ dp_{i,j}$ 表示原来的 $ dp_{i,j\bmod n} $）</p>
<p>考虑找到一个最小的 $ j $ 满足 $ dp_{i-1,j}\ne dp_{i-1,j+b_i-a_i} $，考虑二分判断是否有 $ j\in [0,x] $ 。</p>
<p>则 $ j\in[0,x]\Longleftrightarrow dp_{i-1,[0,x]}\ne dp_{i-1,[b_i-a_i,x+b_i-a_i]}$ 。</p>
<p>我们可以使用树状数组维护哈希值，来进行判断两个区间是否相等。</p>
<p>但是这样做可能会有一个问题，就是我们找到的 $ j $ 可能出现 $ dp_{i-1,j}=0,dp_{i-1,j+b_i-a_i}=1 $ 的情况。</p>
<p>这个时候我们可以稍微转换一下思路，默认我们之前的方案全部选择了 $ b_i $ ，只有这一个方案选择了 $ a_i $ ，这样就可以使得后者向前者转移（实际上可以看成交换了 $ a_i $ 与 $ b_i $ 的值）。</p>
<p>这样的话，对于每一个 $ i $ ，我们恰好只转移了一个地方，但是找这个地方所用的时间复杂度为 $ O(\log^2n) $ 。</p>
<p>这个dp方法构造方案是容易的，总时间复杂度为 $ O(n\log^2n) $ 。</p>
<p><del>真是一道喵喵题</del></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f3fll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[<span class="number">300001</span>];</span><br><span class="line"><span class="type">bool</span> dp[<span class="number">300001</span>];</span><br><span class="line"><span class="type">bool</span> def[<span class="number">300001</span>];</span><br><span class="line">ll p[<span class="number">600001</span>];</span><br><span class="line">ll t[<span class="number">600001</span>];</span><br><span class="line">vc&lt;<span class="type">int</span>&gt;pos[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> now[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">300001</span>];</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">choose</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pos[v][now[v]++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pi&gt;que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) que.<span class="built_in">push</span>(<span class="built_in">pi</span>(cnt[i],i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> v=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        a[i]=u.second,b[i]=v.second;</span><br><span class="line">        <span class="keyword">if</span>(u.first!=<span class="number">1</span>) que.<span class="built_in">push</span>(<span class="built_in">pi</span>(u.first<span class="number">-1</span>,u.second));</span><br><span class="line">        <span class="keyword">if</span>(v.first!=<span class="number">1</span>) que.<span class="built_in">push</span>(<span class="built_in">pi</span>(v.first<span class="number">-1</span>,v.second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">choose</span>(que.<span class="built_in">top</span>().second);</span><br><span class="line">    sum=que.<span class="built_in">top</span>().second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;(-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[id]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x=id+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=<span class="number">2</span>*n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]=(t[x]+p[id])%mod;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    x=id+n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=<span class="number">2</span>*n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]=(t[x]+p[id+n])%mod;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+t[x])%mod;</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">get</span>(r)-<span class="built_in">get</span>(l<span class="number">-1</span>)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">262144</span>;i;i&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(ans+i&lt;n&amp;&amp;<span class="built_in">get</span>(<span class="number">0</span>,ans+i)*p[v]%mod==<span class="built_in">get</span>(v,ans+v+i)) ans+=i;</span><br><span class="line">    <span class="keyword">return</span> (ans+<span class="number">1</span>)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(c[i]==j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(def[i]==<span class="number">0</span>) <span class="built_in">choose</span>(b[i]),<span class="built_in">output</span>(i<span class="number">-1</span>,(j-b[i]+a[i]+n)%n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">choose</span>(a[i]),<span class="built_in">output</span>(i<span class="number">-1</span>,(j+b[i]-a[i]+n)%n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(def[i]==<span class="number">0</span>) <span class="built_in">choose</span>(a[i]),<span class="built_in">output</span>(i<span class="number">-1</span>,j);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">choose</span>(b[i]),<span class="built_in">output</span>(i<span class="number">-1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) p[i]=p[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=(b[i]-a[i]+n)%n;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">check</span>(v);</span><br><span class="line">        <span class="type">int</span> to=(w+v)%n;</span><br><span class="line">        <span class="keyword">if</span>(dp[w])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//w-&gt;to</span></span><br><span class="line">            def[i]=<span class="number">0</span>,sum=(sum+a[i])%n;</span><br><span class="line">            c[i]=to;</span><br><span class="line">            <span class="built_in">Add</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//to-&gt;w</span></span><br><span class="line">            def[i]=<span class="number">1</span>,sum=(sum+b[i])%n;</span><br><span class="line">            c[i]=w;</span><br><span class="line">            <span class="built_in">Add</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">output</span>(n<span class="number">-1</span>,(n-sum)%n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">read</span>()%n;</span><br><span class="line">        pos[a].<span class="built_in">push_back</span>(i);</span><br><span class="line">        cnt[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&gt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="built_in">choose</span>(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢观看！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>UOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树状数组</tag>
        <tag>dp</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2023游记</title>
    <url>/WC2023%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>很开心的一次WC，感觉不错。</p>
<span id="more"></span>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-1">Day $ 1 $</a></li><li class="tab"><a href="#unique-name-2">Day $ 2 $</a></li><li class="tab"><a href="#unique-name-3">Day $ 3 $</a></li><li class="tab"><a href="#unique-name-4">Day $ 4 $</a></li><li class="tab"><a href="#unique-name-5">Day $ 5 $</a></li><li class="tab"><a href="#unique-name-6">Day $ 6 $</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-1"><p>早上是曹老师的课，介绍了一个软件，大概是用代码来证明定理。</p>
<p>感觉特别有意思，可以避免假做法（</p>
<p>玩了一中午，最后自己定义了自然数，并且证明了加法交换律、结合律等一堆东西。</p>
<p>下午是周航锐的课，讲了一堆妙妙题。</p>
<p>前面一直在听，基本都听懂了。</p>
<p>后面就有点跟不上了。</p>
<p>晚上一直在玩上午讲的软件。</p></div><div class="tab-pane" id="unique-name-2"><p>早上是djq的课，讲的是网络流。</p>
<p>为什么djq的声音跟我想象的不太一样（</p>
<p>听了一部分，然后就走神了。</p>
<p>下午直接旷了WC，回班开联欢晚会。</p>
<p>吃了一堆吃的，贼开心。</p>
<p>晚上打ARC，成功把大号打上 $ 2300 $ 。</p></div><div class="tab-pane" id="unique-name-3"><p>早上是yyl的课，讲如何用tuack命题。</p>
<p>上课了才发现，tuack是个工具。</p>
<p>感觉和我关系不大，<del>于是开始自己用C++做游戏</del>。</p>
<p>下午是tsx的课，还是一样，听了一会，然后就走神了。</p>
<p>晚上打CF，这把不愧是阴间场。</p>
<p>E题算法不难，但是及其难打，我直到两个小时多才过。</p>
<p>F一眼看出是区间dp，但是还是不会（</p>
<p>最后十几分钟突然感觉会了，赶紧开打。</p>
<p>最后五分钟过了F，大号成功上红。</p></div><div class="tab-pane" id="unique-name-4"><p>上午是zjk的课，还是一样，听了一会，然后就走神了。</p>
<p>（为啥每次都是这句话。</p>
<p>下午直接没有听，进入摆烂状态。</p>
<p>颓了一晚上，很早就睡了。</p></div><div class="tab-pane" id="unique-name-5"><p>早上 $ 9 $ 点到 $ 14 $ 点考试。</p>
<p>开局先把三道题读了一遍，AB是传统题，C是交互。</p>
<p>A题刚看上去特别有意思，然后发现题读错了（</p>
<p>然后想了一会，发现题又读错了（</p>
<p>然后一眼秒掉前 $ 3 $ 个点，会 $ 15 $ 分（就是这么菜</p>
<p>果断看B，然后发现我不会第一个点 $ n=9 $ 。</p>
<p>我第一次想的做法是 $ O(2^nn^4\times \dfrac{2000}{n}) $ ，算下来将近 $ 7\times 10^8 $ 。</p>
<p>然后发现直接dfs就行，时间复杂度是 $ O(n!\times \dfrac{2000}{n}) $ ，喜提 $ 8 $ 分（就是这么菜。</p>
<p>发现 $ m=1 $ 几行就能打完，又多了 $ 16 $ 分。</p>
<p>然后我没有想到乱搞，就拿了 $ 24 $ 分。</p>
<p>然后去看C，我觉得 $ O(n^2) $ 我应该会做，这就有 $ 36 $ 分。</p>
<p>我还一眼秒掉了链（没错，这个是假做法，但是我过了一会就发现了。</p>
<p>这个时候已经过了差不多 $ 3 $ 个小时了，我就开始打代码。</p>
<p>我觉得B很好打，于是先打B，写+调一共 $ 20min $ 左右，dfs就打完了。</p>
<p>然后几分钟码完了 $ m=1 $ ，预计得分 $ 24 $。</p>
<p>然后就去打C，想了好久具体怎么做。</p>
<p>最后想到的就是，先调整边的顺序，使得对于所有边，权值从上往下递增。</p>
<p>这个换一换，然后问一问，大概用了 $ \dfrac{n^2}{2} $ 次操作。</p>
<p>然后就是对于每两个点，我询问一下，得到他们是否有祖宗关系，然后就能确定每一个点的父亲。</p>
<p>这个大概又用了 $ \dfrac{n^2}{2} $ 次操作。</p>
<p>最后花了将近 $ 1h $ ，把代码写完调完，预计得分是 $ 36 $ 。</p>
<p>然后去想A，发现对于横轴和纵轴，每一个位置可以写成一个值，某一个格子的值，就是对应横坐标的值+纵坐标的值。</p>
<p>并且横坐标、纵坐标上的值都是单调的。</p>
<p>这样子的话，我如果暴力维护这个楼梯，对于每一个询问进行双指针，时间复杂度就是 $ O(ma+mb) $ 。</p>
<p>开心的看了数据范围，发现还是 $ 15 $ 分（</p>
<p>然后发现可以进行离散化，离散化之后的每一个点，对应的值就是一段区间，一样可以进行双指针，就是构造方案有一点点细节。</p>
<p>想+写+调花了好久，最后写完了代码，因为没有发spj，我只测了小样例。</p>
<p>时间复杂度是 $ O(m^2) $ ，预计得分是 $ 40 $ 。</p>
<p>这个时候就剩下十几分钟了，检查了一下文件读写。</p>
<p>晚上讲题，没有心情听。</p></div><div class="tab-pane" id="unique-name-6"><p>$ 14:00 $ 到 $ 16:30 $ 闭幕式、颁奖。</p>
<p>看他们表演了几个节目。</p>
<p>然后就听到一个人说了牌子线。</p>
<p>铜牌 $ 24 $ ，银牌 $ 56 $ ，金牌 $ 89 $ ，这个时候还是有点开心，心情更紧张了。</p>
<p>毕竟只要我不挂分，不被卡常，应该就能拿到金。</p>
<p>这个时候有点后悔没有拍A。</p>
<p>读完银牌没有读到我，我就觉得应该是金了，因为我把C拍过了，$ 36 $ 分应该没有问题。</p>
<p>最后喜提 $ 95 $ 分，拿到了金牌。</p>
<p>之后微信群里发了具体成绩。</p>
<p>我找到了自己，发现成绩是 $ 35+24+36=95 $ ，A被卡了 $ 5 $ 分的常，BC两题和我预计一样。</p>
<p>（Update：最后发现是A没有开long long挂了 $ 5 $ 分）</p>
<p>开心拿金。</p></div></div></div>
<p>然后过了一个好年，颓疯了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>刷题记录</title>
    <url>/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b9cb6746ca272c68a4c3a91128b550db514130b95eea2bfd44b18df976e17961">f16f040370811205e56f47ff1cb540257c600097d77bbd80a4ecc4c0a590080f09162ef2f712cd7048baafa11ef08a0541db0fc48a8394aac106ed2177e3d7ca3d4785df2786aeafed24f486358714d7215bdb8cf6eb4549faf145572e638a7fb39488c9fe5e08f205de935c6adb9464d65a6a91190f27048ef3b8624a8e66b819e3d5a8717951164216eb59bdbb750c5bb7bc8dd99697d60118a1b985966d64d6a6c3f8f7fa8bc5788e30bd3a135e1bb56fa10cc50aa81913096ab86b5d5d98fd01c73e66e2dd57fdecd00a51e17614bb6b8ef3bd54455ff4bc967f57b51e295a687b0a622f091e04003deb9824c84a5aadd0e12d14adcd81d11142fa131f1b8ab0dff491886ed2a43ec45e48dc610ce1f2780d48b4c8e56557529b84b140ab99a243472f5ababa96e3b77218a61811547473aba739e928921e23dec89757fa10cc43438abba5ceab95d4e9ad4e05d342fa42076f0b51b8860329160d8e1c2144da94b72df049d04b12397881f201a1813eaf40b46457f4acaf781d893953fe3403835832a1c8e123e4ea5385f997bc7d752d008a21640b16d7be22ef6ad22b413418fc780cb34957aba9ae6dff2f1cf26ed8f83fc16b38ad1f84e2d76b85052ed4272942ee03f01fcd265c062030a44cd63f3c9b679ed2a026298ab1b8cc5f8d1808b317c123271de41eae40c06c045dd73ead148a9ce092183470341716d17205d5e68abeba8dd9f9d02092a98ebb5565393899616cba663317ed4d41fb79ec55f1c269d364a1f1d3923213a394c7455571d4bf8576510bab5b95122bb3d96f00058901737f3292da158c72da9e675c1fb8b4b5497fb809b2d13a065d0113b02538d1f0dd321054127228c7077550cd7f39f9435c03f1925688c1d98d7757d6016fbbd0ea3a12ff5af8b2e91ae9c4bc23138eb73fe215ba8364c709a632328c10fc6ae63f34490a7fbde19eb0afc9def9a5464ae6e5ae7aedc253eade397cafd7a49f9e2bdb1b85cfa18b6ebe78652257297d8a6a30c23098e871fa447f71a125701755f2f6fce8190b8d2861896e0e85df259a29293c8e7615796daf6683eb93829eddc094cf6e823ce97d849176ab0795c47b78d25ddc87a32b93827d7edb60dab02e5ed392235f4b2acf78d8e7dfe4eee7f21fc3cd9beae50895f1e70540ad9a5c86e1dade1c7fff42e29d11aeb1539c8a242453e177a03efd202ffce3692513b0bc5c1a1e48b232e2469f236ed4d2b466c0af56feb5ab00a146bfd7aaa5095e57aaaa6da7d436720d30385e6ec0637c4dbc4ec3530f11cba7b081ed24d897e3b79bf3db637e1e53e17c8f034615a6a70bdfe5f33228362a22aa4aa5b9028fc37e2736bf3065c1f2748d34ef8ef0e8babbe90cd39339c6b7900cb874c9cc6285cefde4f4f7d64b58e7b0cfb26deba7327bfbff3d27f2362d5c55d39d6ec3a9bbd910db1ab20a1f552315581f0006078614a38db0c3ed5a527a7ed83d47263a98abe7213630d52411fc0242f479a1b5ae4947bd5ef89ef523ce0dcda4f8a81236ba74e7804affda011205075c316bd7e7dffd19aabcc3b1753890d402ab87a76cd8fe6aa6e7e1ea138025ac6ab94449b0b5e374c962a12556ce58dd7162417385aaa07b8fe6c63a02df22974ad6bda9246e9ab2b15a456ee278cf999312c0797e8baca8d9e89f7d22807f7e6cd074646003264b6ecaa7ec9a07f6af12579c01170531d3adb1a90774bb6f9a20eafb8d93189d77f42c4261809614e27eb03c2f3e4e2a776f5aeae0933490d67f05c12dd4abb29608177b8899d75a28308e65bb2837013ef492606de560c41923c637f0deb492438620fc4cb134636afcb29e8d47abb8d5afce496d80bf5091aaf6be9b8933aeb89791b87d8f7e87c9e535228625fc5a85d5d35a043f4a554f905dfd3f5e047e1093c8af7089afc50ae75b6dcd5027a0c2909fda3f13f29928168aa3b6d1203ad979842aef171e4c34bee5d954e6e64752e2cd779e39cff9b15fcd2f47db0b410d696ffe695279a61064717bca4f361780a328b630b9b77d1d51eb5c7d8227cf35b347e3a839b620ac3ff43f3e412148d490fa29078221bbc1f19e758c3f1563722d401ed7de553942c4323e79d89606d91ce62fd16856391afd28e8257290831f29dc4569ea49f70080d3e0daf3d039d4ddd43987bf4ea8a21a89f157bbcb5c07ce886477e1dbafa07da5864e1ae8d2fdd5567a8fd5b1625ee6d80f57b95fab18db8bd5ca386d5f9ddac290fce7c53d73d6dc249b776cdedac9e4c68e4ff52f1f20439817e621a25984fde5ba4d86c9e75a1eb724a08ff56f9646e62ad9d719a7bc64d25b847e9bb71c455a98107c970579b3fab381dd8a7a6f52a009dfa9f15215e24c01d3226ce1eaeca0ed055526c799b0ffb8ac065407dabc8df702eb2c2e5b0803bdda49701615929c8aad1519b261729e70a53b22a7511e8a2c2e26b297ea7ec1b3e4856fd4569d94af57672fdf4e59bb8b41a34c7e3ddbe9faf187c9389ade91ee90f399617e52e6552adab9ea2d008fead20c76d4fa525d9272f281cc9e6cf61b71d624994756c48a72573ed0f995d26bcc78b99187e2a579ce5ac0303d9f14ba859c486f2ffa4231213bc7e27ff99791868e28eb244973025e89593bfa5eb13a1a0eff2e9ec2fdd1ba2f0c62fadae7161a5a00a3531671f72ff1d11dba57c60f54f408d52ba3eaa7416b17022a0d021da09ca0f7c3458ae76dca4ffbaac04e83b1b9639eb1c892a0a1f80778b2fffaed559bddaea0b892b8f7d2952b65ea7e15a2571b4773c8b30df3a5935354f5d9861e1df3507934195b78fd07fa3f8252809dc8f21bbced52489eb1864412892acd2a47b99f0b3be13b28f32aa77686172adc6711745f67779729204e0625c25c18ff7083ed9d5da492c9a4d65b1d483a1af7978112b14ade1efa19ff1815cd6064854b8640919a7980e1d4884602ee8d0bf4857eba0120b178bb397c0c970c9cb9eff8bfa7fe49c0b1e65a87acd8502498d2608c0055995190f8fa62bdf8bc50713e67a7fa10d6bd890b573ce0d37d0993a9c798d0de2b1444a58169f094b00ed55338a809ae0fb8ef7c756f259a7b0ef983cee0608ecbdb113ff210e845a21f7954377c95d7ceae91b1db9768cd26a6418a957f1e2e3dbcb2fb7baea64061890200f16c7ac7303d1c8a95f167bdf37e0861453b5fb4f0f16fb03d2f8409a50fca777a4aaa732f6a030fc957701c891f1244377b5a5ac769ed36d5c89f9019d33c00c64cdb7662</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>需要密码</category>
      </categories>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有数列 $ f,g $ ，对于每一个数字 $ i $ 有 $ f_i=\sum\limits_{j=0}^i(-1)^j\dbinom{i}{j}g_j $</p>
<p>求证，有 $ g_i=\sum\limits_{j=0}^i(-1)^j\dbinom{i}{j}f_j $ 。</p>
<span id="more"></span>
<h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>考虑当 $ n\ne 0 $ 时，$ \sum\limits_{i=0}^n(-1)^i\dbinom{n}{i} $ 的值。</p>
<p>当 $ n $ 为奇数时：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=0}^n(-1)^i\dbinom{n}{i}\\
=&\dfrac{1}{2}\left(\sum_{i=0}^n(-1)^i2\dbinom{n}{i}\right)\\
=&\dfrac{1}{2}\left(\sum_{i=0}^n(-1)^i\dbinom{n}{i}+(-1)^{n-i}\dbinom{n}{n-i}\right)\\
=&0
\end{aligned}</script><p>当 $ n $ 为偶数时：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=0}^n(-1)^i\dbinom{n}{i}\\
=&\sum_{i=0}^{n/2}\dbinom{n}{2i}-\sum\limits_{i=0}^{n/2-1}\dbinom{n}{2i+1}\\
=&\dbinom{n}{0}+\dbinom{n}{n}+\sum_{i=1}^{n/2-1}\dbinom{n}{2i}-\sum\limits_{i=0}^{n/2-1}\dbinom{n}{2i+1}\\
=&\dbinom{n-1}{0}+\dbinom{n-1}{n-1}+\sum_{i=1}^{n/2-1}\dbinom{n-1}{2i}+\dbinom{n-1}{2i-1}-\sum\limits_{i=0}^{n/2-1}\dbinom{n-1}{2i+1}+\dbinom{n-1}{2i}\\
=&\sum_{i=0}^{n-1}\dbinom{n-1}{i}-\sum_{i=0}^{n-1}\dbinom{n-1}{i}\\
=&0
\end{aligned}</script><p>$ \therefore \sum\limits_{i=0}^n(-1)^i\dbinom{n}{i}=0 $ 。</p>
<p>移项可得 $ \sum\limits_{i=1}^n(-1)^i\dbinom{n}{i}=-1 $</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>考虑使用数学归纳法。</p>
<p>当 $ i=0 $ 时，$ f_0=(-1)^0\dbinom{0}{0}g_0=g_0 $ 。</p>
<p>显然 $ g_0=f_0=(-1)^0\dbinom{0}{0}f_0 $ 。</p>
<p>现在假设，对于 $ i=0\sim k-1 $ ，都满足条件，现在来证明 $ i=k $ 时满足条件。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=\sum_{j=0}^i(-1)^j\dbinom{i}{j}g_j\\
f_i&=(-1)^ig_i+\sum_{j=0}^{i-1}(-1)^j\dbinom{i}{j}\sum_{p=0}^j(-1)^p\dbinom{j}{p}f_p\\
f_i&=(-1)^ig_i+\sum_{j=0}^{i-1}\sum_{p=0}^j(-1)^{j+p}\dbinom{i}{j}\dbinom{j}{p}f_p
\end{aligned}</script><p>我们来看 $ \dbinom{i}{j}\dbinom{j}{p} $ 的组合意义。</p>
<p>我们可以理解成，一个班级共有 $ i $ 个人，我们要先选出 $ j $ 个人当班干部，这 $ j $ 个人中再选出 $ p $ 个人当组长，剩余的 $ j-p $ 个人当副组长。</p>
<p>那我们就可以看成，先从 $ i $ 个人选出 $ p $ 个人当组长，再从剩下的 $ i-p $ 个人中，选 $ j-p $ 个人当副组长（$ i-j $ 人是平民）。</p>
<p>也就是说，$ \dbinom{i}{j}\dbinom{j}{p}=\dbinom{i}{p}\dbinom{i-p}{j-p}=\dbinom{i}{p}\dbinom{i-p}{i-j} $。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=(-1)^ig_i+\sum_{j=0}^{i-1}\sum_{p=0}^j(-1)^{j+p}\dbinom{i}{j}\dbinom{j}{p}f_p\\
f_i&=(-1)^ig_i+\sum_{j=0}^{i-1}\sum_{p=0}^j(-1)^{j+p}\dbinom{i}{p}\dbinom{i-p}{i-j}f_p\\
f_i&=(-1)^ig_i+\sum_{p=0}^{i-1}(-1)^p\dbinom{i}{p}f_p\sum_{j=p}^{i-1}(-1)^{j}\dbinom{i-p}{i-j}\\
f_i&=(-1)^ig_i+\sum_{p=0}^{i-1}(-1)^p\dbinom{i}{p}f_p\sum_{j=1}^{i-p}(-1)^{i-j}\dbinom{i-p}{j}\\
(-1)^if_i&=g_i+\sum_{p=0}^{i-1}(-1)^p\dbinom{i}{p}f_p\sum_{j=1}^{t}(-1)^j\dbinom{t}{j}&令t=i-p\\(-1)^if_i&=g_i+\sum_{p=0}^{i-1}(-1)^p\dbinom{i}{p}f_p\times(-1)&引理\\
g_i&=(-1)^if_i+\sum_{p=0}^{i-1}(-1)^p\dbinom{i}{p}f_p\\
g_i&=\sum_{p=0}^i(-1)^p\dbinom{i}{p}f_p\\
\end{aligned}</script><p>证完力！</p>
]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu7162</title>
    <url>/hdu7162/</url>
    <content><![CDATA[<p>一道分治NTT的好题。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=7162">题目链接</a></p>
<span id="more"></span>
<p>前置知识：<a href="https://shijiuwan.github.io/NTT学习笔记/#分治NTT">分治NTT</a>。</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>小Q在玩一个RPG游戏，这个游戏里的武器可以升级，武器一开始是 $ 0 $ 级，最高可以到 $ n $ 级。</p>
<p>假如武器现在是 $ i(0\leqslant i&lt;n) $ 级，小Q就可以花费 $ c_i $ 个硬币升级武器；</p>
<p>升级武器有 $ p_i $ 的概率成功，这个时候武器的等级会变为 $ i+1 $ 。</p>
<p>否则升级会失败，有 $ (1-p_i)\dfrac{w_j}{\sum_{k=1}^iw_k} $ 的概率会掉落到 $ i-j(1\leqslant j\leqslant i) $ 级。</p>
<p>请你帮小Q算出升级到 $ n $ 级，期望需要多少硬币，对 $ 998244353 $ 取模。</p>
<p>$ n\leqslant 10^5 $ ，$ 数据组数T\leqslant 300 $，$ \sum n\leqslant 5\times 10^5 $ 。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题一看上去就很期望dp对吧，是不是很像武器升级游戏？</p>
<p>这题显然不能直接倒推，倒着推全是环。</p>
<p>考虑正推。</p>
<p>设 $ dp_i $ 表示从 $ i-1 $ 升级到 $ i $ 级的期望，则 $ pre_i=\sum\limits_{j=1}^idp_j $ 表示从 $ 0 $ 级升级到 $ i $ 级的期望。</p>
<p>首先列一下方程：</p>
<script type="math/tex; mode=display">
dp_i=c_{i-1}+(1-p_{i-1})\left(\sum_{j=1}^i\dfrac{w_j(pre_i-pre_{i-j-1})}{\sum_{k=1}^iw_k}\right)</script><p>大概意思就是说，你首先花费了 $ c_{i-1} $ 个硬币进行升级。</p>
<p>有 $ p_{i-1} $ 的概率成功了，这个时候代价就是 $ 0 $ ，不用管。</p>
<p>否则会失败，枚举掉到了哪一层，然后乘上重新回来的代价即可。</p>
<p>这样我们就得到了一个 $ n^2 $ 的dp，显然过不了，而且这个dp还有环（$ dp_i $ 需要用到 $ pre_i $) 。</p>
<p>所以下面我们来颓柿子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp_i&=c_{i-1}+(1-p_{i-1})\left(\sum_{j=1}^i\dfrac{w_j(pre_i-pre_{i-j-1})}{\sum_{k=1}^iw_k}\right)\\
dp_i&=c_{i-1}+(1-p_{i-1})\left(\sum_{j=1}^i\dfrac{w_j(dp_i+pre_{i-1}-pre_{i-j-1})}{\sum_{k=1}^iw_k}\right)\\
dp_i&=c_{i-1}+(1-p_{i-1})\left(\sum_{j=1}^i\dfrac{w_j(pre_{i-1}-pre_{i-j-1})}{\sum_{k=1}^iw_k}\right)+(1-p_{i-1})dp_i\\
p_{i-1}dp_i&=c_{i-1}+(1-p_{i-1})\left(\sum_{j=1}^i\dfrac{w_j(pre_{i-1}-pre_{i-j-1})}{\sum_{k=1}^iw_k}\right)\\
p_{i-1}dp_i&=c_{i-1}+(1-p_{i-1})pre_{i-1}+(p_{i-1}-1)\left(\sum_{j=1}^i\dfrac{w_jpre_{i-j-1}}{\sum_{k=1}^iw_k}\right)\\
dp_i&=\dfrac{c_{i-1}+(1-p_{i-1})pre_{i-1}+(p_{i-1}-1)\left(\sum_{j=1}^i\dfrac{w_jpre_{i-j-1}}{\sum_{k=1}^iw_k}\right)}{p_{i-1}}\\
\end{aligned}</script><p>所以呢？</p>
<p>$ c_{i-1}+(1-p_{i-1})pre_{i-1} $ 和 $ p_{i-1}-1 $ ，$ p_{i-1} $ 都是常数（或者在算 $ dp_i $ 的时候可以被当成常数）。</p>
<p>后面的括号直接一个分治NTT带走。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pl=pair&lt;ll,ll&gt;;</span><br><span class="line"><span class="keyword">using</span> pli=pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">using</span> vc=vector&lt;A&gt;;</span><br><span class="line"><span class="keyword">using</span> vi=vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> RG=<span class="number">332748118</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> G=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> wh[<span class="number">600001</span>];</span><br><span class="line">ll f[<span class="number">600001</span>];</span><br><span class="line">ll g[<span class="number">600001</span>];</span><br><span class="line">ll pre[<span class="number">100001</span>];</span><br><span class="line">ll dp[<span class="number">100001</span>];</span><br><span class="line">ll prew[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">qow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(ll *f,<span class="type">int</span> n,<span class="type">bool</span> dft=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;wh[i]) <span class="built_in">swap</span>(f[i],f[wh[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll step=<span class="built_in">qow</span>(dft?G:RG,(mod<span class="number">-1</span>)/len);<span class="type">int</span> num=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,mid=num;l&lt;n;l+=len,mid+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            ll s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll now=f[i+mid]*s%mod;</span><br><span class="line">                f[i+mid]=(f[i+l]-now+mod)%mod;</span><br><span class="line">                f[i+l]=(f[i+l]+now)%mod;</span><br><span class="line">                s=s*step%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!dft)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num=<span class="built_in">qow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*num%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) wh[i]=(wh[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)+(i&amp;<span class="number">1</span>?n&gt;&gt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(f,n),<span class="built_in">NTT</span>(g,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(f,n,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fz</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        dp[l]=mod-dp[l]*(mod+<span class="number">1</span>-p[l<span class="number">-1</span>])%mod*<span class="built_in">qow</span>(prew[l<span class="number">-1</span>],mod<span class="number">-2</span>)%mod;</span><br><span class="line">        dp[l]=(dp[l]+c[l<span class="number">-1</span>]+pre[l<span class="number">-1</span>]*(mod+<span class="number">1</span>-p[l<span class="number">-1</span>]))%mod;</span><br><span class="line">        dp[l]=dp[l]*<span class="built_in">qow</span>(p[l<span class="number">-1</span>],mod<span class="number">-2</span>)%mod;</span><br><span class="line">        pre[l]=(pre[l<span class="number">-1</span>]+dp[l])%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fz</span>(l,mid);</span><br><span class="line">    <span class="type">int</span> len=(r-l+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>,nb=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;nb&lt;=len;nb&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nb;i++) f[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++) f[i-l]=pre[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;i++) g[i]=w[i];</span><br><span class="line">    <span class="built_in">NTT</span>(nb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++) dp[i]=(dp[i]+f[i-l<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="built_in">fz</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>();ll num=<span class="built_in">qow</span>(<span class="number">100</span>,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) p[i]=<span class="built_in">read</span>()*num%mod,c[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) w[i]=<span class="built_in">read</span>(),prew[i]=prew[i<span class="number">-1</span>]+w[i];</span><br><span class="line">        <span class="built_in">fz</span>(<span class="number">0</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,pre[n]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>向量点积</title>
    <url>/%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现有三个点 $ A(x_1,y_1),B(x_2,y_2),O(0,0) $ 。</p>
<p>求证 $ \overrightarrow{OA}\cdot\overrightarrow{OB}=x_1x_2+y_1y_2 $ 。</p>
<p>也就是证明 $ |OA||OB|\cos\theta=x_1x_2+y_1y_2 $</p>
<span id="more"></span>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>标点 $ C(1,0),D(0,1) $ ，并设 $ \overrightarrow{e_1}=\overrightarrow{OC},\overrightarrow{e_2}=\overrightarrow{OD} $ 。</p>
<p>那么 $ \overrightarrow{OA}=x_1\overrightarrow{e_1}+y_1\overrightarrow{e_2},\overrightarrow{OB}=x_2\overrightarrow{e_1}+y_2\overrightarrow{e_2} $ 。</p>
<p>所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\overrightarrow{OA}\cdot\overrightarrow{OB}\\
=&(x_1\overrightarrow{e_1}+y_1\overrightarrow{e_2})\cdot(x_2\overrightarrow{e_1}+y_2\overrightarrow{e_2})\\
=&x_1x_2\overrightarrow{e_1}\cdot\overrightarrow{e_1}+y_1y_2\overrightarrow{e_2}\cdot\overrightarrow{e_2}+(x_1y_2+x_2y_1)(\overrightarrow{e_1}\cdot\overrightarrow{e_2})\\
=&(x_1x_2+y_1y_2)\cos{0}+(x_1y_2+x_2y_1)\cos\dfrac{\pi}{2}\\
=&x_1x_2+y_1y_2
\end{aligned}</script>]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式学习笔记</title>
    <url>/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文为作者的学习笔记，其中主要包含作者学习时的一些笔记，以及一些例题。<del>如果有小伙伴看到这篇博客没有写完的话，那一定是我咕咕咕了。</del></p>
<p>事实上这只是一个目录。</p>
<span id="more"></span>
<p><a href="https://shijiuwan.github.io/FFT学习笔记/">FFT学习笔记</a></p>
<p><a href="https://shijiuwan.github.io/NTT学习笔记/">NTT学习笔记</a></p>
<p><a href="https://shijiuwan.github.io/FMT-FWT学习笔记/">FMT/FWT学习笔记</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>FMT</tag>
        <tag>FWT</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>点到直线距离公式</title>
    <url>/%E7%82%B9%E5%88%B0%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现在有一个直线 $ l:Ax+By+C=0 $ 与一个点 $ P(x_0,y_0) $ 。</p>
<p>求点 $ P $ 到直线 $ l $ 的距离。</p>
<span id="more"></span>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>过 $ P $ 做直线 $ l $ 的垂线 $ l’ $ ，则 $ l’ $ 可以写成 $ Bx-Ay+D=0 $ 的形式。</p>
<p>因为 $ P $ 在 $ l’ $ 上，将 $ (x_0,y_0) $ 带入，可解得 $ D=Ay_0-Bx_0 $ 。</p>
<p>设 $ l $ 与 $ l’ $ 交于点 $ Q $ ，则 $ PQ $ 即为 $ P $ 到 $ l $ 的距离。</p>
<p>因为点 $ Q $ 为直线 $ l $ 与直线 $ l’ $ 的交点，我们可以用<a href="https://shijiuwan.github.io/直线和直线交点公式/">直线和直线交点公式</a>求出点 $ Q $ 的坐标。</p>
<p>解得点 $ Q $ 坐标为 $ \left(\dfrac{B^2x_0-ABy_0-AC}{A^2+B^2},\dfrac{A^2y_0-ABx_0-BC}{A^2+B^2}\right) $ 。</p>
<p>那么就可以知道：</p>
<script type="math/tex; mode=display">
\begin{aligned}
PQ^2&=\left(\dfrac{B^2x_0-ABy_0-AC}{A^2+B^2}-x_0\right)^2+\left(\dfrac{A^2y_0-ABx_0-BC}{A^2+B^2}-y_0\right)^2\\
&=\left(\dfrac{-A^2x_0-ABy_0-AC}{A^2+B^2}\right)^2+\left(\dfrac{-B^2y_0-ABx_0-BC}{A^2+B^2}\right)^2\\
&=\dfrac{(A^2x_0+ABy_0+AC)^2}{(A^2+B^2)^2}+\dfrac{(B^2y_0+ABx_0+BC)^2}{(A^2+B^2)^2}\\
&=\dfrac{A^2(Ax_0+By_0+C)^2}{(A^2+B^2)^2}+\dfrac{B^2(By_0+Ax_0+C)^2}{(A^2+B^2)^2}\\
&=\dfrac{(A^2+B^2)(Ax_0+By_0+C)^2}{(A^2+B^2)^2}\\
&=\dfrac{(Ax_0+By_0+C)^2}{A^2+B^2}\\
\end{aligned}</script><p>两边同时开根号</p>
<script type="math/tex; mode=display">
PQ=\pm\dfrac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}</script><p>由于距离非负，所以有：</p>
<script type="math/tex; mode=display">
PQ=\dfrac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}}</script><p>若换一种形式，$ l:y=kx+b $ ，则知 $ kx-y+b=0 $ ，此时距离为 $ \dfrac{|kx_0-y_0+b|}{\sqrt{1+k^2}} $</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>若 $ l:Ax+By+C=0,P(x_0,y_0) $</p>
<p>则 $ P $ 到 $ l $ 距离为 $ \dfrac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}} $ 。</p>
<p>若 $ l:y=kx+b,P(x_0,y_0) $</p>
<p>则 $ P $ 到 $ l $ 距离为 $ \dfrac{|kx_0-y_0+b|}{\sqrt{1+k^2}} $ 。</p>
]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>树状数组是一种数据结构，常用于区间修改、区间查询等问题，功能没有线段树多，但胜在常数比线段树小了许多，且代码较短，更容易实现。</p>
<span id="more"></span>
<p>树状数组本质上就是一个数组，他们之间的关系就像一棵树一样，层层管理。</p>
<p>不妨设原数组为 $ a $,树状数组为 $ t $,则 $ t_x=\sum\limits_{i=x-lowbit\left(x\right)+1}^xa_i $ 。</p>
<p>那么 $ lowbit $ 又是什么呢？</p>
<p>其实就是一个二进制数最后的 $ 1 $ 所代表的值。</p>
<p>并且因为补码的原因，还有 $ lowbit\left(x\right)=x\&amp;-x $,其中 $ \&amp; $ 表示按位与。</p>
<p>对于每一个 $ i $,管理 $ i $ 的节点可能有很多个，但是<strong>直接</strong>进行管理的最多只有一个，其他的都是间接进行管理。</p>
<p>举个例子：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nxj38tkv.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt=""></p>
<p>$ 1 $ 被 $ 2 $ 直接管理；</p>
<p>$ 2 $ 被 $ 4 $ 直接管理；</p>
<p>$ 3 $ 被 $ 4 $ 直接管理；</p>
<p>$ 4 $ 被 $ 8 $ 直接管理；</p>
<p>$ 5 $ 被 $ 6 $ 直接管理；</p>
<p>$ 6 $ 被 $ 8 $ 直接管理；</p>
<p>$ 7 $ 被 $ 8 $ 直接管理；</p>
<p>$ 8 $ 不被任何节点管理。</p>
<p>不难<del>瞪出</del>直接管理 $ i $ 的节点编号为 $ i+lowbit\left(i\right) $。</p>
<p>建树思路 $ 1 $：</p>
<p>对于每一个 $ i $,称直接管理 $ i $ 的节点为 $ fa_i $。</p>
<p>$ fa_i $ 管理 $ i $,$ fa_{fa_i} $ 又管理 $ i $,$ fa_{fa_i} $ 显然管理 $ i $。</p>
<h2 id="父亲编号证明"><a href="#父亲编号证明" class="headerlink" title="父亲编号证明"></a>父亲编号证明</h2><p>我们刚刚只是用眼睛发现了 $ i $ 的父亲是 $ i+lowbit(i) $ ，现在我们来证明。</p>
<p>为了方便，我们先设 $ x=i+lowbit(i) $ 。</p>
<p>我们先来证明 $ x $ 管理 $ i $ 。</p>
<p>这个很显然，因为 $ x=i+lowbit(i) $ ，</p>
<p>那么就一定会有 $ lowbit(x)&gt;lowbit(i) $ 。</p>
<p>$ x $ 管理的节点为 $ [x-lowbit(x)+1,x] $ 。</p>
<p>$ \because x-lowbit(x)+1&lt;x-lowbit(i)+1 $</p>
<p>$ \therefore x-lowbit(x)+1\leqslant x-lowbit(i)=i $</p>
<p>又有 $ i&lt;x $ ，即 $ i\in[x-lowbit(x)+1,x] $ 。</p>
<p>所以 $ x $ 一定管理 $ i $ 。</p>
<p>我们再来证明 $ x $ 是所有管理 $ i $ 的节点中最小的。</p>
<p>假设 $ lowbit(i)=2^j,lowbit(x)=2^y $ ，则一定 $ y&gt;j $ 。</p>
<p>假设还有一个数字 $ c $ 满足 $ c-lowbit(c)+1\leqslant i<c<x $ ，我们设 $ lowbit(c)=2^d $ ，显然还有 $ d>j $ 。</p>
<p>因为我们知道 $ x=i+lowbit(i) $ ，也就是说 $ i $ 和 $ x $ 在大于 $ y $ 的位上都是相同的。</p>
<p>由于 $ i&lt;c&lt;x $ ，所以他们三个数字在大于 $ y $ 的位上也是相同的。</p>
<p>也就是说他们三个数应该长这个样子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
i:&10010011111\\
c:&10010??????\\
x:&10010100000\\
\end{aligned}</script><p>注意到 $ c&gt;i $ ，所以这个时候 $ c $ 的第 $ y $ 位上肯定是 $ 1 $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
i:&10010011111\\
c:&100101?????\\
x:&10010100000\\
\end{aligned}</script><p>然后你就会发现 $ c\geqslant x $，但是根据我们之前的假设 $ c&lt;x $ 。</p>
<p>所以 $ x $ 肯定为管理 $ i $ 的最小的节点。</p>
<h2 id="树状数组建树"><a href="#树状数组建树" class="headerlink" title="树状数组建树"></a>树状数组建树</h2><p>根据刚刚的结论，我们也可以算出，管理 $ i $ 的节点总共只有 $ O(\log n) $ 的。</p>
<p>所以，我们就可以暴力找出所有管理 $ i $ 的节点，然后修改这个点的权值，时间复杂度 $ O\left(n\log n\right) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=i;</span><br><span class="line">    <span class="keyword">while</span>(num&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[num]+=a[i];</span><br><span class="line">        num+=<span class="built_in">lowbit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建树思路 $ 2 $：</p>
<p>对于每一个 $ i $,管理 $ i $ 的节点必定管理所有 $ i $ 所管理的节点。</p>
<p>所以直接找到直接管理 $ i $ 的节点，对其进行修改即可，时间复杂度 $ \Theta\left(n\right) $。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    t[i]+=a[i];</span><br><span class="line">    <span class="type">int</span> num=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=n)</span><br><span class="line">        t[num]+=t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：如果你想要节省内存，那么数组 $ a $ 与 $ t $ 可以为同一个数组，读入时读入 $ t $ 即可。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=n)</span><br><span class="line">        t[num]+=t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="树状数组的修改"><a href="#树状数组的修改" class="headerlink" title="树状数组的修改"></a>树状数组的修改</h2><p>根据建树所提到的，只需修改管理该节点的所有节点即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//将第x个数的值增加y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=y;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组的查询"><a href="#树状数组的查询" class="headerlink" title="树状数组的查询"></a>树状数组的查询</h2><p>树状数组这种数据结构可以做到 $ O\left(\log n\right) $ 查询前缀和，一个点管理的所有点为它自己（包括）之前的 $ lowbit $ 个节点，只需要利用这种关系查询即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//查询前x个数的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="树状数组维护信息"><a href="#树状数组维护信息" class="headerlink" title="树状数组维护信息"></a>树状数组维护信息</h2><h3 id="单点修改与区间查询"><a href="#单点修改与区间查询" class="headerlink" title="单点修改与区间查询"></a>单点修改与区间查询</h3><p><a href="https://www.luogu.com.cn/problem/P3374">例题</a></p>
<p>操作 $ 1 $ 与上述所讲完全一样，树状数组即可。</p>
<p>操作 $ 2 $ 中的 $ l $ 并不保证是 $ 1 $，我们可以利用：</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^ra_i-\sum\limits_{i=1}^{l-1}a_i=\sum\limits_{i=l}^ra_i</script><p>解得答案。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=n)</span><br><span class="line">            t[num]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        num+=t[i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,t+i);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;k);</span><br><span class="line">            <span class="built_in">change</span>(x,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(y)-<span class="built_in">get</span>(x<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区间修改与单点查询"><a href="#区间修改与单点查询" class="headerlink" title="区间修改与单点查询"></a>区间修改与单点查询</h3><p><a href="https://www.luogu.com.cn/problem/P3374">例题</a></p>
<p>众所周知，原序列的区间修改操作在差分序列上会变成两次单点修改，而这时的单点查询操作就会变成一个区间查询操作。</p>
<p>利用这个性质，我们就可以使用树状数组来维护原序列的差分序列来做这道题。</p>
<p>大体步骤是这样的：</p>
<p>首先计算原序列的差分序列并建树。</p>
<p>对于修改操作，将差分序列第 $ x $ 个位置加上 $ k $,将第 $ r+1 $ 个位置减去 $ k $。</p>
<p>对与查询操作，即为查询差分序列前 $ x $ 数的和。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=n)</span><br><span class="line">            t[num]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        num+=t[i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,t+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">        t[i]-=t[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y,k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">            <span class="built_in">change</span>(x,k);</span><br><span class="line">            <span class="built_in">change</span>(y+<span class="number">1</span>,-k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区间修改与区间查询"><a href="#区间修改与区间查询" class="headerlink" title="区间修改与区间查询"></a>区间修改与区间查询</h3><p><a href="https://www.luogu.com.cn/problem/P3372">例题</a></p>
<p>首先我们知道由于区间修改操作的存在，我们没有更好的方法来进行修改，所以还是考虑维护差分序列，下面我们来推式子：</p>
<p>设 $ a $ 为原序列，$ b $ 为差分序列，则：</p>
<p>$ \sum\limits_{i=1}^xa_i=\sum\limits_{i=1}^x\sum\limits_{j=1}^ib_j $</p>
<p>$ \kern{22pt}=\sum\limits_{i=1}^xb_i\times\left(n-i+1\right) $</p>
<p>$ \kern{22pt}=\sum\limits_{i=1}^xb_i\times\left(n+1\right)-\sum\limits_{i=1}^xb_i\times i $</p>
<p>所以只需要使用两个树状数组维护信息即可。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b[<span class="number">100010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[<span class="number">100010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            w=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lowbit</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;(-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num=i;</span><br><span class="line">        <span class="keyword">while</span>(num&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            b[num]+=a[i];</span><br><span class="line">            c[num]+=a[i]*i;</span><br><span class="line">            num+=<span class="built_in">lowbit</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num=x;</span><br><span class="line">    <span class="keyword">while</span>(num&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        b[num]+=k;</span><br><span class="line">        c[num]+=x*k;</span><br><span class="line">        num+=<span class="built_in">lowbit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>,num=x;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=b[num];</span><br><span class="line">        num-=<span class="built_in">lowbit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    ans*=(x+<span class="number">1</span>);</span><br><span class="line">    num=x;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        ans-=c[num];</span><br><span class="line">        num-=<span class="built_in">lowbit</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n;i;i--)</span><br><span class="line">        a[i]-=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> op;</span><br><span class="line">        op=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> l,r,k;</span><br><span class="line">            l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">change</span>(l,k);</span><br><span class="line">            <span class="built_in">change</span>(r+<span class="number">1</span>,-k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line">            l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">get</span>(r)-<span class="built_in">get</span>(l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>直线和圆交点公式</title>
    <url>/%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%9C%86%E4%BA%A4%E7%82%B9%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>设现在有一个圆，圆心在 $ (x_c,y_c) $ ，半径为 $ r $ 。</p>
<p>还有一条直线，公式为 $ Ax+By+C=0 $ 。</p>
<p>求交点个数以及坐标。</p>
<span id="more"></span>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>显然最多只有两个交点。</p>
<p>我们设交点坐标为 $ (x,y) $ 。</p>
<p>那么一定会有这个方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
Ax+By+C=0&(1)\\
(x-x_c)^2+(y-y_c)^2=r^2&(2)
\end{cases}</script><p>当 $ B\ne 0 $ 时，我们可以通过方程 $ (1) $ ，使用 $ x $ 来表达出 $ y $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
y=-\dfrac{Ax+C}{B}&&(3)
\end{aligned}</script><p>然后将 $ (3) $ 带入 $ (2) $ ，开始暴力解方程。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(x-x_c)^2+(-\dfrac{Ax+C}{B}-y_c)^2&=r^2\\
(x-x_c)^2+(\dfrac{Ax+C}{B}+y_c)^2&=r^2\\
x^2-2x_cx+x_c^2+\dfrac{A^2x^2}{B^2}+\frac{C^2}{B^2}+y_c^2+\dfrac{2ACx}{B^2}+\dfrac{2Ay_cx}{B}+\dfrac{2Cy_c}{B}&=r^2\\
(A^2+B^2)x^2+2(AC+ABy_c-B^2x_c)x+(B^2x_c^2+C^2+y_c^2B^2+2BCy_c-r^2B^2)&=0
\end{aligned}</script><p>我们令 $ a=A^2+B^2,b=2(AC+ABy_c-B^2x_c),c=(B^2x_c^2+C^2+y^2_cB^2+2BCy_c-r^2B^2) $ 。</p>
<p>这样子这个方程就变成了标准的一元二次方程。</p>
<p>再令 $ \Delta=b^2-4ac $ 。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>那么当 $ \Delta&lt;0 $ 时，没有交点。</p>
<p>当 $ \Delta=0 $ 时，交点横坐标都为 $ \dfrac{-b}{2a} $ 。</p>
<p>当 $ \Delta&gt;0 $ 时，两个交点横坐标为 $ \dfrac{-b\pm\sqrt{\Delta}{}}{2a} $ 。</p>
<p>容易发现，当 $ B=0 $ 时，仍满足此方程。</p>
]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>直线和直线交点公式</title>
    <url>/%E7%9B%B4%E7%BA%BF%E5%92%8C%E7%9B%B4%E7%BA%BF%E4%BA%A4%E7%82%B9%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现在有两条直线。</p>
<p>第一条方程为 $ A_1x+B_1y+C_1=0 $ 。</p>
<p>第二条方程为 $ A_2x+B_2y+C_2=0 $ 。</p>
<p>求交点坐标。</p>
<span id="more"></span>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>显然，两条直线斜率分别为 $ -\dfrac{A_1}{B_1},-\dfrac{A_2}{B_2} $ 。</p>
<p>所以当 $ -\dfrac{A_1}{B_1}=-\dfrac{A_2}{B_2}\Longleftrightarrow A_1B_2=A_2B_1 $ 时没有交点。</p>
<p>所以有交点时，$ A_1B_2-A_2B_1\ne0 $ 。</p>
<script type="math/tex; mode=display">
\begin{cases}
A_1x+B_1y+C_1=0&(1)\\
A_2x+B_2y+C_2=0&(2)\\
\end{cases}</script><p>第一个式子乘上 $ A_2 $ ，第二个式子乘上 $ A_1 $ ，得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
A_1A_2x+B_1A_2y+C_1A_2=0&(3)\\
A_1A_2x+B_2A_1y+C_2A_1=0&(4)
\end{cases}</script><p>两式相减：</p>
<script type="math/tex; mode=display">
(B_1A_2-B_2A_1)y+(C_1A_2-C_2A_1)=0\kern{10pt}(5)</script><p>随便搞搞：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y&=-\dfrac{C_1A_2-C_2A_1}{B_1A_2-B_2A_1}\\
y&=\dfrac{C_1A_2-C_2A_1}{B_2A_1-B_1A_2}\\
\end{aligned}</script><p>带到 $ (1) $ 中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_1x+B_1\times \dfrac{C_1A_2-C_2A_1}{B_2A_1-B_1A_2}+C_1&=0\\
A_1x&=-B_1\times \dfrac{C_1A_2-C_2A_1}{B_2A_1-B_1A_2}-C_1\\
A_1x&=B_1\times \dfrac{C_1A_2-C_2A_1}{B_1A_2-B_2A_1}-C_1\\
A_1x&=\dfrac{C_1B_1A_2-C_2B_1A_1}{B_1A_2-B_2A_1}-C_1\\
A_1x&=\dfrac{C_1B_1A_2-C_2B_1A_1-C_1B_1A_2+C_1B_2A_1}{B_1A_2-B_2A_1}\\
A_1x&=\dfrac{C_1B_2A_1-C_2B_1A_1}{B_1A_2-B_2A_1}\\
x&=\dfrac{C_1B_2-C_2B_1}{B_1A_2-B_2A_1}\\
\end{aligned}</script><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当 $ A_1B_2-A_2B_1=0 $ 时没有交点；</p>
<p>否则交点坐标为 $ \left(\dfrac{C_1B_2-C_2B_1}{B_1A_2-B_2A_1},\dfrac{C_1A_2-C_2A_1}{B_2A_1-B_1A_2}\right) $ 。</p>
]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演学习笔记</title>
    <url>/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>莫比乌斯反演是一种数论中用于计数的算法。</p>
<p>看上去挺难的，实际上挺简单的。</p>
<span id="more"></span>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>感觉要写的东西有点多，所以还是分开单独写一篇吧。</p>
<p><a href="https://shijiuwan.github.io/积性函数">积性函数</a></p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>莫比乌斯反演的基本原理就是 $ \mu\ast I=\varepsilon $ 。</p>
<p>也就是说，如果我们在一个式子中看到了 $ \varepsilon $ ，我们就可以将他转化为 $ \mu\ast I $ 。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 $ 1 $"></a>例题 $ 1 $</h3><p><a href="https://www.luogu.com.cn/problem/P2398">GCD SUM</a></p>
<p>题意：求 $ \sum\limits_{i=1}^n\sum\limits_{i=1}^n\gcd(i,j) $ 。其中 $ n\leqslant 10^5 $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)\\
=&\sum_{g=1}^ng\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=g]&\text{枚举gcd是多少}\\
=&\sum_{g=1}^ng\sum_{i'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\sum_{j'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}[\gcd(i',j')=1]&\text{i和j一定是g倍数，枚举i=i'g,j=j'g}\\
=&\sum_{g=1}^ng\sum_{i'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\sum_{j'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\varepsilon(\gcd(i',j'))&\varepsilon\text{的定义}\\
=&\sum_{g=1}^ng\sum_{i'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\sum_{j'=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\sum_{d|\gcd(i',j')}\mu(d)&\text{莫比乌斯反演}\\
=&\sum_{g=1}^ng\sum_{d=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\mu(d)\left\lfloor\dfrac{n}{gd}\right\rfloor^2&\text{把 $ d $ 提前}\\
=&\sum_{T=1}^n\left\lfloor\dfrac{n}{T}\right\rfloor^2\sum_{d|T}d\times\mu\left(\dfrac{T}{d}\right)&\text{枚举}T=gd\\
=&\sum_{T=1}^n\left\lfloor\dfrac{n}{T}\right\rfloor^2(id\ast\mu)(T)&\text{狄利克雷卷积的定义}\\
=&\sum_{T=1}^n\left\lfloor\dfrac{n}{T}\right\rfloor^2\varphi(T)
\end{aligned}</script><p>暴力计算，时间复杂度为 $ O(n) $ ，可以通过。</p>
<p>我最后一步是用数论分块做的，时间复杂度不变。</p>
<p><a href="https://www.luogu.com.cn/record/83354452">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/26mx5kgx">代码</a></p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 $ 2 $"></a>例题 $ 2 $</h3><p><a href="https://www.luogu.com.cn/problem/P2522">[HAOI2011]Problem b</a></p>
<p>题意：$ T $ 组询问，每次给出 $ a,b,c,d,k $ ，求出：</p>
<script type="math/tex; mode=display">
\sum_{i=a}^b\sum_{j=c}^d[\gcd(i,j)=k]</script><p>所有数字 $ \leqslant 5\times 10^4 $ 。</p>
<p>显然，我们可以使用前缀和大法，所以我们只需要求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]</script><p>我们假设 $ n\leqslant m $ （不满足就交换一下），然后来颓柿子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]\\
=&\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[\gcd(i,j)=1]\\
=&\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\sum_{d|\gcd(i,j)}\mu(d)\\
=&\sum_{d=1}^n\mu(d)\left\lfloor\dfrac{n}{dk}\right\rfloor\left\lfloor\dfrac{m}{dk}\right\rfloor\\
\end{aligned}</script><p>直接计算时间复杂度 $ O(Tn) $ ，无法通过。</p>
<p>数论分块即可，时间复杂度 $ O(T\sqrt{n}) $ 。</p>
<p><a href="https://www.luogu.com.cn/record/77699486">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/1qyhiply">代码</a></p>
<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 $ 3 $"></a>例题 $ 3 $</h3><p><a href="https://www.luogu.com.cn/problem/P5221">Product</a></p>
<p>题意：求 $ \prod\limits_{i=1}^N\prod\limits_{j=1}^N\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,j)} $ 。其中 $ N\leqslant 10^6 $ 。</p>
<p>时限 $ 200ms $ ，空限 $ 7.81M $ 。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^N\prod_{j=1}^N\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\\
=&\prod_{i=1}^N\prod_{j=1}^N\dfrac{ij}{\gcd^2(i,j)}
\end{aligned}</script><p>分子和分母我们可以分开算。</p>
<p>分子比较简单：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^N\prod_{j=1}^Nij\\
=&\left(\prod_{i=1}^Ni^N\right)\left(\prod_{j=1}^Nj^N\right)\\
=&(N!)^N\times(N!)^N\\
=&(N!)^{2N}
\end{aligned}</script><p>分母：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^N\prod_{j=1}^N\gcd(i,j)\\
=&\prod_{g=1}^Ng^{\sum\limits_{i=1}^N\sum\limits_{j=1}^N[\gcd(i,j)=g]}\\
=&\prod_{g=1}^Ng^{\sum\limits_{i=1}^{\left\lfloor\frac{N}{g}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{N}{g}\right\rfloor}[\gcd(i,j)=1]}\\
=&\prod_{g=1}^Ng^{\sum\limits_{i=1}^{\left\lfloor\frac{N}{g}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{N}{g}\right\rfloor}\sum\limits_{d|\gcd(i,j)}\mu(d)}\\
=&\prod_{g=1}^Ng^{\sum\limits_{d=1}^{\left\lfloor\frac{N}{g}\right\rfloor}\mu(d)\left\lfloor\frac{N}{gd}\right\rfloor^2}\end{aligned}</script><p>暴力这样做是 $ O(N\ln N) $ 的，应该可以通过。</p>
<p>我在做的时候对上面的式子进行整除分块，时间复杂度为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int_{1}^N\sqrt{\dfrac{N}{x}}\mathrm{d}x\\
=&N^{\frac{1}{2}}\times\int_{1}^Nx^{-\frac{1}{2}}\mathrm{d}x\\
=&O(N)
\end{aligned}</script><p><a href="https://www.luogu.com.cn/record/83265998">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/9lbevi82">代码</a></p>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题 $ 4 $"></a>例题 $ 4 $</h3><p>这道题就有点难度了。</p>
<p><a href="https://www.luogu.com.cn/problem/P6825">「EZEC-4」求和</a></p>
<p>求 $ \sum\limits_{i=1}^n\sum\limits_{j=1}^n\gcd(i,j)^{i+j} $。</p>
<p>共 $ T $ 组数据。</p>
<p>$ 1\leqslant T\leqslant 2,1\leqslant \sum n\leqslant 1.5\times 10^6 $</p>
<p>最大点时限 $ 6s $ 。</p>
<p>还是一样，先颓柿子。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j}\\
=&\sum_{g=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{g}\right\rfloor}g^{gi+gj}\sum_{d|\gcd(i,j)}\mu(d)\\
=&\sum_{g=1}^n\sum_{d=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\mu(d)\sum_{i=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}g^{gd(i+j)}\\
=&\sum_{g=1}^n\sum_{d=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\mu(d)\sum_{i=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}g^{gdi}\times g^{gdj}\\
=&\sum_{g=1}^n\sum_{d=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\mu(d)(\sum_{i=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}g^{gdi})(\sum_{j=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}g^{gdj})\\
=&\sum_{g=1}^n\sum_{d=1}^{\left\lfloor\frac{n}{g}\right\rfloor}\mu(d)(\sum_{i=1}^{\left\lfloor\frac{n}{gd}\right\rfloor}g^{gdi})^2\\
\end{aligned}</script><p>前面两个 $ \sum $ 总时间复杂度是 $ O(n\ln n) $ ，所以我们需要快速计算后面的括号。</p>
<p>不难发现，这是一个等比数列的和。</p>
<p>我们可以在 $ O(\log n) $ 时间内求出等比数列，就像这个样子：</p>
<script type="math/tex; mode=display">
S_n=\dfrac{a^{n+1}-1}{a-1}</script><p>这需要两次快速幂，常数比较大，我们可以进行优化。</p>
<script type="math/tex; mode=display">
S_n=S_{\left\lfloor\frac{n}{2}\right\rfloor}(1+a^{\left\lfloor\frac{n}{2}\right\rfloor})+a^n[n为奇数]</script><p>$ a_n $ 可以递推， $ S_n $ 也可以递推。</p>
<p>时间复杂度 $ O(n\log n\ln n) $ 。</p>
<p><a href="https://www.luogu.com.cn/record/86202851">提交记录</a></p>
<p><a href="https://www.luogu.com.cn/paste/vk46uv96">代码</a></p>
<h3 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h3><p>后面还有两道需要杜教筛的题。</p>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1220">题目</a> <a href="https://shijiuwan.github.io/51nod1220约数之和/">题解</a></p>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1227">题目</a> <a href="https://shijiuwan.github.io/51nod1227平均最小公倍数/">题解</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数论分块</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>积性函数</title>
    <url>/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本篇博客主要是对积性函数的推导。</p>
<p>后面列举一些常见的积性函数，以及狄利克雷卷积公式。</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于一个数论函数（就是定义在正整数域上的函数）$ f $ ，如果任何两个互质的正整数 $ a,b $ 都有 ：</p>
<script type="math/tex; mode=display">
f(a)f(b)=f(ab)</script><p>那么我们称 $ f $ 为积性函数。</p>
<p>特别的，如果对于任何两个正整数 $ a,b $ 都有 $ f(a)f(b)=f(ab) $ ，那么称 $ f $ 为完全积性函数。</p>
<h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>下文中，我们统一使用 $ \ast $ 来表示乘法卷积，也叫做狄利克雷卷积。</p>
<p>其实就是一个新运算，<del>把它当成小学奥数题就OK</del>。</p>
<p>具体来说，如果有 $ f=g\ast h $ ，那么就会有：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{i\times j=n}g(i)\times h(j)=\sum_{i|n}g(i)\times h\left(\dfrac{n}{i}\right)</script><p>这里，$ f(i) $ 表示一个多项式的第 $ i $ 项（$ i $ 次项的系数），或者一个函数在 $ i $ 处的取值。</p>
<p>狄利克雷卷积的单位元为 $ \varepsilon $ ，即对于任何数论函数，都有 $ f\ast\varepsilon=f $ 。</p>
<p>其中：</p>
<script type="math/tex; mode=display">
\varepsilon(n)=\begin{cases}
1&n=1\\
0&n\ne 1
\end{cases}</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>感觉好多性质都是和狄利克雷卷积有关的。</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 $ 1 $"></a>性质 $ 1 $</h3><blockquote>
<p>性质 $ 1 $ ：对于任何一个积性函数 $ f $ ，有 $ f(1)=1 $ 。</p>
</blockquote>
<p>显然，对于任何一个正整数 $ a $ 都有 $ \gcd(1,a)=1 $ ，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(1)f(a)&=f(1\times a)\\
f(1)f(a)&=f(a)\\
f(1)&=1\\
\end{aligned}</script><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 $ 2 $"></a>性质 $ 2 $</h3><blockquote>
<p>性质 $ 2 $ ：对于任何两个积性函数 $ f,g $ ，$ f\ast g=g\ast f $ 。</p>
</blockquote>
<p>这个也比较显然。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(f\ast g)(n)\\
=&\sum_{i|n}f(i)g\left(\dfrac{n}{i}\right)\\
=&\sum_{i|n,j=\frac{n}{i}}f\left(\dfrac{n}{j}\right)g\left(j\right)\\
=&\sum_{i|n,j=\frac{n}{i}}g\left(j\right)f\left(\dfrac{n}{j}\right)\\
=&\sum_{j|n}g\left(j\right)f\left(\dfrac{n}{j}\right)\\
=&(g\ast f)(n)\\
\end{aligned}</script><p><del>我怎么这么能氵字数</del></p>
<h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 $ 3 $"></a>性质 $ 3 $</h3><blockquote>
<p>性质 $ 3 $ ：对于任意两个积性函数 $ f,g $ 和正整数 $ n $ ，$ h(n)=f(n)\times g(n) $ ，则 $ h $ 为积性函数。</p>
</blockquote>
<p>显然，对于任意两个互质的正整数 $ a,b $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h(ab)\\
=&f(ab)\times g(ab)\\
=&f(a)\times f(b)\times g(a)\times g(b)\\
=&f(a)\times g(a)\times f(b)\times g(b)\\
=&h(a)\times h(b)\\
\end{aligned}</script><h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 $ 4 $"></a>性质 $ 4 $</h3><blockquote>
<p>性质 $ 4 $ ：对于任何一个积性函数 $ f $ 和正整数 $ n,p $ ，$ g(n)=f(n^p) $ ，则 $ g $ 为积性函数。 </p>
</blockquote>
<p>显然，对于任意两个互质的正整数 $ a,b $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&g(ab)\\
=&f((ab)^p)\\
=&f(a^pb^p)\\
=&f(a^p)f(b^p)\\
=&g(a)g(b)
\end{aligned}</script><h3 id="性质-5"><a href="#性质-5" class="headerlink" title="性质 $ 5 $"></a>性质 $ 5 $</h3><blockquote>
<p>性质 $ 5 $ ：对于任何一个积性函数 $ f $ 和正整数 $ n,p $ ，$ g(n)=f^p(n) $ ，则 $ g $ 为积性函数。 </p>
</blockquote>
<p>显然，对于任意两个互质的正整数 $ a,b $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&g(ab)\\
=&f^p(ab)\\
=&(f(a)f(b))^p\\
=&f^p(a)f^p(b)\\
=&g(a)g(b)
\end{aligned}</script><h3 id="性质-6"><a href="#性质-6" class="headerlink" title="性质 $ 6 $"></a>性质 $ 6 $</h3><blockquote>
<p>性质 $ 6 $ ：对于任何两个积性函数 $ f,g $ ，$ h=f\ast g $ ，则 $ h $ 为积性函数。</p>
</blockquote>
<p>显然，对于任意两个互质的正整数 $ a,b $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h(ab)\\
=&\sum_{d|ab}f(d)g\left(\dfrac{ab}{d}\right)\\
=&\sum_{x|a}\sum_{y|b}f(xy)g\left(\dfrac{ab}{xy}\right)\\
=&\sum_{x|a}\sum_{y|b}f(x)f(y)g\left(\dfrac{a}{x}\right)g\left(\dfrac{b}{y}\right)\\
=&\left(\sum_{x|a}f(x)g\left(\dfrac{a}{x}\right)\right)\left(\sum_{y|b}f(y)g\left(\dfrac{b}{y}\right)\right)\\
=&h(a)h(b)
\end{aligned}</script><h3 id="性质-7"><a href="#性质-7" class="headerlink" title="性质 $ 7 $"></a>性质 $ 7 $</h3><blockquote>
<p>性质 $ 7 $ ：对于任何一个积性函数 $ f $ ，$ g=\varepsilon/f $ ，$ / $ 为狄利克雷卷积意义下的除法， $ g $ 为积性函数。</p>
</blockquote>
<p>移项，得：$ f\ast g=\varepsilon $ 。</p>
<p>这个应该得用数学归纳法才能证。</p>
<p>首先当 $ ab=1 $ 即 $ a=b=1 $ 时：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\ast g)(1)&=\varepsilon(1)\\
f(1)g(1)&=1\\
f(1)&=1
\end{aligned}</script><p>然后，我们假设对于所有的 $ 1\leqslant a’b’&lt;ab $ 都满足条件，我们来证 $ ab(\gcd(a,b)=1) $ 满足条件。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(f\ast g)(ab)&=\varepsilon(ab)\\
(f\ast g)(ab)&=0\\
\sum_{d|ab}g(d)f\left(\dfrac{ab}{d}\right)&=0\\
g(ab)&=-\sum_{d|ab\wedge d\ne ab}g(d)f\left(\dfrac{ab}{d}\right)\\
g(ab)&=-\sum_{x|a}\sum_{y|b\wedge xy\ne ab}g(xy)f\left(\dfrac{ab}{xy}\right)\\
g(ab)&=-\sum_{x|a}\sum_{y|b\wedge xy\ne ab}g(x)g(y)f\left(\dfrac{a}{x}\right)f\left(\dfrac{b}{y}\right)&xy<ab\\
g(ab)&=g(a)g(b)-\sum_{x|a}\sum_{y|b}g(x)g(y)f\left(\dfrac{a}{x}\right)f\left(\dfrac{b}{y}\right)\\
g(ab)&=g(a)g(b)-(\sum_{x|a}g(x)f\left(\dfrac{a}{x}\right))(\sum_{y|b}g(y)f\left(\dfrac{b}{y}\right))\\
g(ab)&=g(a)g(b)-\varepsilon(a)\varepsilon(b)\\
g(ab)&=g(a)g(b)\\
\end{aligned}</script><h3 id="性质-8"><a href="#性质-8" class="headerlink" title="性质 $ 8 $"></a>性质 $ 8 $</h3><blockquote>
<p>性质 $ 8 $ ：对于任意三个积性函数 $ f,g,h $ ，$ (f\ast g)\ast h=f\ast (g\ast h) $ 。</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
&((f\ast g)\ast h)(n)\\
=&\sum_{d|n}(f\ast g)(d)h\left(\dfrac{n}{d}\right)\\
=&\sum_{d|n}h\left(\dfrac{n}{d}\right)\sum_{d'|\frac{n}{d}}f(d')g\left(\dfrac{n}{dd'}\right)\\
=&\sum_{abc=n}f(a)g(b)h(c)\\
=&\sum_{d|n}f\left(\dfrac{n}{d}\right)\sum_{d'|\frac{n}{d}}g(d')h\left(\dfrac{n}{dd'}\right)\\
=&\sum_{d|n}(g\ast h)(d)f\left(\dfrac{n}{d}\right)\\
=&(f\ast(g\ast h))(n)
\end{aligned}</script><h2 id="常见积性函数"><a href="#常见积性函数" class="headerlink" title="常见积性函数"></a>常见积性函数</h2><p>$ \varepsilon(n)=[n=1] $ 原函数，$ n $ 为 $1  $ 时值为 $ 1 $ ，否则为 $ 0 $ 。<strong>是完全积性函数</strong>。</p>
<p>$ \varphi(n)=\sum\limits_{i=1}^n[\gcd(i,n)=1] $ 表示小于等于 $ n $ 的数中和 $ n $ 互质的数字个数。</p>
<p>$ \mu(n)=\begin{cases}<br>1&amp;n=1\\<br>(-1)^k&amp;n=p_1p_2\dots p_k\\<br>0&amp;\text{otherwise}<br>\end{cases}$ ，就是莫比乌斯函数。</p>
<p>$ I(n)=1 $，值永远为 $ 1 $ 。<strong>是完全积性函数</strong>。</p>
<p>$ id(n)=n $，就是值本身。<strong>是完全积性函数</strong>。</p>
<p>$ d(n)=\sum\limits_{d|n}1 $，约数个数。</p>
<p>$ \sigma(n)=\sum\limits_{d|n}d $，约数和。</p>
<h2 id="常见公式"><a href="#常见公式" class="headerlink" title="常见公式"></a>常见公式</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式 $ 1 $"></a>公式 $ 1 $</h3><p>$ \mu\ast I=\varepsilon $</p>
<p>证明：</p>
<p>对于任何质数 $ p $ 和正整数 $ c $ ，都有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\mu\ast I)(p^c)\\
=&\sum_{d|p^c}\mu(d)\\
=&\sum_{i=0}^c\mu(p^i)\\
=&\mu(1)+\mu(p)\\
=&1-1\\
=&0\\
=&\varepsilon(p^c)
\end{aligned}</script><p>所以这个公式对于所有 $ p^c $ 成立。</p>
<p>对于任何一个正整数 $ n=\prod\limits_{i=1}^kp_i^{q_i} $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\mu\ast I)(n)\\
=&(\mu\ast I)\left(\prod_{i=1}^kp_i^{q_i}\right)\\
=&\prod\limits_{i=1}^k(\mu\ast I)(p_i^{q_i})\\
=&\prod\limits_{i=1}^k\varepsilon(p_i^{q_i})\\
=&\varepsilon(n)
\end{aligned}</script><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式 $ 2 $"></a>公式 $ 2 $</h3><p>$ \varphi\ast I=id $</p>
<p>对于任何质数 $ p $ 和正整数 $ c $ ，都有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\varphi\ast I)(p^c)\\
=&\sum_{d|p^c}\varphi(d)\\
=&\sum_{i=0}^c\varphi(p^i)\\
=&1+\sum_{i=1}^c\varphi(p^i)\\
=&1+\sum_{i=1}^c(p^i-p^{i-1})\\
=&p^c\\
=&id(p^c)
\end{aligned}</script><p>所以这个公式对于所有 $ p^c $ 成立。</p>
<p>对于任何一个正整数 $ n=\prod\limits_{i=1}^kp_i^{q_i} $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\varphi\ast I)(n)\\
=&(\varphi\ast I)\left(\prod_{i=1}^kp_i^{q_i}\right)\\
=&\prod\limits_{i=1}^k(\varphi\ast I)(p_i^{q_i})\\
=&\prod\limits_{i=1}^kid(p_i^{q_i})\\
=&id(n)
\end{aligned}</script><h3 id="公式-3"><a href="#公式-3" class="headerlink" title="公式 $ 3 $"></a>公式 $ 3 $</h3><p>$ id\ast\mu=\varphi $</p>
<p>这个有点显然。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&id\ast\mu\\
=&\varphi\ast I\ast\mu\\
=&\varphi\ast\varepsilon\\
=&\varphi
\end{aligned}</script><h3 id="公式-4"><a href="#公式-4" class="headerlink" title="公式 $ 4 $"></a>公式 $ 4 $</h3><p>$ I\ast I=d $。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(I\ast I)(n)\\
=&\sum_{d|n}1\\
=&d(n)
\end{aligned}</script><h3 id="公式-5"><a href="#公式-5" class="headerlink" title="公式 $ 5 $"></a>公式 $ 5 $</h3><p>$ id\ast i=\sigma $</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(id\ast I)(n)\\
=&\sum_{d|n}d\\
=&\sigma(n)
\end{aligned}</script>]]></content>
      <categories>
        <category>公式推导</category>
      </categories>
      <tags>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title>类欧几里得算法</title>
    <url>/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>给定数字 $ a,b,c,n $ ，在 $ O(\log(a+c)) $ 时间内求出 $ \sum\limits_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor,\sum\limits_{i=0}^ni\left\lfloor\frac{ai+b}{c}\right\rfloor,\sum\limits_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor^2 $</p>
<span id="more"></span>
<p>令 $ f(a,b,c,n)=\sum\limits_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor,g(a,b,c,n)=\sum\limits_{i=0}^ni\left\lfloor\frac{ai+b}{c}\right\rfloor,h(a,b,c,n)=\sum\limits_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor^2 $ 。</p>
<h2 id="f的推导"><a href="#f的推导" class="headerlink" title="f的推导"></a>f的推导</h2><p>当 $ a\ge c $ 或 $ b\ge c $ 时，</p>
<p>令 $ a’=a \bmod c,b’=b\bmod c $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&f(a,b,c,n)\\
=&\sum_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor\\
=&\sum_{i=0}^n\left\lfloor\dfrac{(c\lfloor\frac{a}{c}\rfloor+a')i+(c\lfloor\frac{b}{c}\rfloor+b')}{c}\right\rfloor\\
=&\sum_{i=0}^n\left\lfloor\dfrac{a}{c}\right\rfloor i+\left\lfloor\dfrac{b}{c}\right\rfloor +\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor\\
=&\dfrac{n(n+1)}{2}\left\lfloor\dfrac{a}{c}\right\rfloor+(n+1)\left\lfloor\dfrac{b}{c}\right\rfloor+f(a',b',c,n)
\end{aligned}</script><p>否则，令 $ m=\left\lfloor\dfrac{an+b}{c}\right\rfloor $：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&f(a,b,c,n)\\
=&\sum_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor\\
=&\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[j<\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[j+1\le\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[cj+c\le ai+b\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[ai\ge cj+c-b\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[ai> cj+c-b-1\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^n\left[i>\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor\right]\\
=&\sum_{j=0}^{m-1}n-\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor\\
=&nm-\sum_{j=0}^{m-1}\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor\\
=&nm-f(c,c-b-1,a,m-1)
\end{aligned}</script><h2 id="g的推导"><a href="#g的推导" class="headerlink" title="g的推导"></a>g的推导</h2><p>当 $ a\ge c$ 或 $ b\ge c $ 时，</p>
<p>令 $ a’=a \bmod c,b’=b\bmod c $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&g(a,b,c,n)\\
=&\sum_{i=0}^ni\left\lfloor\dfrac{ai+b}{c}\right\rfloor\\
=&\sum_{i=0}^ni\left\lfloor\dfrac{(c\lfloor\frac{a}{c}\rfloor+a')i+(c\lfloor\frac{b}{c}\rfloor+b')}{c}\right\rfloor\\
=&\sum_{i=0}^n\left\lfloor\dfrac{a}{c}\right\rfloor i^2+\left\lfloor\dfrac{b}{c}\right\rfloor i+\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor\\
=&\dfrac{n(n+1)(2n+1)}{6}\left\lfloor\dfrac{a}{c}\right\rfloor+\dfrac{n(n+1)}{2}\left\lfloor\dfrac{b}{c}\right\rfloor+g(a',b',c,n)
\end{aligned}</script><p>否则，令 $ m=\left\lfloor\dfrac{an+b}{c}\right\rfloor,p=\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&g(a,b,c,n)\\
=&\sum_{i=0}^ni\left\lfloor\dfrac{ai+b}{c}\right\rfloor\\
=&\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}i\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[j<\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[j+1\le\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[cj+c\le ai+b\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[ai\ge cj+c-b\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[ai> cj+c-b-1\right]\\
=&\sum_{j=0}^{m-1}\sum_{i=0}^ni\left[i>p\right]\\
=&\sum_{j=0}^{m-1}\dfrac{(p+1+n)(n-p)}{2}\\
=&\sum_{j=0}^{m-1}\dfrac{n^2-p^2+n-p}{2}\\
=&\dfrac{n(n+1)m}{2}-\sum_{j=0}^{m-1}\dfrac{p^2+p}{2}\\
=&\dfrac{n(n+1)m-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)}{2}\\
\end{aligned}</script><h2 id="h的推导"><a href="#h的推导" class="headerlink" title="h的推导"></a>h的推导</h2><p>当 $ a\ge c$ 或 $ b\ge c $ 时，</p>
<p>令 $ a’=a \bmod c,b’=b\bmod c,x=\left\lfloor\dfrac{a}{c}\right\rfloor,y=\left\lfloor\dfrac{b}{c}\right\rfloor $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h(a,b,c,n)\\
=&\sum_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor^2\\
=&\sum_{i=0}^n\left\lfloor\dfrac{(cx+a')i+(cy+b')}{c}\right\rfloor^2\\
=&\sum_{i=0}^n\left(xi+y+\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor\right)^2\\
=&\sum_{i=0}^n\left(x^2 i^2+y^2 +\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor^2+2xyi+2xi\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor+2y\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor\right)\\
=&\dfrac{n(n+1)(2n+1)}{6}x^2+(n+1)y^2+2xy\dfrac{n(n+1)}{2}+\sum_{i=0}^n\left(\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor^2+2xi\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor+2y\left\lfloor\dfrac{a'i+b'}{c}\right\rfloor\right)\\
=&\dfrac{n(n+1)(2n+1)}{6}x^2+(n+1)y^2+xyn(n+1)+h(a',b',c,n)+2xg(a',b',c,n)+2yf(a',b',c,n)\\
\end{aligned}</script><p>否则，注意到 $ n^2=n(n+1)-n=\left(2\sum\limits_{i=0}^ni\right)-n $ 。</p>
<p>令 $ m=\left\lfloor\dfrac{an+b}{c}\right\rfloor,p=\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor $ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h(a,b,c,n)\\
=&\sum_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor^2\\
=&\sum_{i=0}^n\left(2\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor}j \right)-\left\lfloor\dfrac{ai+b}{c}\right\rfloor\\
=&2\left(\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor}j \right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^mj\sum_{i=0}^n\left[j\le\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^mj\sum_{i=0}^n\left[j\le\dfrac{ai+b}{c}\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^mj\sum_{i=0}^n[ai\ge cj-b]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^mj\sum_{i=0}^n[ai>cj-b-1]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^mj\sum_{i=0}^n\left[i>\dfrac{cj-b-1}{a}\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=1}^mj\sum_{i=0}^n\left[i>\dfrac{cj-b-1}{a}\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n\left[i>\dfrac{cj+c-b-1}{a}\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n\left[i>\left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n\left[i>p\right]\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^{m-1}(j+1)(n-p)\right)-f(a,b,c,n)\\
=&2\left(\sum_{j=0}^{m-1}j(n-p)\right)+2\left(\sum_{j=0}^{m-1}(n-p)\right)-f(a,b,c,n)\\
=&nm(m-1)-2\left(\sum_{j=0}^{m-1}jp\right)+2mn-2\left(\sum_{j=0}^{m-1}p\right)-f(a,b,c,n)\\
=&nm(m-1)-2g(c,c-b-1,a,m-1)+2mn-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\\
=&nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\\
\end{aligned}</script><p>三个函数一起算，时间复杂度为 $ O(\log (a+c)) $ 。</p>
]]></content>
      <categories>
        <category>算法学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>类欧</tag>
      </tags>
  </entry>
</search>
